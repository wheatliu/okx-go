/*
Okx Rest API

OpenAPI specification for Okx cryptocurrency exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SolStakingAPIService SolStakingAPI service
type SolStakingAPIService service

type ApiCreateFinanceStakingDefiSolPurchaseV5Request struct {
	ctx context.Context
	ApiService *SolStakingAPIService
	createFinanceStakingDefiSolPurchaseV5Req *CreateFinanceStakingDefiSolPurchaseV5Req
}

// The request body for CreateFinanceStaking-DefiSolPurchaseV5
func (r ApiCreateFinanceStakingDefiSolPurchaseV5Request) CreateFinanceStakingDefiSolPurchaseV5Req(createFinanceStakingDefiSolPurchaseV5Req CreateFinanceStakingDefiSolPurchaseV5Req) ApiCreateFinanceStakingDefiSolPurchaseV5Request {
	r.createFinanceStakingDefiSolPurchaseV5Req = &createFinanceStakingDefiSolPurchaseV5Req
	return r
}

func (r ApiCreateFinanceStakingDefiSolPurchaseV5Request) Execute() (*CreateFinanceStakingDefiSolPurchaseV5Resp, *http.Response, error) {
	return r.ApiService.CreateFinanceStakingDefiSolPurchaseV5Execute(r)
}

/*
CreateFinanceStakingDefiSolPurchaseV5 Staking SOL for OKSOL   Only the assets in the funding account can be used.    

Staking SOL for OKSOL


Only the assets in the funding account can be used.



#### Rate Limit: 2 requests per second 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFinanceStakingDefiSolPurchaseV5Request
*/
func (a *SolStakingAPIService) CreateFinanceStakingDefiSolPurchaseV5(ctx context.Context) ApiCreateFinanceStakingDefiSolPurchaseV5Request {
	return ApiCreateFinanceStakingDefiSolPurchaseV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateFinanceStakingDefiSolPurchaseV5Resp
func (a *SolStakingAPIService) CreateFinanceStakingDefiSolPurchaseV5Execute(r ApiCreateFinanceStakingDefiSolPurchaseV5Request) (*CreateFinanceStakingDefiSolPurchaseV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFinanceStakingDefiSolPurchaseV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolStakingAPIService.CreateFinanceStakingDefiSolPurchaseV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/finance/staking-defi/sol/purchase"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFinanceStakingDefiSolPurchaseV5Req == nil {
		return localVarReturnValue, nil, reportError("createFinanceStakingDefiSolPurchaseV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFinanceStakingDefiSolPurchaseV5Req

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFinanceStakingDefiSolRedeemV5Request struct {
	ctx context.Context
	ApiService *SolStakingAPIService
	createFinanceStakingDefiSolRedeemV5Req *CreateFinanceStakingDefiSolRedeemV5Req
}

// The request body for CreateFinanceStaking-DefiSolRedeemV5
func (r ApiCreateFinanceStakingDefiSolRedeemV5Request) CreateFinanceStakingDefiSolRedeemV5Req(createFinanceStakingDefiSolRedeemV5Req CreateFinanceStakingDefiSolRedeemV5Req) ApiCreateFinanceStakingDefiSolRedeemV5Request {
	r.createFinanceStakingDefiSolRedeemV5Req = &createFinanceStakingDefiSolRedeemV5Req
	return r
}

func (r ApiCreateFinanceStakingDefiSolRedeemV5Request) Execute() (*CreateFinanceStakingDefiSolRedeemV5Resp, *http.Response, error) {
	return r.ApiService.CreateFinanceStakingDefiSolRedeemV5Execute(r)
}

/*
CreateFinanceStakingDefiSolRedeemV5 Only the assets in the funding account can be used. If your OKSOL is in your trading account, you can make funding transfer first.    

Only the assets in the funding account can be used. If your OKSOL is in your trading account, you can make funding transfer first.



#### Rate Limit: 2 requests per second 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFinanceStakingDefiSolRedeemV5Request
*/
func (a *SolStakingAPIService) CreateFinanceStakingDefiSolRedeemV5(ctx context.Context) ApiCreateFinanceStakingDefiSolRedeemV5Request {
	return ApiCreateFinanceStakingDefiSolRedeemV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateFinanceStakingDefiSolRedeemV5Resp
func (a *SolStakingAPIService) CreateFinanceStakingDefiSolRedeemV5Execute(r ApiCreateFinanceStakingDefiSolRedeemV5Request) (*CreateFinanceStakingDefiSolRedeemV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFinanceStakingDefiSolRedeemV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolStakingAPIService.CreateFinanceStakingDefiSolRedeemV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/finance/staking-defi/sol/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFinanceStakingDefiSolRedeemV5Req == nil {
		return localVarReturnValue, nil, reportError("createFinanceStakingDefiSolRedeemV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFinanceStakingDefiSolRedeemV5Req

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFinanceStakingDefiSolApyHistoryV5Request struct {
	ctx context.Context
	ApiService *SolStakingAPIService
	days *string
}

// Get the days of APY(Annual percentage yield) history record in the past  No more than 365 days
func (r ApiGetFinanceStakingDefiSolApyHistoryV5Request) Days(days string) ApiGetFinanceStakingDefiSolApyHistoryV5Request {
	r.days = &days
	return r
}

func (r ApiGetFinanceStakingDefiSolApyHistoryV5Request) Execute() (*GetFinanceStakingDefiSolApyHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetFinanceStakingDefiSolApyHistoryV5Execute(r)
}

/*
GetFinanceStakingDefiSolApyHistoryV5 Public endpoints don't need authorization.  

Public endpoints don't need authorization.

#### Rate Limit: 6 requests per second 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFinanceStakingDefiSolApyHistoryV5Request
*/
func (a *SolStakingAPIService) GetFinanceStakingDefiSolApyHistoryV5(ctx context.Context) ApiGetFinanceStakingDefiSolApyHistoryV5Request {
	return ApiGetFinanceStakingDefiSolApyHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFinanceStakingDefiSolApyHistoryV5Resp
func (a *SolStakingAPIService) GetFinanceStakingDefiSolApyHistoryV5Execute(r ApiGetFinanceStakingDefiSolApyHistoryV5Request) (*GetFinanceStakingDefiSolApyHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFinanceStakingDefiSolApyHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolStakingAPIService.GetFinanceStakingDefiSolApyHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/finance/staking-defi/sol/apy-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.days == nil {
		return localVarReturnValue, nil, reportError("days is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFinanceStakingDefiSolBalanceV5Request struct {
	ctx context.Context
	ApiService *SolStakingAPIService
}

func (r ApiGetFinanceStakingDefiSolBalanceV5Request) Execute() (*GetFinanceStakingDefiSolBalanceV5Resp, *http.Response, error) {
	return r.ApiService.GetFinanceStakingDefiSolBalanceV5Execute(r)
}

/*
GetFinanceStakingDefiSolBalanceV5 The balance is summarized all OKSOL assets (including assets in redeeming) in account.  

The balance is summarized all OKSOL assets (including assets in redeeming) in account.

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFinanceStakingDefiSolBalanceV5Request
*/
func (a *SolStakingAPIService) GetFinanceStakingDefiSolBalanceV5(ctx context.Context) ApiGetFinanceStakingDefiSolBalanceV5Request {
	return ApiGetFinanceStakingDefiSolBalanceV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFinanceStakingDefiSolBalanceV5Resp
func (a *SolStakingAPIService) GetFinanceStakingDefiSolBalanceV5Execute(r ApiGetFinanceStakingDefiSolBalanceV5Request) (*GetFinanceStakingDefiSolBalanceV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFinanceStakingDefiSolBalanceV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolStakingAPIService.GetFinanceStakingDefiSolBalanceV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/finance/staking-defi/sol/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request struct {
	ctx context.Context
	ApiService *SolStakingAPIService
	type_ *string
	status *string
	after *string
	before *string
	limit *string
}

// Type  &#x60;purchase&#x60;  &#x60;redeem&#x60;
func (r ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request) Type_(type_ string) ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request {
	r.type_ = &type_
	return r
}

// Status  &#x60;pending&#x60;  &#x60;success&#x60;  &#x60;failed&#x60;
func (r ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request) Status(status string) ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request {
	r.status = &status
	return r
}

// Pagination of data to return records earlier than the &#x60;requestTime&#x60;. The value passed is the corresponding &#x60;timestamp&#x60;
func (r ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request) After(after string) ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the &#x60;requestTime&#x60;. The value passed is the corresponding &#x60;timestamp&#x60;
func (r ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request) Before(before string) ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The default is &#x60;100&#x60;. The maximum is &#x60;100&#x60;.
func (r ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request) Limit(limit string) ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request) Execute() (*GetFinanceStakingDefiSolPurchaseRedeemHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetFinanceStakingDefiSolPurchaseRedeemHistoryV5Execute(r)
}

/*
GetFinanceStakingDefiSolPurchaseRedeemHistoryV5 Method for GetFinanceStakingDefiSolPurchaseRedeemHistoryV5

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request
*/
func (a *SolStakingAPIService) GetFinanceStakingDefiSolPurchaseRedeemHistoryV5(ctx context.Context) ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request {
	return ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFinanceStakingDefiSolPurchaseRedeemHistoryV5Resp
func (a *SolStakingAPIService) GetFinanceStakingDefiSolPurchaseRedeemHistoryV5Execute(r ApiGetFinanceStakingDefiSolPurchaseRedeemHistoryV5Request) (*GetFinanceStakingDefiSolPurchaseRedeemHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFinanceStakingDefiSolPurchaseRedeemHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolStakingAPIService.GetFinanceStakingDefiSolPurchaseRedeemHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/finance/staking-defi/sol/purchase-redeem-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = ""
		r.status = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
