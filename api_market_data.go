/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"fmt"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MarketDataAPIService MarketDataAPI service
type MarketDataAPIService service

type ApiGetMarketBooksFullV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
	sz *string
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetMarketBooksFullV5Request) InstId(instId string) ApiGetMarketBooksFullV5Request {
	r.instId = &instId
	return r
}

// Order book depth per side. Maximum 5000, e.g. 5000 bids + 5000 asks    Default returns to &#x60;1&#x60; depth data.
func (r ApiGetMarketBooksFullV5Request) Sz(sz string) ApiGetMarketBooksFullV5Request {
	r.sz = &sz
	return r
}

func (r ApiGetMarketBooksFullV5Request) Execute() (*GetMarketBooksFullV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketBooksFullV5Execute(r)
}

/*
GetMarketBooksFullV5 Retrieve order book of the instrument. The data will be updated once a second.  

Retrieve order book of the instrument. The data will be updated once a second.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketBooksFullV5Request
*/
func (a *MarketDataAPIService) GetMarketBooksFullV5(ctx context.Context) ApiGetMarketBooksFullV5Request {
	return ApiGetMarketBooksFullV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketBooksFullV5Resp
func (a *MarketDataAPIService) GetMarketBooksFullV5Execute(r ApiGetMarketBooksFullV5Request) (*GetMarketBooksFullV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketBooksFullV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketBooksFullV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/books-full"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.sz != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sz", r.sz, "form", "")
	} else {
		var defaultValue string = ""
		r.sz = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketBooksV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
	sz *string
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetMarketBooksV5Request) InstId(instId string) ApiGetMarketBooksV5Request {
	r.instId = &instId
	return r
}

// Order book depth per side. Maximum 400, e.g. 400 bids + 400 asks   Default returns to &#x60;1&#x60; depth data
func (r ApiGetMarketBooksV5Request) Sz(sz string) ApiGetMarketBooksV5Request {
	r.sz = &sz
	return r
}

func (r ApiGetMarketBooksV5Request) Execute() (*GetMarketBooksV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketBooksV5Execute(r)
}

/*
GetMarketBooksV5 Retrieve order book of the instrument.  

Retrieve order book of the instrument.

#### Rate Limit: 40 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketBooksV5Request
*/
func (a *MarketDataAPIService) GetMarketBooksV5(ctx context.Context) ApiGetMarketBooksV5Request {
	return ApiGetMarketBooksV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketBooksV5Resp
func (a *MarketDataAPIService) GetMarketBooksV5Execute(r ApiGetMarketBooksV5Request) (*GetMarketBooksV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketBooksV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketBooksV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/books"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.sz != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sz", r.sz, "form", "")
	} else {
		var defaultValue string = ""
		r.sz = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketCallAuctionDetailsV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetMarketCallAuctionDetailsV5Request) InstId(instId string) ApiGetMarketCallAuctionDetailsV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetMarketCallAuctionDetailsV5Request) Execute() (*GetMarketCallAuctionDetailsV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketCallAuctionDetailsV5Execute(r)
}

/*
GetMarketCallAuctionDetailsV5 Retrieve call auction details.  

Retrieve call auction details.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketCallAuctionDetailsV5Request
*/
func (a *MarketDataAPIService) GetMarketCallAuctionDetailsV5(ctx context.Context) ApiGetMarketCallAuctionDetailsV5Request {
	return ApiGetMarketCallAuctionDetailsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketCallAuctionDetailsV5Resp
func (a *MarketDataAPIService) GetMarketCallAuctionDetailsV5Execute(r ApiGetMarketCallAuctionDetailsV5Request) (*GetMarketCallAuctionDetailsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketCallAuctionDetailsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketCallAuctionDetailsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/call-auction-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketCandlesV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
	bar *string
	after *string
	before *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetMarketCandlesV5Request) InstId(instId string) ApiGetMarketCandlesV5Request {
	r.instId = &instId
	return r
}

// Bar size, the default is &#x60;1m&#x60;  e.g. [1m/3m/5m/15m/30m/1H/2H/4H]   Hong Kong time opening price k-line: [6H/12H/1D/2D/3D/1W/1M/3M]  UTC time opening price k-line: [/6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/1Wutc/1Mutc/3Mutc]
func (r ApiGetMarketCandlesV5Request) Bar(bar string) ApiGetMarketCandlesV5Request {
	r.bar = &bar
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetMarketCandlesV5Request) After(after string) ApiGetMarketCandlesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;. The latest data will be returned when using &#x60;before&#x60; individually
func (r ApiGetMarketCandlesV5Request) Before(before string) ApiGetMarketCandlesV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;300&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetMarketCandlesV5Request) Limit(limit string) ApiGetMarketCandlesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketCandlesV5Request) Execute() (*GetMarketCandlesV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketCandlesV5Execute(r)
}

/*
GetMarketCandlesV5 Retrieve the candlestick charts. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.   

Retrieve the candlestick charts. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar. 

#### Rate Limit: 40 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketCandlesV5Request
*/
func (a *MarketDataAPIService) GetMarketCandlesV5(ctx context.Context) ApiGetMarketCandlesV5Request {
	return ApiGetMarketCandlesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketCandlesV5Resp
func (a *MarketDataAPIService) GetMarketCandlesV5Execute(r ApiGetMarketCandlesV5Request) (*GetMarketCandlesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketCandlesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketCandlesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "form", "")
	} else {
		var defaultValue string = ""
		r.bar = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketHistoryTradesV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
	type_ *string
	after *string
	before *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetMarketHistoryTradesV5Request) InstId(instId string) ApiGetMarketHistoryTradesV5Request {
	r.instId = &instId
	return r
}

// Pagination Type   &#x60;1&#x60;: tradeId &#x60;2&#x60;: timestamp  The default is &#x60;1&#x60;
func (r ApiGetMarketHistoryTradesV5Request) Type_(type_ string) ApiGetMarketHistoryTradesV5Request {
	r.type_ = &type_
	return r
}

// Pagination of data to return records earlier than the requested tradeId or ts.
func (r ApiGetMarketHistoryTradesV5Request) After(after string) ApiGetMarketHistoryTradesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested tradeId.   Do not support timestamp for pagination. The latest data will be returned when using &#x60;before&#x60; individually
func (r ApiGetMarketHistoryTradesV5Request) Before(before string) ApiGetMarketHistoryTradesV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum and default both are &#x60;100&#x60;
func (r ApiGetMarketHistoryTradesV5Request) Limit(limit string) ApiGetMarketHistoryTradesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketHistoryTradesV5Request) Execute() (*GetMarketHistoryTradesV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketHistoryTradesV5Execute(r)
}

/*
GetMarketHistoryTradesV5 Retrieve the recent transactions of an instrument from the last 3 months with pagination.  

Retrieve the recent transactions of an instrument from the last 3 months with pagination.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketHistoryTradesV5Request
*/
func (a *MarketDataAPIService) GetMarketHistoryTradesV5(ctx context.Context) ApiGetMarketHistoryTradesV5Request {
	return ApiGetMarketHistoryTradesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketHistoryTradesV5Resp
func (a *MarketDataAPIService) GetMarketHistoryTradesV5Execute(r ApiGetMarketHistoryTradesV5Request) (*GetMarketHistoryTradesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketHistoryTradesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketHistoryTradesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/history-trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketOptionInstrumentFamilyTradesV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instFamily *string
}

// Instrument family, e.g. BTC-USD  Applicable to &#x60;OPTION&#x60;
func (r ApiGetMarketOptionInstrumentFamilyTradesV5Request) InstFamily(instFamily string) ApiGetMarketOptionInstrumentFamilyTradesV5Request {
	r.instFamily = &instFamily
	return r
}

func (r ApiGetMarketOptionInstrumentFamilyTradesV5Request) Execute() (*GetMarketOptionInstrumentFamilyTradesV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketOptionInstrumentFamilyTradesV5Execute(r)
}

/*
GetMarketOptionInstrumentFamilyTradesV5 Retrieve the recent transactions of an instrument under same instFamily. The maximum is 100.  

Retrieve the recent transactions of an instrument under same instFamily. The maximum is 100.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketOptionInstrumentFamilyTradesV5Request
*/
func (a *MarketDataAPIService) GetMarketOptionInstrumentFamilyTradesV5(ctx context.Context) ApiGetMarketOptionInstrumentFamilyTradesV5Request {
	return ApiGetMarketOptionInstrumentFamilyTradesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketOptionInstrumentFamilyTradesV5Resp
func (a *MarketDataAPIService) GetMarketOptionInstrumentFamilyTradesV5Execute(r ApiGetMarketOptionInstrumentFamilyTradesV5Request) (*GetMarketOptionInstrumentFamilyTradesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketOptionInstrumentFamilyTradesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketOptionInstrumentFamilyTradesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/option/instrument-family-trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instFamily == nil {
		return localVarReturnValue, nil, reportError("instFamily is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketPlatform24VolumeV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
}

func (r ApiGetMarketPlatform24VolumeV5Request) Execute() (*GetMarketPlatform24VolumeV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketPlatform24VolumeV5Execute(r)
}

/*
GetMarketPlatform24VolumeV5 The 24-hour trading volume is calculated on a rolling basis.  

The 24-hour trading volume is calculated on a rolling basis.

#### Rate Limit: 2 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketPlatform24VolumeV5Request
*/
func (a *MarketDataAPIService) GetMarketPlatform24VolumeV5(ctx context.Context) ApiGetMarketPlatform24VolumeV5Request {
	return ApiGetMarketPlatform24VolumeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketPlatform24VolumeV5Resp
func (a *MarketDataAPIService) GetMarketPlatform24VolumeV5Execute(r ApiGetMarketPlatform24VolumeV5Request) (*GetMarketPlatform24VolumeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketPlatform24VolumeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketPlatform24VolumeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/platform-24-volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketTickerV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
}

// Instrument ID, e.g. &#x60;BTC-USD-SWAP&#x60;
func (r ApiGetMarketTickerV5Request) InstId(instId string) ApiGetMarketTickerV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetMarketTickerV5Request) Execute() (*GetMarketTickerV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketTickerV5Execute(r)
}

/*
GetMarketTickerV5 Retrieve the latest price snapshot, best bid/ask price, and trading volume in the last 24 hours.  

Retrieve the latest price snapshot, best bid/ask price, and trading volume in the last 24 hours.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketTickerV5Request
*/
func (a *MarketDataAPIService) GetMarketTickerV5(ctx context.Context) ApiGetMarketTickerV5Request {
	return ApiGetMarketTickerV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketTickerV5Resp
func (a *MarketDataAPIService) GetMarketTickerV5Execute(r ApiGetMarketTickerV5Request) (*GetMarketTickerV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketTickerV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketTickerV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketTickersV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instType *string
	uly *string
	instFamily *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetMarketTickersV5Request) InstType(instType string) ApiGetMarketTickersV5Request {
	r.instType = &instType
	return r
}

// Underlying, e.g. &#x60;BTC-USD&#x60;   Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetMarketTickersV5Request) Uly(uly string) ApiGetMarketTickersV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetMarketTickersV5Request) InstFamily(instFamily string) ApiGetMarketTickersV5Request {
	r.instFamily = &instFamily
	return r
}

func (r ApiGetMarketTickersV5Request) Execute() (*GetMarketTickersV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketTickersV5Execute(r)
}

/*
GetMarketTickersV5 Retrieve the latest price snapshot, best bid/ask price, and trading volume in the last 24 hours.  

Retrieve the latest price snapshot, best bid/ask price, and trading volume in the last 24 hours.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketTickersV5Request
*/
func (a *MarketDataAPIService) GetMarketTickersV5(ctx context.Context) ApiGetMarketTickersV5Request {
	return ApiGetMarketTickersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketTickersV5Resp
func (a *MarketDataAPIService) GetMarketTickersV5Execute(r ApiGetMarketTickersV5Request) (*GetMarketTickersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketTickersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketTickersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/tickers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketTradesV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetMarketTradesV5Request) InstId(instId string) ApiGetMarketTradesV5Request {
	r.instId = &instId
	return r
}

// Number of results per request. The maximum is &#x60;500&#x60;; The default is &#x60;100&#x60;
func (r ApiGetMarketTradesV5Request) Limit(limit string) ApiGetMarketTradesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketTradesV5Request) Execute() (*GetMarketTradesV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketTradesV5Execute(r)
}

/*
GetMarketTradesV5 Retrieve the recent transactions of an instrument.  

Retrieve the recent transactions of an instrument.

#### Rate Limit: 100 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketTradesV5Request
*/
func (a *MarketDataAPIService) GetMarketTradesV5(ctx context.Context) ApiGetMarketTradesV5Request {
	return ApiGetMarketTradesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketTradesV5Resp
func (a *MarketDataAPIService) GetMarketTradesV5Execute(r ApiGetMarketTradesV5Request) (*GetMarketTradesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketTradesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetMarketTradesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicOptionTradesV5Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	instId *string
	instFamily *string
	optType *string
}

// Instrument ID, e.g. BTC-USD-221230-4000-C, Either &#x60;instId&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instId&#x60; will be used.
func (r ApiGetPublicOptionTradesV5Request) InstId(instId string) ApiGetPublicOptionTradesV5Request {
	r.instId = &instId
	return r
}

// Instrument family, e.g. BTC-USD
func (r ApiGetPublicOptionTradesV5Request) InstFamily(instFamily string) ApiGetPublicOptionTradesV5Request {
	r.instFamily = &instFamily
	return r
}

// Option type, &#x60;C&#x60;: Call  &#x60;P&#x60;: put
func (r ApiGetPublicOptionTradesV5Request) OptType(optType string) ApiGetPublicOptionTradesV5Request {
	r.optType = &optType
	return r
}

func (r ApiGetPublicOptionTradesV5Request) Execute() (*GetPublicOptionTradesV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicOptionTradesV5Execute(r)
}

/*
GetPublicOptionTradesV5 The maximum is 100.  

The maximum is 100.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicOptionTradesV5Request
*/
func (a *MarketDataAPIService) GetPublicOptionTradesV5(ctx context.Context) ApiGetPublicOptionTradesV5Request {
	return ApiGetPublicOptionTradesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicOptionTradesV5Resp
func (a *MarketDataAPIService) GetPublicOptionTradesV5Execute(r ApiGetPublicOptionTradesV5Request) (*GetPublicOptionTradesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicOptionTradesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetPublicOptionTradesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/option-trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.optType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "optType", r.optType, "form", "")
	} else {
		var defaultValue string = ""
		r.optType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
