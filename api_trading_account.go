/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"fmt"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TradingAccountAPIService TradingAccountAPI service
type TradingAccountAPIService service

type ApiCreateAccountAccountLevelSwitchPresetV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountAccountLevelSwitchPresetV5Req *CreateAccountAccountLevelSwitchPresetV5Req
}

// The request body for CreateAccountAccountLevelSwitchPresetV5
func (r ApiCreateAccountAccountLevelSwitchPresetV5Request) CreateAccountAccountLevelSwitchPresetV5Req(createAccountAccountLevelSwitchPresetV5Req CreateAccountAccountLevelSwitchPresetV5Req) ApiCreateAccountAccountLevelSwitchPresetV5Request {
	r.createAccountAccountLevelSwitchPresetV5Req = &createAccountAccountLevelSwitchPresetV5Req
	return r
}

func (r ApiCreateAccountAccountLevelSwitchPresetV5Request) Execute() (*CreateAccountAccountLevelSwitchPresetV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountAccountLevelSwitchPresetV5Execute(r)
}

/*
CreateAccountAccountLevelSwitchPresetV5 Preset account mode switch

Pre-set the required information for account mode switching. When switching from `Portfolio margin mode` back to `Spot and futures mode` / `Multi-currency margin mode`, and if there are existing cross-margin contract positions, it is mandatory to pre-set leverage.

If the user does not follow the required settings, they will receive an error message during the pre-check or when setting the account mode.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountAccountLevelSwitchPresetV5Request
*/
func (a *TradingAccountAPIService) CreateAccountAccountLevelSwitchPresetV5(ctx context.Context) ApiCreateAccountAccountLevelSwitchPresetV5Request {
	return ApiCreateAccountAccountLevelSwitchPresetV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountAccountLevelSwitchPresetV5Resp
func (a *TradingAccountAPIService) CreateAccountAccountLevelSwitchPresetV5Execute(r ApiCreateAccountAccountLevelSwitchPresetV5Request) (*CreateAccountAccountLevelSwitchPresetV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountAccountLevelSwitchPresetV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountAccountLevelSwitchPresetV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/account-level-switch-preset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountAccountLevelSwitchPresetV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountAccountLevelSwitchPresetV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountAccountLevelSwitchPresetV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountActivateOptionV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
}

func (r ApiCreateAccountActivateOptionV5Request) Execute() (*CreateAccountActivateOptionV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountActivateOptionV5Execute(r)
}

/*
CreateAccountActivateOptionV5 Activate option

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountActivateOptionV5Request
*/
func (a *TradingAccountAPIService) CreateAccountActivateOptionV5(ctx context.Context) ApiCreateAccountActivateOptionV5Request {
	return ApiCreateAccountActivateOptionV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountActivateOptionV5Resp
func (a *TradingAccountAPIService) CreateAccountActivateOptionV5Execute(r ApiCreateAccountActivateOptionV5Request) (*CreateAccountActivateOptionV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountActivateOptionV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountActivateOptionV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/activate-option"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountBillsHistoryArchiveV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountBillsHistoryArchiveV5Req *CreateAccountBillsHistoryArchiveV5Req
}

// The request body for CreateAccountBillsHistoryArchiveV5
func (r ApiCreateAccountBillsHistoryArchiveV5Request) CreateAccountBillsHistoryArchiveV5Req(createAccountBillsHistoryArchiveV5Req CreateAccountBillsHistoryArchiveV5Req) ApiCreateAccountBillsHistoryArchiveV5Request {
	r.createAccountBillsHistoryArchiveV5Req = &createAccountBillsHistoryArchiveV5Req
	return r
}

func (r ApiCreateAccountBillsHistoryArchiveV5Request) Execute() (*CreateAccountBillsHistoryArchiveV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountBillsHistoryArchiveV5Execute(r)
}

/*
CreateAccountBillsHistoryArchiveV5 Apply bills details (since 2021)

Apply for bill data since 1 February, 2021 except for the current quarter.

#### Rate Limitï¼š12 requests per day 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountBillsHistoryArchiveV5Request
*/
func (a *TradingAccountAPIService) CreateAccountBillsHistoryArchiveV5(ctx context.Context) ApiCreateAccountBillsHistoryArchiveV5Request {
	return ApiCreateAccountBillsHistoryArchiveV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountBillsHistoryArchiveV5Resp
func (a *TradingAccountAPIService) CreateAccountBillsHistoryArchiveV5Execute(r ApiCreateAccountBillsHistoryArchiveV5Request) (*CreateAccountBillsHistoryArchiveV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountBillsHistoryArchiveV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountBillsHistoryArchiveV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/bills-history-archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountBillsHistoryArchiveV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountBillsHistoryArchiveV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountBillsHistoryArchiveV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountMmpConfigV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountMmpConfigV5Req *CreateAccountMmpConfigV5Req
}

// The request body for CreateAccountMmpConfigV5
func (r ApiCreateAccountMmpConfigV5Request) CreateAccountMmpConfigV5Req(createAccountMmpConfigV5Req CreateAccountMmpConfigV5Req) ApiCreateAccountMmpConfigV5Request {
	r.createAccountMmpConfigV5Req = &createAccountMmpConfigV5Req
	return r
}

func (r ApiCreateAccountMmpConfigV5Request) Execute() (*CreateAccountMmpConfigV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountMmpConfigV5Execute(r)
}

/*
CreateAccountMmpConfigV5 Set MMP

This endpoint is used to set MMP configure



Only applicable to Option in Portfolio Margin mode, and MMP privilege is required.

**_What is MMP?Market Maker Protection (MMP) is an automated mechanism for market makers to pull their quotes when their executions exceed a certain threshold(`qtyLimit`) within a certain time frame(`timeInterval`). Once mmp is triggered, any pre-existing mmp pending orders(`mmp` and `mmp_and_post_only` orders) will be automatically canceled, and new orders tagged as MMP will be rejected for a specific duration(`frozenInterval`), or until manual reset by makers.How to enable MMP?Please send an email to institutional@okx.com or contact your business development (BD) manager to apply for MMP. The initial threshold will be upon your request._**

#### Rate Limit: 2 requests per 10 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountMmpConfigV5Request
*/
func (a *TradingAccountAPIService) CreateAccountMmpConfigV5(ctx context.Context) ApiCreateAccountMmpConfigV5Request {
	return ApiCreateAccountMmpConfigV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountMmpConfigV5Resp
func (a *TradingAccountAPIService) CreateAccountMmpConfigV5Execute(r ApiCreateAccountMmpConfigV5Request) (*CreateAccountMmpConfigV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountMmpConfigV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountMmpConfigV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/mmp-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountMmpConfigV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountMmpConfigV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountMmpConfigV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountMmpResetV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountMmpResetV5Req *CreateAccountMmpResetV5Req
}

// The request body for CreateAccountMmpResetV5
func (r ApiCreateAccountMmpResetV5Request) CreateAccountMmpResetV5Req(createAccountMmpResetV5Req CreateAccountMmpResetV5Req) ApiCreateAccountMmpResetV5Request {
	r.createAccountMmpResetV5Req = &createAccountMmpResetV5Req
	return r
}

func (r ApiCreateAccountMmpResetV5Request) Execute() (*CreateAccountMmpResetV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountMmpResetV5Execute(r)
}

/*
CreateAccountMmpResetV5 Reset MMP Status

You can unfreeze by this endpoint once MMP is triggered.



Only applicable to Option in Portfolio Margin mode, and MMP privilege is required.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountMmpResetV5Request
*/
func (a *TradingAccountAPIService) CreateAccountMmpResetV5(ctx context.Context) ApiCreateAccountMmpResetV5Request {
	return ApiCreateAccountMmpResetV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountMmpResetV5Resp
func (a *TradingAccountAPIService) CreateAccountMmpResetV5Execute(r ApiCreateAccountMmpResetV5Request) (*CreateAccountMmpResetV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountMmpResetV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountMmpResetV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/mmp-reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountMmpResetV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountMmpResetV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountMmpResetV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountPositionBuilderV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountPositionBuilderV5Req *CreateAccountPositionBuilderV5Req
}

// The request body for CreateAccountPositionBuilderV5
func (r ApiCreateAccountPositionBuilderV5Request) CreateAccountPositionBuilderV5Req(createAccountPositionBuilderV5Req CreateAccountPositionBuilderV5Req) ApiCreateAccountPositionBuilderV5Request {
	r.createAccountPositionBuilderV5Req = &createAccountPositionBuilderV5Req
	return r
}

func (r ApiCreateAccountPositionBuilderV5Request) Execute() (*CreateAccountPositionBuilderV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountPositionBuilderV5Execute(r)
}

/*
CreateAccountPositionBuilderV5 Position builder (new)

Calculates portfolio margin information for virtual position/assets or current position of the user.


You can add up to 200 virtual positions and 200 virtual assets in one request.

#### Rate Limit: 2 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountPositionBuilderV5Request
*/
func (a *TradingAccountAPIService) CreateAccountPositionBuilderV5(ctx context.Context) ApiCreateAccountPositionBuilderV5Request {
	return ApiCreateAccountPositionBuilderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountPositionBuilderV5Resp
func (a *TradingAccountAPIService) CreateAccountPositionBuilderV5Execute(r ApiCreateAccountPositionBuilderV5Request) (*CreateAccountPositionBuilderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountPositionBuilderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountPositionBuilderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/position-builder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountPositionBuilderV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountPositionBuilderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountPositionBuilderV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountPositionMarginBalanceV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountPositionMarginBalanceV5Req *CreateAccountPositionMarginBalanceV5Req
}

// The request body for CreateAccountPositionMarginBalanceV5
func (r ApiCreateAccountPositionMarginBalanceV5Request) CreateAccountPositionMarginBalanceV5Req(createAccountPositionMarginBalanceV5Req CreateAccountPositionMarginBalanceV5Req) ApiCreateAccountPositionMarginBalanceV5Request {
	r.createAccountPositionMarginBalanceV5Req = &createAccountPositionMarginBalanceV5Req
	return r
}

func (r ApiCreateAccountPositionMarginBalanceV5Request) Execute() (*CreateAccountPositionMarginBalanceV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountPositionMarginBalanceV5Execute(r)
}

/*
CreateAccountPositionMarginBalanceV5 Increase/decrease margin

Increase or decrease the margin of the isolated position. Margin reduction may result in the change of the actual leverage.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountPositionMarginBalanceV5Request
*/
func (a *TradingAccountAPIService) CreateAccountPositionMarginBalanceV5(ctx context.Context) ApiCreateAccountPositionMarginBalanceV5Request {
	return ApiCreateAccountPositionMarginBalanceV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountPositionMarginBalanceV5Resp
func (a *TradingAccountAPIService) CreateAccountPositionMarginBalanceV5Execute(r ApiCreateAccountPositionMarginBalanceV5Request) (*CreateAccountPositionMarginBalanceV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountPositionMarginBalanceV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountPositionMarginBalanceV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/position/margin-balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountPositionMarginBalanceV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountPositionMarginBalanceV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountPositionMarginBalanceV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountQuickMarginBorrowRepayV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountQuickMarginBorrowRepayV5Req *CreateAccountQuickMarginBorrowRepayV5Req
}

// The request body for CreateAccountQuickMarginBorrowRepayV5
func (r ApiCreateAccountQuickMarginBorrowRepayV5Request) CreateAccountQuickMarginBorrowRepayV5Req(createAccountQuickMarginBorrowRepayV5Req CreateAccountQuickMarginBorrowRepayV5Req) ApiCreateAccountQuickMarginBorrowRepayV5Request {
	r.createAccountQuickMarginBorrowRepayV5Req = &createAccountQuickMarginBorrowRepayV5Req
	return r
}

func (r ApiCreateAccountQuickMarginBorrowRepayV5Request) Execute() (*CreateAccountQuickMarginBorrowRepayV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountQuickMarginBorrowRepayV5Execute(r)
}

/*
CreateAccountQuickMarginBorrowRepayV5 Manual borrow and repay in Quick Margin Mode

Please note that this endpoint will be deprecated soon.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountQuickMarginBorrowRepayV5Request
*/
func (a *TradingAccountAPIService) CreateAccountQuickMarginBorrowRepayV5(ctx context.Context) ApiCreateAccountQuickMarginBorrowRepayV5Request {
	return ApiCreateAccountQuickMarginBorrowRepayV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountQuickMarginBorrowRepayV5Resp
func (a *TradingAccountAPIService) CreateAccountQuickMarginBorrowRepayV5Execute(r ApiCreateAccountQuickMarginBorrowRepayV5Request) (*CreateAccountQuickMarginBorrowRepayV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountQuickMarginBorrowRepayV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountQuickMarginBorrowRepayV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/quick-margin-borrow-repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountQuickMarginBorrowRepayV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountQuickMarginBorrowRepayV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountQuickMarginBorrowRepayV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetAccountLevelV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetAccountLevelV5Req *CreateAccountSetAccountLevelV5Req
}

// The request body for CreateAccountSetAccountLevelV5
func (r ApiCreateAccountSetAccountLevelV5Request) CreateAccountSetAccountLevelV5Req(createAccountSetAccountLevelV5Req CreateAccountSetAccountLevelV5Req) ApiCreateAccountSetAccountLevelV5Request {
	r.createAccountSetAccountLevelV5Req = &createAccountSetAccountLevelV5Req
	return r
}

func (r ApiCreateAccountSetAccountLevelV5Request) Execute() (*CreateAccountSetAccountLevelV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetAccountLevelV5Execute(r)
}

/*
CreateAccountSetAccountLevelV5 Set account mode

You need to set on the Web/App for the first set of every account mode. If users plan to switch account modes while holding positions, they should first call the preset endpoint to conduct necessary settings, then call the precheck endpoint to get unmatched information, margin check, and other related information, and finally call the account mode switch endpoint to switch account modes.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetAccountLevelV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetAccountLevelV5(ctx context.Context) ApiCreateAccountSetAccountLevelV5Request {
	return ApiCreateAccountSetAccountLevelV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetAccountLevelV5Resp
func (a *TradingAccountAPIService) CreateAccountSetAccountLevelV5Execute(r ApiCreateAccountSetAccountLevelV5Request) (*CreateAccountSetAccountLevelV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetAccountLevelV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetAccountLevelV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-account-level"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetAccountLevelV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetAccountLevelV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetAccountLevelV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetAutoLoanV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetAutoLoanV5Req *CreateAccountSetAutoLoanV5Req
}

// The request body for CreateAccountSetAutoLoanV5
func (r ApiCreateAccountSetAutoLoanV5Request) CreateAccountSetAutoLoanV5Req(createAccountSetAutoLoanV5Req CreateAccountSetAutoLoanV5Req) ApiCreateAccountSetAutoLoanV5Request {
	r.createAccountSetAutoLoanV5Req = &createAccountSetAutoLoanV5Req
	return r
}

func (r ApiCreateAccountSetAutoLoanV5Request) Execute() (*CreateAccountSetAutoLoanV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetAutoLoanV5Execute(r)
}

/*
CreateAccountSetAutoLoanV5 Set auto loan

Only applicable to `Multi-currency margin` and `Portfolio margin`

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetAutoLoanV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetAutoLoanV5(ctx context.Context) ApiCreateAccountSetAutoLoanV5Request {
	return ApiCreateAccountSetAutoLoanV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetAutoLoanV5Resp
func (a *TradingAccountAPIService) CreateAccountSetAutoLoanV5Execute(r ApiCreateAccountSetAutoLoanV5Request) (*CreateAccountSetAutoLoanV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetAutoLoanV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetAutoLoanV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-auto-loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetAutoLoanV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetAutoLoanV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetAutoLoanV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetAutoRepayV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetAutoRepayV5Req *CreateAccountSetAutoRepayV5Req
}

// The request body for CreateAccountSetAutoRepayV5
func (r ApiCreateAccountSetAutoRepayV5Request) CreateAccountSetAutoRepayV5Req(createAccountSetAutoRepayV5Req CreateAccountSetAutoRepayV5Req) ApiCreateAccountSetAutoRepayV5Request {
	r.createAccountSetAutoRepayV5Req = &createAccountSetAutoRepayV5Req
	return r
}

func (r ApiCreateAccountSetAutoRepayV5Request) Execute() (*CreateAccountSetAutoRepayV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetAutoRepayV5Execute(r)
}

/*
CreateAccountSetAutoRepayV5 Set auto repay

Only applicable to `Spot mode` (enabled borrowing)

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetAutoRepayV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetAutoRepayV5(ctx context.Context) ApiCreateAccountSetAutoRepayV5Request {
	return ApiCreateAccountSetAutoRepayV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetAutoRepayV5Resp
func (a *TradingAccountAPIService) CreateAccountSetAutoRepayV5Execute(r ApiCreateAccountSetAutoRepayV5Request) (*CreateAccountSetAutoRepayV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetAutoRepayV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetAutoRepayV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-auto-repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetAutoRepayV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetAutoRepayV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetAutoRepayV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetCollateralAssetsV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetCollateralAssetsV5Req *CreateAccountSetCollateralAssetsV5Req
}

// The request body for CreateAccountSetCollateralAssetsV5
func (r ApiCreateAccountSetCollateralAssetsV5Request) CreateAccountSetCollateralAssetsV5Req(createAccountSetCollateralAssetsV5Req CreateAccountSetCollateralAssetsV5Req) ApiCreateAccountSetCollateralAssetsV5Request {
	r.createAccountSetCollateralAssetsV5Req = &createAccountSetCollateralAssetsV5Req
	return r
}

func (r ApiCreateAccountSetCollateralAssetsV5Request) Execute() (*CreateAccountSetCollateralAssetsV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetCollateralAssetsV5Execute(r)
}

/*
CreateAccountSetCollateralAssetsV5 Set collateral assets

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetCollateralAssetsV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetCollateralAssetsV5(ctx context.Context) ApiCreateAccountSetCollateralAssetsV5Request {
	return ApiCreateAccountSetCollateralAssetsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetCollateralAssetsV5Resp
func (a *TradingAccountAPIService) CreateAccountSetCollateralAssetsV5Execute(r ApiCreateAccountSetCollateralAssetsV5Request) (*CreateAccountSetCollateralAssetsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetCollateralAssetsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetCollateralAssetsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-collateral-assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetCollateralAssetsV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetCollateralAssetsV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetCollateralAssetsV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetGreeksV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetGreeksV5Req *CreateAccountSetGreeksV5Req
}

// The request body for CreateAccountSetGreeksV5
func (r ApiCreateAccountSetGreeksV5Request) CreateAccountSetGreeksV5Req(createAccountSetGreeksV5Req CreateAccountSetGreeksV5Req) ApiCreateAccountSetGreeksV5Request {
	r.createAccountSetGreeksV5Req = &createAccountSetGreeksV5Req
	return r
}

func (r ApiCreateAccountSetGreeksV5Request) Execute() (*CreateAccountSetGreeksV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetGreeksV5Execute(r)
}

/*
CreateAccountSetGreeksV5 Set greeks (PA/BS)

Set the display type of Greeks.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetGreeksV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetGreeksV5(ctx context.Context) ApiCreateAccountSetGreeksV5Request {
	return ApiCreateAccountSetGreeksV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetGreeksV5Resp
func (a *TradingAccountAPIService) CreateAccountSetGreeksV5Execute(r ApiCreateAccountSetGreeksV5Request) (*CreateAccountSetGreeksV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetGreeksV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetGreeksV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-greeks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetGreeksV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetGreeksV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetGreeksV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetIsolatedModeV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetIsolatedModeV5Req *CreateAccountSetIsolatedModeV5Req
}

// The request body for CreateAccountSetIsolatedModeV5
func (r ApiCreateAccountSetIsolatedModeV5Request) CreateAccountSetIsolatedModeV5Req(createAccountSetIsolatedModeV5Req CreateAccountSetIsolatedModeV5Req) ApiCreateAccountSetIsolatedModeV5Request {
	r.createAccountSetIsolatedModeV5Req = &createAccountSetIsolatedModeV5Req
	return r
}

func (r ApiCreateAccountSetIsolatedModeV5Request) Execute() (*CreateAccountSetIsolatedModeV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetIsolatedModeV5Execute(r)
}

/*
CreateAccountSetIsolatedModeV5 Isolated margin trading settings

You can set the currency margin and futures/perpetual Isolated margin trading mode

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetIsolatedModeV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetIsolatedModeV5(ctx context.Context) ApiCreateAccountSetIsolatedModeV5Request {
	return ApiCreateAccountSetIsolatedModeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetIsolatedModeV5Resp
func (a *TradingAccountAPIService) CreateAccountSetIsolatedModeV5Execute(r ApiCreateAccountSetIsolatedModeV5Request) (*CreateAccountSetIsolatedModeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetIsolatedModeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetIsolatedModeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-isolated-mode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetIsolatedModeV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetIsolatedModeV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetIsolatedModeV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetLeverageV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetLeverageV5Req *CreateAccountSetLeverageV5Req
}

// The request body for CreateAccountSetLeverageV5
func (r ApiCreateAccountSetLeverageV5Request) CreateAccountSetLeverageV5Req(createAccountSetLeverageV5Req CreateAccountSetLeverageV5Req) ApiCreateAccountSetLeverageV5Request {
	r.createAccountSetLeverageV5Req = &createAccountSetLeverageV5Req
	return r
}

func (r ApiCreateAccountSetLeverageV5Request) Execute() (*CreateAccountSetLeverageV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetLeverageV5Execute(r)
}

/*
CreateAccountSetLeverageV5 Set leverage



There are 10 different scenarios for leverage setting: 




1. Set leverage for `MARGIN` instruments under `isolated-margin` trade mode at pairs level. 


2. Set leverage for `MARGIN` instruments under `cross-margin` trade mode and Spot mode (enabled borrow) at currency level. 


3. Set leverage for `MARGIN` instruments under `cross-margin` trade mode and Spot and futures mode account mode at pairs level. 


4. Set leverage for `MARGIN` instruments under `cross-margin` trade mode and Multi-currency margin at currency level. 


5. Set leverage for `MARGIN` instruments under `cross-margin` trade mode and Portfolio margin at currency level. 


6. Set leverage for `FUTURES` instruments under `cross-margin` trade mode at underlying level. 


7. Set leverage for `FUTURES` instruments under `isolated-margin` trade mode and buy/sell position mode at contract level. 


8. Set leverage for `FUTURES` instruments under `isolated-margin` trade mode and long/short position mode at contract and position side level. 


9. Set leverage for `SWAP` instruments under `cross-margin` trade at contract level. 


10. Set leverage for `SWAP` instruments under `isolated-margin` trade mode and buy/sell position mode at contract level. 


11. Set leverage for `SWAP` instruments under `isolated-margin` trade mode and long/short position mode at contract and position side level. 





Note that the request parameter `posSide` is only required when margin mode is isolated in long/short position mode for FUTURES/SWAP instruments (see scenario 8 and 11 above). 


Please refer to the request examples on the right for each case. 



#### Rate limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetLeverageV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetLeverageV5(ctx context.Context) ApiCreateAccountSetLeverageV5Request {
	return ApiCreateAccountSetLeverageV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetLeverageV5Resp
func (a *TradingAccountAPIService) CreateAccountSetLeverageV5Execute(r ApiCreateAccountSetLeverageV5Request) (*CreateAccountSetLeverageV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetLeverageV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetLeverageV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetLeverageV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetLeverageV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetLeverageV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetPositionModeV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetPositionModeV5Req *CreateAccountSetPositionModeV5Req
}

// The request body for CreateAccountSetPositionModeV5
func (r ApiCreateAccountSetPositionModeV5Request) CreateAccountSetPositionModeV5Req(createAccountSetPositionModeV5Req CreateAccountSetPositionModeV5Req) ApiCreateAccountSetPositionModeV5Request {
	r.createAccountSetPositionModeV5Req = &createAccountSetPositionModeV5Req
	return r
}

func (r ApiCreateAccountSetPositionModeV5Request) Execute() (*CreateAccountSetPositionModeV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetPositionModeV5Execute(r)
}

/*
CreateAccountSetPositionModeV5 Set position mode

Spot and futures mode and Multi-currency mode: `FUTURES` and `SWAP` support both `long/short` mode and `net` mode. In `net` mode, users can only have positions in one direction; In `long/short` mode, users can hold positions in long and short directions.


Portfolio margin mode: `FUTURES` and `SWAP` only support `net` mode

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetPositionModeV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetPositionModeV5(ctx context.Context) ApiCreateAccountSetPositionModeV5Request {
	return ApiCreateAccountSetPositionModeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetPositionModeV5Resp
func (a *TradingAccountAPIService) CreateAccountSetPositionModeV5Execute(r ApiCreateAccountSetPositionModeV5Request) (*CreateAccountSetPositionModeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetPositionModeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetPositionModeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-position-mode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetPositionModeV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetPositionModeV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetPositionModeV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSetRiskOffsetAmtV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSetRiskOffsetAmtV5Req *CreateAccountSetRiskOffsetAmtV5Req
}

// The request body for CreateAccountSetRiskOffsetAmtV5
func (r ApiCreateAccountSetRiskOffsetAmtV5Request) CreateAccountSetRiskOffsetAmtV5Req(createAccountSetRiskOffsetAmtV5Req CreateAccountSetRiskOffsetAmtV5Req) ApiCreateAccountSetRiskOffsetAmtV5Request {
	r.createAccountSetRiskOffsetAmtV5Req = &createAccountSetRiskOffsetAmtV5Req
	return r
}

func (r ApiCreateAccountSetRiskOffsetAmtV5Request) Execute() (*CreateAccountSetRiskOffsetAmtV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSetRiskOffsetAmtV5Execute(r)
}

/*
CreateAccountSetRiskOffsetAmtV5 Set risk offset amount

Set risk offset amount. This does not represent the actual spot risk offset amount. Only applicable to Portfolio Margin Mode.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSetRiskOffsetAmtV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSetRiskOffsetAmtV5(ctx context.Context) ApiCreateAccountSetRiskOffsetAmtV5Request {
	return ApiCreateAccountSetRiskOffsetAmtV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSetRiskOffsetAmtV5Resp
func (a *TradingAccountAPIService) CreateAccountSetRiskOffsetAmtV5Execute(r ApiCreateAccountSetRiskOffsetAmtV5Request) (*CreateAccountSetRiskOffsetAmtV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSetRiskOffsetAmtV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSetRiskOffsetAmtV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-riskOffset-amt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSetRiskOffsetAmtV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSetRiskOffsetAmtV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSetRiskOffsetAmtV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSpotManualBorrowRepayV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	createAccountSpotManualBorrowRepayV5Req *CreateAccountSpotManualBorrowRepayV5Req
}

// The request body for CreateAccountSpotManualBorrowRepayV5
func (r ApiCreateAccountSpotManualBorrowRepayV5Request) CreateAccountSpotManualBorrowRepayV5Req(createAccountSpotManualBorrowRepayV5Req CreateAccountSpotManualBorrowRepayV5Req) ApiCreateAccountSpotManualBorrowRepayV5Request {
	r.createAccountSpotManualBorrowRepayV5Req = &createAccountSpotManualBorrowRepayV5Req
	return r
}

func (r ApiCreateAccountSpotManualBorrowRepayV5Request) Execute() (*CreateAccountSpotManualBorrowRepayV5Resp, *http.Response, error) {
	return r.ApiService.CreateAccountSpotManualBorrowRepayV5Execute(r)
}

/*
CreateAccountSpotManualBorrowRepayV5 Manual borrow / repay

Only applicable to `Spot mode` (enabled borrowing)

#### Rate Limit: 1 request per second 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountSpotManualBorrowRepayV5Request
*/
func (a *TradingAccountAPIService) CreateAccountSpotManualBorrowRepayV5(ctx context.Context) ApiCreateAccountSpotManualBorrowRepayV5Request {
	return ApiCreateAccountSpotManualBorrowRepayV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccountSpotManualBorrowRepayV5Resp
func (a *TradingAccountAPIService) CreateAccountSpotManualBorrowRepayV5Execute(r ApiCreateAccountSpotManualBorrowRepayV5Request) (*CreateAccountSpotManualBorrowRepayV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccountSpotManualBorrowRepayV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.CreateAccountSpotManualBorrowRepayV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/spot-manual-borrow-repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountSpotManualBorrowRepayV5Req == nil {
		return localVarReturnValue, nil, reportError("createAccountSpotManualBorrowRepayV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountSpotManualBorrowRepayV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountAccountPositionRiskV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
}

// Instrument type  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetAccountAccountPositionRiskV5Request) InstType(instType string) ApiGetAccountAccountPositionRiskV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetAccountAccountPositionRiskV5Request) Execute() (*GetAccountAccountPositionRiskV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountAccountPositionRiskV5Execute(r)
}

/*
GetAccountAccountPositionRiskV5 Get account and position risk

Get account and position risk

**_Obtain basic information about accounts and positions on the same time snapshot_**

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountAccountPositionRiskV5Request
*/
func (a *TradingAccountAPIService) GetAccountAccountPositionRiskV5(ctx context.Context) ApiGetAccountAccountPositionRiskV5Request {
	return ApiGetAccountAccountPositionRiskV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountAccountPositionRiskV5Resp
func (a *TradingAccountAPIService) GetAccountAccountPositionRiskV5Execute(r ApiGetAccountAccountPositionRiskV5Request) (*GetAccountAccountPositionRiskV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountAccountPositionRiskV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountAccountPositionRiskV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/account-position-risk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountAdjustLeverageInfoV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	mgnMode *string
	lever *string
	instId *string
	ccy *string
	posSide *string
}

// Instrument type  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;
func (r ApiGetAccountAdjustLeverageInfoV5Request) InstType(instType string) ApiGetAccountAdjustLeverageInfoV5Request {
	r.instType = &instType
	return r
}

// Margin mode  &#x60;isolated&#x60;  &#x60;cross&#x60;
func (r ApiGetAccountAdjustLeverageInfoV5Request) MgnMode(mgnMode string) ApiGetAccountAdjustLeverageInfoV5Request {
	r.mgnMode = &mgnMode
	return r
}

// Leverage
func (r ApiGetAccountAdjustLeverageInfoV5Request) Lever(lever string) ApiGetAccountAdjustLeverageInfoV5Request {
	r.lever = &lever
	return r
}

// Instrument ID, e.g. BTC-USDT  It is required for these scenarioes: &#x60;SWAP&#x60; and &#x60;FUTURES&#x60;, Margin isolation, Margin cross in &#x60;Spot and futures mode&#x60;.
func (r ApiGetAccountAdjustLeverageInfoV5Request) InstId(instId string) ApiGetAccountAdjustLeverageInfoV5Request {
	r.instId = &instId
	return r
}

// Currency used for margin, e.g. BTC  It is required for isolated margin and cross margin in &#x60;Spot and futures mode&#x60;, &#x60;Multi-currency margin&#x60; and &#x60;Portfolio margin&#x60;
func (r ApiGetAccountAdjustLeverageInfoV5Request) Ccy(ccy string) ApiGetAccountAdjustLeverageInfoV5Request {
	r.ccy = &ccy
	return r
}

// posSide  &#x60;net&#x60;: The default value  &#x60;long&#x60;  &#x60;short&#x60;
func (r ApiGetAccountAdjustLeverageInfoV5Request) PosSide(posSide string) ApiGetAccountAdjustLeverageInfoV5Request {
	r.posSide = &posSide
	return r
}

func (r ApiGetAccountAdjustLeverageInfoV5Request) Execute() (*GetAccountAdjustLeverageInfoV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountAdjustLeverageInfoV5Execute(r)
}

/*
GetAccountAdjustLeverageInfoV5 Get leverage estimated info

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountAdjustLeverageInfoV5Request
*/
func (a *TradingAccountAPIService) GetAccountAdjustLeverageInfoV5(ctx context.Context) ApiGetAccountAdjustLeverageInfoV5Request {
	return ApiGetAccountAdjustLeverageInfoV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountAdjustLeverageInfoV5Resp
func (a *TradingAccountAPIService) GetAccountAdjustLeverageInfoV5Execute(r ApiGetAccountAdjustLeverageInfoV5Request) (*GetAccountAdjustLeverageInfoV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountAdjustLeverageInfoV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountAdjustLeverageInfoV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/adjust-leverage-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}
	if r.mgnMode == nil {
		return localVarReturnValue, nil, reportError("mgnMode is required and must be specified")
	}
	if r.lever == nil {
		return localVarReturnValue, nil, reportError("lever is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mgnMode", r.mgnMode, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "lever", r.lever, "form", "")
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.posSide != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "posSide", r.posSide, "form", "")
	} else {
		var defaultValue string = ""
		r.posSide = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountBalanceV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	ccy *string
}

// Single currency or multiple currencies (no more than 20) separated with comma, e.g. &#x60;BTC&#x60; or &#x60;BTC,ETH&#x60;.
func (r ApiGetAccountBalanceV5Request) Ccy(ccy string) ApiGetAccountBalanceV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAccountBalanceV5Request) Execute() (*GetAccountBalanceV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountBalanceV5Execute(r)
}

/*
GetAccountBalanceV5 Get balance

Retrieve a list of assets (with non-zero balance), remaining balance, and available amount in the trading account.

**_Interest-free quota and discount rates are public data and not displayed on the account interface._**

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountBalanceV5Request
*/
func (a *TradingAccountAPIService) GetAccountBalanceV5(ctx context.Context) ApiGetAccountBalanceV5Request {
	return ApiGetAccountBalanceV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountBalanceV5Resp
func (a *TradingAccountAPIService) GetAccountBalanceV5Execute(r ApiGetAccountBalanceV5Request) (*GetAccountBalanceV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountBalanceV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountBalanceV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountBillsArchiveV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	instId *string
	ccy *string
	mgnMode *string
	ctType *string
	type_ *string
	subType *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetAccountBillsArchiveV5Request) InstType(instType string) ApiGetAccountBillsArchiveV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetAccountBillsArchiveV5Request) InstId(instId string) ApiGetAccountBillsArchiveV5Request {
	r.instId = &instId
	return r
}

// Bill currency
func (r ApiGetAccountBillsArchiveV5Request) Ccy(ccy string) ApiGetAccountBillsArchiveV5Request {
	r.ccy = &ccy
	return r
}

// Margin mode  &#x60;isolated&#x60;  &#x60;cross&#x60;
func (r ApiGetAccountBillsArchiveV5Request) MgnMode(mgnMode string) ApiGetAccountBillsArchiveV5Request {
	r.mgnMode = &mgnMode
	return r
}

// Contract type  &#x60;linear&#x60;  &#x60;inverse&#x60;  Only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;
func (r ApiGetAccountBillsArchiveV5Request) CtType(ctType string) ApiGetAccountBillsArchiveV5Request {
	r.ctType = &ctType
	return r
}

// Bill type  &#x60;1&#x60;: Transfer  &#x60;2&#x60;: Trade  &#x60;3&#x60;: Delivery  &#x60;4&#x60;: Forced repayment  &#x60;5&#x60;: Liquidation  &#x60;6&#x60;: Margin transfer  &#x60;7&#x60;: Interest deduction  &#x60;8&#x60;: Funding fee  &#x60;9&#x60;: ADL  &#x60;10&#x60;: Clawback  &#x60;11&#x60;: System token conversion  &#x60;12&#x60;: Strategy transfer  &#x60;13&#x60;: DDH  &#x60;14&#x60;: Block trade  &#x60;15&#x60;: Quick Margin  &#x60;16&#x60;: Borrowing  &#x60;22&#x60;: Repay  &#x60;24&#x60;: Spread trading  &#x60;26&#x60;: Structured products  &#x60;27&#x60;: Convert  &#x60;28&#x60;: Easy convert  &#x60;29&#x60;: One-click repay  &#x60;30&#x60;: Simple trade  &#x60;33&#x60;: Loans  &#x60;34&#x60;: Settlement  &#x60;250&#x60;: Copy trader profit sharing expenses  &#x60;251&#x60;: Copy trader profit sharing refund
func (r ApiGetAccountBillsArchiveV5Request) Type_(type_ string) ApiGetAccountBillsArchiveV5Request {
	r.type_ = &type_
	return r
}

// Bill subtype  &#x60;1&#x60;: Buy  &#x60;2&#x60;: Sell  &#x60;3&#x60;: Open long  &#x60;4&#x60;: Open short  &#x60;5&#x60;: Close long  &#x60;6&#x60;: Close short  &#x60;9&#x60;: Interest deduction for Market loans  &#x60;11&#x60;: Transfer in  &#x60;12&#x60;: Transfer out  &#x60;14&#x60;: Interest deduction for VIP loans  &#x60;160&#x60;: Manual margin increase  &#x60;161&#x60;: Manual margin decrease  &#x60;162&#x60;: Auto margin increase  &#x60;114&#x60;: Forced repayment buy  &#x60;115&#x60;: Forced repayment sell  &#x60;118&#x60;: System token conversion transfer in  &#x60;119&#x60;: System token conversion transfer out  &#x60;100&#x60;: Partial liquidation close long  &#x60;101&#x60;: Partial liquidation close short  &#x60;102&#x60;: Partial liquidation buy  &#x60;103&#x60;: Partial liquidation sell  &#x60;104&#x60;: Liquidation long  &#x60;105&#x60;: Liquidation short  &#x60;106&#x60;: Liquidation buy  &#x60;107&#x60;: Liquidation sell  &#x60;108&#x60;: Clawback  &#x60;110&#x60;: Liquidation transfer in  &#x60;111&#x60;: Liquidation transfer out  &#x60;125&#x60;: ADL close long  &#x60;126&#x60;: ADL close short  &#x60;127&#x60;: ADL buy  &#x60;128&#x60;: ADL sell  &#x60;131&#x60;: ddh buy  &#x60;132&#x60;: ddh sell  &#x60;170&#x60;: Exercised(ITM buy side)  &#x60;171&#x60;: Counterparty exercised(ITM sell side)  &#x60;172&#x60;: Expired(Non-ITM buy and sell side)  &#x60;112&#x60;: Delivery long  &#x60;113&#x60;: Delivery short  &#x60;117&#x60;: Delivery/Exercise clawback  &#x60;173&#x60;: Funding fee expense  &#x60;174&#x60;: Funding fee income  &#x60;200&#x60;:System transfer in  &#x60;201&#x60;: Manually transfer in  &#x60;202&#x60;: System transfer out  &#x60;203&#x60;: Manually transfer out  &#x60;204&#x60;: block trade buy  &#x60;205&#x60;: block trade sell  &#x60;206&#x60;: block trade open long  &#x60;207&#x60;: block trade open short  &#x60;208&#x60;: block trade close long  &#x60;209&#x60;: block trade close short  &#x60;210&#x60;: Manual Borrowing of quick margin  &#x60;211&#x60;: Manual Repayment of quick margin  &#x60;212&#x60;: Auto borrow of quick margin  &#x60;213&#x60;: Auto repay of quick margin  &#x60;220&#x60;: Transfer in when using USDT to buy OPTION  &#x60;221&#x60;: Transfer out when using USDT to buy OPTION  &#x60;16&#x60;: Repay forcibly  &#x60;17&#x60;: Repay interest by borrowing forcibly  &#x60;224&#x60;: Repayment transfer in  &#x60;225&#x60;: Repayment transfer out  &#x60;236&#x60;: Easy convert in  &#x60;237&#x60;: Easy convert out  &#x60;250&#x60;: Profit sharing expenses  &#x60;251&#x60;: Profit sharing refund  &#x60;280&#x60;: SPOT profit sharing expenses  &#x60;281&#x60;: SPOT profit sharing refund  &#x60;270&#x60;: Spread trading buy  &#x60;271&#x60;: Spread trading sell  &#x60;272&#x60;: Spread trading open long  &#x60;273&#x60;: Spread trading open short  &#x60;274&#x60;: Spread trading close long  &#x60;275&#x60;: Spread trading close short  &#x60;280&#x60;: SPOT profit sharing expenses  &#x60;281&#x60;: SPOT profit sharing refund   &#x60;284&#x60;: Copy trade automatic transfer in  &#x60;285&#x60;: Copy trade manual transfer in  &#x60;286&#x60;: Copy trade automatic transfer out  &#x60;287&#x60;: Copy trade manual transfer out  &#x60;290&#x60;: Crypto dust auto-transfer out  &#x60;293&#x60;: Fixed loan interest deduction  &#x60;294&#x60;: Fixed loan interest refund  &#x60;295&#x60;: Fixed loan overdue penalty  &#x60;296&#x60;: From structured order placements  &#x60;297&#x60;: To structured order placements  &#x60;298&#x60;: From structured settlements  &#x60;299&#x60;: To structured settlements  &#x60;306&#x60;: Manual borrow  &#x60;307&#x60;: Auto borrow  &#x60;308&#x60;: Manual repay  &#x60;309&#x60;: Auto repay  &#x60;312&#x60;: Auto offset  &#x60;318&#x60;: Convert in  &#x60;319&#x60;: Convert out  &#x60;320&#x60;: Simple buy  &#x60;321&#x60;: Simple sell  &#x60;332&#x60;: Margin transfer in isolated margin position   &#x60;333&#x60;: Margin transfer out isolated margin position  &#x60;334&#x60;: Margin loss when closing isolated margin position  &#x60;348&#x60;: [Credit line] Forced repayment  &#x60;350&#x60;: [Credit line] Forced repayment refund  &#x60;352&#x60;: [Credit line] Forced repayment penalty fee deduction  &#x60;353&#x60;: [Credit line] Forced repayment penalty fee (pending deduction)  &#x60;356&#x60;: [Credit line] Auto conversion (pending deduction)  &#x60;357&#x60;: [Credit line] Auto Conversion Transfer to Funding  &#x60;355&#x60;: Settlement PnL
func (r ApiGetAccountBillsArchiveV5Request) SubType(subType string) ApiGetAccountBillsArchiveV5Request {
	r.subType = &subType
	return r
}

// Pagination of data to return records earlier than the requested bill ID.
func (r ApiGetAccountBillsArchiveV5Request) After(after string) ApiGetAccountBillsArchiveV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested bill ID.
func (r ApiGetAccountBillsArchiveV5Request) Before(before string) ApiGetAccountBillsArchiveV5Request {
	r.before = &before
	return r
}

// Filter with a begin timestamp  &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountBillsArchiveV5Request) Begin(begin string) ApiGetAccountBillsArchiveV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp  &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountBillsArchiveV5Request) End(end string) ApiGetAccountBillsArchiveV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetAccountBillsArchiveV5Request) Limit(limit string) ApiGetAccountBillsArchiveV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAccountBillsArchiveV5Request) Execute() (*GetAccountBillsArchiveV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountBillsArchiveV5Execute(r)
}

/*
GetAccountBillsArchiveV5 Get bills details (last 1 year)

Retrieve the accountâ€™s bills. The bill refers to all transaction records that result in changing the balance of an account. Pagination is supported, and the response is sorted with most recent first. This endpoint can retrieve data from the last 1 year since July 1, 2024.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountBillsArchiveV5Request
*/
func (a *TradingAccountAPIService) GetAccountBillsArchiveV5(ctx context.Context) ApiGetAccountBillsArchiveV5Request {
	return ApiGetAccountBillsArchiveV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountBillsArchiveV5Resp
func (a *TradingAccountAPIService) GetAccountBillsArchiveV5Execute(r ApiGetAccountBillsArchiveV5Request) (*GetAccountBillsArchiveV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountBillsArchiveV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountBillsArchiveV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/bills-archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.mgnMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mgnMode", r.mgnMode, "form", "")
	} else {
		var defaultValue string = ""
		r.mgnMode = &defaultValue
	}
	if r.ctType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ctType", r.ctType, "form", "")
	} else {
		var defaultValue string = ""
		r.ctType = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	} else {
		var defaultValue string = ""
		r.subType = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountBillsHistoryArchiveV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	year *string
	quarter *string
}

// 4 digits year
func (r ApiGetAccountBillsHistoryArchiveV5Request) Year(year string) ApiGetAccountBillsHistoryArchiveV5Request {
	r.year = &year
	return r
}

// Quarter, valid value is &#x60;Q1&#x60;, &#x60;Q2&#x60;, &#x60;Q3&#x60;, &#x60;Q4&#x60;
func (r ApiGetAccountBillsHistoryArchiveV5Request) Quarter(quarter string) ApiGetAccountBillsHistoryArchiveV5Request {
	r.quarter = &quarter
	return r
}

func (r ApiGetAccountBillsHistoryArchiveV5Request) Execute() (*GetAccountBillsHistoryArchiveV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountBillsHistoryArchiveV5Execute(r)
}

/*
GetAccountBillsHistoryArchiveV5 Get bills details (since 2021)

Apply for bill data since 1 February, 2021 except for the current quarter.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountBillsHistoryArchiveV5Request
*/
func (a *TradingAccountAPIService) GetAccountBillsHistoryArchiveV5(ctx context.Context) ApiGetAccountBillsHistoryArchiveV5Request {
	return ApiGetAccountBillsHistoryArchiveV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountBillsHistoryArchiveV5Resp
func (a *TradingAccountAPIService) GetAccountBillsHistoryArchiveV5Execute(r ApiGetAccountBillsHistoryArchiveV5Request) (*GetAccountBillsHistoryArchiveV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountBillsHistoryArchiveV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountBillsHistoryArchiveV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/bills-history-archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.year == nil {
		return localVarReturnValue, nil, reportError("year is required and must be specified")
	}
	if r.quarter == nil {
		return localVarReturnValue, nil, reportError("quarter is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "year", r.year, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "quarter", r.quarter, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountBillsV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	instId *string
	ccy *string
	mgnMode *string
	ctType *string
	type_ *string
	subType *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetAccountBillsV5Request) InstType(instType string) ApiGetAccountBillsV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetAccountBillsV5Request) InstId(instId string) ApiGetAccountBillsV5Request {
	r.instId = &instId
	return r
}

// Bill currency
func (r ApiGetAccountBillsV5Request) Ccy(ccy string) ApiGetAccountBillsV5Request {
	r.ccy = &ccy
	return r
}

// Margin mode  &#x60;isolated&#x60;  &#x60;cross&#x60;
func (r ApiGetAccountBillsV5Request) MgnMode(mgnMode string) ApiGetAccountBillsV5Request {
	r.mgnMode = &mgnMode
	return r
}

// Contract type  &#x60;linear&#x60;  &#x60;inverse&#x60;  Only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;
func (r ApiGetAccountBillsV5Request) CtType(ctType string) ApiGetAccountBillsV5Request {
	r.ctType = &ctType
	return r
}

// Bill type  &#x60;1&#x60;: Transfer  &#x60;2&#x60;: Trade  &#x60;3&#x60;: Delivery  &#x60;4&#x60;: Forced repayment  &#x60;5&#x60;: Liquidation  &#x60;6&#x60;: Margin transfer  &#x60;7&#x60;: Interest deduction  &#x60;8&#x60;: Funding fee  &#x60;9&#x60;: ADL  &#x60;10&#x60;: Clawback  &#x60;11&#x60;: System token conversion  &#x60;12&#x60;: Strategy transfer  &#x60;13&#x60;: DDH  &#x60;14&#x60;: Block trade  &#x60;15&#x60;: Quick Margin  &#x60;16&#x60;: Borrowing  &#x60;22&#x60;: Repay  &#x60;24&#x60;: Spread trading  &#x60;26&#x60;: Structured products  &#x60;27&#x60;: Convert  &#x60;28&#x60;: Easy convert  &#x60;29&#x60;: One-click repay  &#x60;30&#x60;: Simple trade  &#x60;33&#x60;: Loans  &#x60;34&#x60;: Settlement  &#x60;250&#x60;: Copy trader profit sharing expenses  &#x60;251&#x60;: Copy trader profit sharing refund
func (r ApiGetAccountBillsV5Request) Type_(type_ string) ApiGetAccountBillsV5Request {
	r.type_ = &type_
	return r
}

// Bill subtype  &#x60;1&#x60;: Buy  &#x60;2&#x60;: Sell  &#x60;3&#x60;: Open long  &#x60;4&#x60;: Open short  &#x60;5&#x60;: Close long  &#x60;6&#x60;: Close short  &#x60;9&#x60;: Interest deduction for Market loans  &#x60;11&#x60;: Transfer in  &#x60;12&#x60;: Transfer out  &#x60;14&#x60;: Interest deduction for VIP loans  &#x60;160&#x60;: Manual margin increase  &#x60;161&#x60;: Manual margin decrease  &#x60;162&#x60;: Auto margin increase  &#x60;114&#x60;: Forced repayment buy  &#x60;115&#x60;: Forced repayment sell  &#x60;118&#x60;: System token conversion transfer in  &#x60;119&#x60;: System token conversion transfer out  &#x60;100&#x60;: Partial liquidation close long  &#x60;101&#x60;: Partial liquidation close short  &#x60;102&#x60;: Partial liquidation buy  &#x60;103&#x60;: Partial liquidation sell  &#x60;104&#x60;: Liquidation long  &#x60;105&#x60;: Liquidation short  &#x60;106&#x60;: Liquidation buy  &#x60;107&#x60;: Liquidation sell  &#x60;108&#x60;: Clawback  &#x60;110&#x60;: Liquidation transfer in  &#x60;111&#x60;: Liquidation transfer out  &#x60;125&#x60;: ADL close long  &#x60;126&#x60;: ADL close short  &#x60;127&#x60;: ADL buy  &#x60;128&#x60;: ADL sell  &#x60;131&#x60;: ddh buy  &#x60;132&#x60;: ddh sell  &#x60;170&#x60;: Exercised(ITM buy side)  &#x60;171&#x60;: Counterparty exercised(ITM sell side)  &#x60;172&#x60;: Expired(Non-ITM buy and sell side)  &#x60;112&#x60;: Delivery long  &#x60;113&#x60;: Delivery short  &#x60;117&#x60;: Delivery/Exercise clawback  &#x60;173&#x60;: Funding fee expense  &#x60;174&#x60;: Funding fee income  &#x60;200&#x60;:System transfer in  &#x60;201&#x60;: Manually transfer in  &#x60;202&#x60;: System transfer out  &#x60;203&#x60;: Manually transfer out  &#x60;204&#x60;: block trade buy  &#x60;205&#x60;: block trade sell  &#x60;206&#x60;: block trade open long  &#x60;207&#x60;: block trade open short  &#x60;208&#x60;: block trade close long  &#x60;209&#x60;: block trade close short  &#x60;210&#x60;: Manual Borrowing of quick margin  &#x60;211&#x60;: Manual Repayment of quick margin  &#x60;212&#x60;: Auto borrow of quick margin  &#x60;213&#x60;: Auto repay of quick margin  &#x60;220&#x60;: Transfer in when using USDT to buy OPTION  &#x60;221&#x60;: Transfer out when using USDT to buy OPTION  &#x60;16&#x60;: Repay forcibly  &#x60;17&#x60;: Repay interest by borrowing forcibly  &#x60;224&#x60;: Repayment transfer in  &#x60;225&#x60;: Repayment transfer out  &#x60;236&#x60;: Easy convert in  &#x60;237&#x60;: Easy convert out  &#x60;250&#x60;: Profit sharing expenses  &#x60;251&#x60;: Profit sharing refund  &#x60;280&#x60;: SPOT profit sharing expenses  &#x60;281&#x60;: SPOT profit sharing refund  &#x60;270&#x60;: Spread trading buy  &#x60;271&#x60;: Spread trading sell  &#x60;272&#x60;: Spread trading open long  &#x60;273&#x60;: Spread trading open short  &#x60;274&#x60;: Spread trading close long  &#x60;275&#x60;: Spread trading close short  &#x60;280&#x60;: SPOT profit sharing expenses  &#x60;281&#x60;: SPOT profit sharing refund   &#x60;284&#x60;: Copy trade automatic transfer in  &#x60;285&#x60;: Copy trade manual transfer in  &#x60;286&#x60;: Copy trade automatic transfer out  &#x60;287&#x60;: Copy trade manual transfer out  &#x60;290&#x60;: Crypto dust auto-transfer out  &#x60;293&#x60;: Fixed loan interest deduction  &#x60;294&#x60;: Fixed loan interest refund  &#x60;295&#x60;: Fixed loan overdue penalty  &#x60;296&#x60;: From structured order placements  &#x60;297&#x60;: To structured order placements  &#x60;298&#x60;: From structured settlements  &#x60;299&#x60;: To structured settlements  &#x60;306&#x60;: Manual borrow  &#x60;307&#x60;: Auto borrow  &#x60;308&#x60;: Manual repay  &#x60;309&#x60;: Auto repay  &#x60;312&#x60;: Auto offset  &#x60;318&#x60;: Convert in  &#x60;319&#x60;: Convert out  &#x60;320&#x60;: Simple buy  &#x60;321&#x60;: Simple sell  &#x60;332&#x60;: Margin transfer in isolated margin position   &#x60;333&#x60;: Margin transfer out isolated margin position  &#x60;334&#x60;: Margin loss when closing isolated margin position  &#x60;348&#x60;: [Credit line] Forced repayment  &#x60;350&#x60;: [Credit line] Forced repayment refund  &#x60;352&#x60;: [Credit line] Forced repayment penalty fee deduction  &#x60;353&#x60;: [Credit line] Forced repayment penalty fee (pending deduction)  &#x60;356&#x60;: [Credit line] Auto conversion (pending deduction)  &#x60;357&#x60;: [Credit line] Auto Conversion Transfer to Funding  &#x60;355&#x60;: Settlement PnL
func (r ApiGetAccountBillsV5Request) SubType(subType string) ApiGetAccountBillsV5Request {
	r.subType = &subType
	return r
}

// Pagination of data to return records earlier than the requested bill ID.
func (r ApiGetAccountBillsV5Request) After(after string) ApiGetAccountBillsV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested bill ID.
func (r ApiGetAccountBillsV5Request) Before(before string) ApiGetAccountBillsV5Request {
	r.before = &before
	return r
}

// Filter with a begin timestamp &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountBillsV5Request) Begin(begin string) ApiGetAccountBillsV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountBillsV5Request) End(end string) ApiGetAccountBillsV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetAccountBillsV5Request) Limit(limit string) ApiGetAccountBillsV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAccountBillsV5Request) Execute() (*GetAccountBillsV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountBillsV5Execute(r)
}

/*
GetAccountBillsV5 Get bills details (last 7 days)

Retrieve the bills of the account. The bill refers to all transaction records that result in changing the balance of an account. Pagination is supported, and the response is sorted with the most recent first. This endpoint can retrieve data from the last 7 days.

#### Rate Limit: 5 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountBillsV5Request
*/
func (a *TradingAccountAPIService) GetAccountBillsV5(ctx context.Context) ApiGetAccountBillsV5Request {
	return ApiGetAccountBillsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountBillsV5Resp
func (a *TradingAccountAPIService) GetAccountBillsV5Execute(r ApiGetAccountBillsV5Request) (*GetAccountBillsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountBillsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountBillsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/bills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.mgnMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mgnMode", r.mgnMode, "form", "")
	} else {
		var defaultValue string = ""
		r.mgnMode = &defaultValue
	}
	if r.ctType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ctType", r.ctType, "form", "")
	} else {
		var defaultValue string = ""
		r.ctType = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	} else {
		var defaultValue string = ""
		r.subType = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountCollateralAssetsV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	ccy *string
	collateralEnabled *bool
}

// Single currency or multiple currencies (no more than 20) separated with comma, e.g. \&quot;BTC\&quot; or \&quot;BTC,ETH\&quot;.
func (r ApiGetAccountCollateralAssetsV5Request) Ccy(ccy string) ApiGetAccountCollateralAssetsV5Request {
	r.ccy = &ccy
	return r
}

// Whether or not to be a collateral asset
func (r ApiGetAccountCollateralAssetsV5Request) CollateralEnabled(collateralEnabled bool) ApiGetAccountCollateralAssetsV5Request {
	r.collateralEnabled = &collateralEnabled
	return r
}

func (r ApiGetAccountCollateralAssetsV5Request) Execute() (*GetAccountCollateralAssetsV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountCollateralAssetsV5Execute(r)
}

/*
GetAccountCollateralAssetsV5 Get collateral assets

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountCollateralAssetsV5Request
*/
func (a *TradingAccountAPIService) GetAccountCollateralAssetsV5(ctx context.Context) ApiGetAccountCollateralAssetsV5Request {
	return ApiGetAccountCollateralAssetsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountCollateralAssetsV5Resp
func (a *TradingAccountAPIService) GetAccountCollateralAssetsV5Execute(r ApiGetAccountCollateralAssetsV5Request) (*GetAccountCollateralAssetsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountCollateralAssetsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountCollateralAssetsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/collateral-assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.collateralEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collateralEnabled", r.collateralEnabled, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountConfigV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
}

func (r ApiGetAccountConfigV5Request) Execute() (*GetAccountConfigV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountConfigV5Execute(r)
}

/*
GetAccountConfigV5 Get account configuration

Retrieve current account configuration.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountConfigV5Request
*/
func (a *TradingAccountAPIService) GetAccountConfigV5(ctx context.Context) ApiGetAccountConfigV5Request {
	return ApiGetAccountConfigV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountConfigV5Resp
func (a *TradingAccountAPIService) GetAccountConfigV5Execute(r ApiGetAccountConfigV5Request) (*GetAccountConfigV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountConfigV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountConfigV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountGreeksV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	ccy *string
}

// Single currency, e.g. &#x60;BTC&#x60;.
func (r ApiGetAccountGreeksV5Request) Ccy(ccy string) ApiGetAccountGreeksV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAccountGreeksV5Request) Execute() (*GetAccountGreeksV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountGreeksV5Execute(r)
}

/*
GetAccountGreeksV5 Get Greeks

Retrieve a greeks list of all assets in the account.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountGreeksV5Request
*/
func (a *TradingAccountAPIService) GetAccountGreeksV5(ctx context.Context) ApiGetAccountGreeksV5Request {
	return ApiGetAccountGreeksV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountGreeksV5Resp
func (a *TradingAccountAPIService) GetAccountGreeksV5Execute(r ApiGetAccountGreeksV5Request) (*GetAccountGreeksV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountGreeksV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountGreeksV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/greeks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountInstrumentsV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
}

// Instrument type  &#x60;SPOT&#x60;: Spot  &#x60;MARGIN&#x60;: Margin  &#x60;SWAP&#x60;: Perpetual Futures  &#x60;FUTURES&#x60;: Expiry Futures  &#x60;OPTION&#x60;: Option
func (r ApiGetAccountInstrumentsV5Request) InstType(instType string) ApiGetAccountInstrumentsV5Request {
	r.instType = &instType
	return r
}

// Underlying   Only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;.If instType is &#x60;OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.
func (r ApiGetAccountInstrumentsV5Request) Uly(uly string) ApiGetAccountInstrumentsV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;. If instType is &#x60;OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.
func (r ApiGetAccountInstrumentsV5Request) InstFamily(instFamily string) ApiGetAccountInstrumentsV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID
func (r ApiGetAccountInstrumentsV5Request) InstId(instId string) ApiGetAccountInstrumentsV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetAccountInstrumentsV5Request) Execute() (*GetAccountInstrumentsV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountInstrumentsV5Execute(r)
}

/*
GetAccountInstrumentsV5 Get instruments

Retrieve available instruments info of current account.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID + Instrument Type 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountInstrumentsV5Request
*/
func (a *TradingAccountAPIService) GetAccountInstrumentsV5(ctx context.Context) ApiGetAccountInstrumentsV5Request {
	return ApiGetAccountInstrumentsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountInstrumentsV5Resp
func (a *TradingAccountAPIService) GetAccountInstrumentsV5Execute(r ApiGetAccountInstrumentsV5Request) (*GetAccountInstrumentsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountInstrumentsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountInstrumentsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/instruments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountInterestAccruedV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	type_ *string
	ccy *string
	instId *string
	mgnMode *string
	after *string
	before *string
	limit *string
}

// Loan type  &#x60;2&#x60;: Market loans  Default is &#x60;2&#x60;
func (r ApiGetAccountInterestAccruedV5Request) Type_(type_ string) ApiGetAccountInterestAccruedV5Request {
	r.type_ = &type_
	return r
}

// Loan currency, e.g. &#x60;BTC&#x60;  Only applicable to &#x60;Market loans&#x60;  Only applicable to&#x60;MARGIN&#x60;
func (r ApiGetAccountInterestAccruedV5Request) Ccy(ccy string) ApiGetAccountInterestAccruedV5Request {
	r.ccy = &ccy
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;  Only applicable to &#x60;Market loans&#x60;
func (r ApiGetAccountInterestAccruedV5Request) InstId(instId string) ApiGetAccountInterestAccruedV5Request {
	r.instId = &instId
	return r
}

// Margin mode  &#x60;cross&#x60;    &#x60;isolated&#x60;  Only applicable to &#x60;Market loans&#x60;
func (r ApiGetAccountInterestAccruedV5Request) MgnMode(mgnMode string) ApiGetAccountInterestAccruedV5Request {
	r.mgnMode = &mgnMode
	return r
}

// Pagination of data to return records earlier than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountInterestAccruedV5Request) After(after string) ApiGetAccountInterestAccruedV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountInterestAccruedV5Request) Before(before string) ApiGetAccountInterestAccruedV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetAccountInterestAccruedV5Request) Limit(limit string) ApiGetAccountInterestAccruedV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAccountInterestAccruedV5Request) Execute() (*GetAccountInterestAccruedV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountInterestAccruedV5Execute(r)
}

/*
GetAccountInterestAccruedV5 Get interest accrued data

Get interest accrued data. Only data within the last one year can be obtained.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountInterestAccruedV5Request
*/
func (a *TradingAccountAPIService) GetAccountInterestAccruedV5(ctx context.Context) ApiGetAccountInterestAccruedV5Request {
	return ApiGetAccountInterestAccruedV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountInterestAccruedV5Resp
func (a *TradingAccountAPIService) GetAccountInterestAccruedV5Execute(r ApiGetAccountInterestAccruedV5Request) (*GetAccountInterestAccruedV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountInterestAccruedV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountInterestAccruedV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/interest-accrued"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.mgnMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mgnMode", r.mgnMode, "form", "")
	} else {
		var defaultValue string = ""
		r.mgnMode = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountInterestLimitsV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	type_ *string
	ccy *string
}

// Loan type  &#x60;2&#x60;: Market loans  Default is &#x60;2&#x60;
func (r ApiGetAccountInterestLimitsV5Request) Type_(type_ string) ApiGetAccountInterestLimitsV5Request {
	r.type_ = &type_
	return r
}

// Loan currency, e.g. &#x60;BTC&#x60;
func (r ApiGetAccountInterestLimitsV5Request) Ccy(ccy string) ApiGetAccountInterestLimitsV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAccountInterestLimitsV5Request) Execute() (*GetAccountInterestLimitsV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountInterestLimitsV5Execute(r)
}

/*
GetAccountInterestLimitsV5 Get borrow interest and limit

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountInterestLimitsV5Request
*/
func (a *TradingAccountAPIService) GetAccountInterestLimitsV5(ctx context.Context) ApiGetAccountInterestLimitsV5Request {
	return ApiGetAccountInterestLimitsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountInterestLimitsV5Resp
func (a *TradingAccountAPIService) GetAccountInterestLimitsV5Execute(r ApiGetAccountInterestLimitsV5Request) (*GetAccountInterestLimitsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountInterestLimitsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountInterestLimitsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/interest-limits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountInterestRateV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	ccy *string
}

// Currency, e.g. &#x60;BTC&#x60;
func (r ApiGetAccountInterestRateV5Request) Ccy(ccy string) ApiGetAccountInterestRateV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAccountInterestRateV5Request) Execute() (*GetAccountInterestRateV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountInterestRateV5Execute(r)
}

/*
GetAccountInterestRateV5 Get interest rate

Get the user's current leveraged currency borrowing market interest rate

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountInterestRateV5Request
*/
func (a *TradingAccountAPIService) GetAccountInterestRateV5(ctx context.Context) ApiGetAccountInterestRateV5Request {
	return ApiGetAccountInterestRateV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountInterestRateV5Resp
func (a *TradingAccountAPIService) GetAccountInterestRateV5Execute(r ApiGetAccountInterestRateV5Request) (*GetAccountInterestRateV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountInterestRateV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountInterestRateV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/interest-rate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountLeverageInfoV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	mgnMode *string
	instId *string
	ccy *string
}

// Margin mode  &#x60;cross&#x60; &#x60;isolated&#x60;
func (r ApiGetAccountLeverageInfoV5Request) MgnMode(mgnMode string) ApiGetAccountLeverageInfoV5Request {
	r.mgnMode = &mgnMode
	return r
}

// Instrument ID  Single instrument ID or multiple instrument IDs (no more than 20) separated with comma
func (r ApiGetAccountLeverageInfoV5Request) InstId(instId string) ApiGetAccountLeverageInfoV5Request {
	r.instId = &instId
	return r
}

// Currencyï¼Œused for getting leverage of currency level.  Applicable to &#x60;cross&#x60; &#x60;MARGIN&#x60; of &#x60;Spot mode&#x60;/&#x60;Multi-currency margin&#x60;/&#x60;Portfolio margin&#x60;.  Supported single currency or multiple currencies (no more than 20) separated with comma.
func (r ApiGetAccountLeverageInfoV5Request) Ccy(ccy string) ApiGetAccountLeverageInfoV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAccountLeverageInfoV5Request) Execute() (*GetAccountLeverageInfoV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountLeverageInfoV5Execute(r)
}

/*
GetAccountLeverageInfoV5 Get leverage

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountLeverageInfoV5Request
*/
func (a *TradingAccountAPIService) GetAccountLeverageInfoV5(ctx context.Context) ApiGetAccountLeverageInfoV5Request {
	return ApiGetAccountLeverageInfoV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountLeverageInfoV5Resp
func (a *TradingAccountAPIService) GetAccountLeverageInfoV5Execute(r ApiGetAccountLeverageInfoV5Request) (*GetAccountLeverageInfoV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountLeverageInfoV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountLeverageInfoV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/leverage-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mgnMode == nil {
		return localVarReturnValue, nil, reportError("mgnMode is required and must be specified")
	}

	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mgnMode", r.mgnMode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountMaxAvailSizeV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instId *string
	tdMode *string
	ccy *string
	reduceOnly *bool
	px *string
}

// Single instrument or multiple instruments (no more than 5) separated with comma, e.g. &#x60;BTC-USDT,ETH-USDT&#x60;
func (r ApiGetAccountMaxAvailSizeV5Request) InstId(instId string) ApiGetAccountMaxAvailSizeV5Request {
	r.instId = &instId
	return r
}

// Trade mode  &#x60;cross&#x60;  &#x60;isolated&#x60;  &#x60;cash&#x60;  &#x60;spot_isolated&#x60;
func (r ApiGetAccountMaxAvailSizeV5Request) TdMode(tdMode string) ApiGetAccountMaxAvailSizeV5Request {
	r.tdMode = &tdMode
	return r
}

// Currency used for margin  Applicable to &#x60;isolated&#x60; &#x60;MARGIN&#x60; and &#x60;cross&#x60; &#x60;MARGIN&#x60; in &#x60;Spot and futures mode&#x60;.
func (r ApiGetAccountMaxAvailSizeV5Request) Ccy(ccy string) ApiGetAccountMaxAvailSizeV5Request {
	r.ccy = &ccy
	return r
}

// Whether to reduce position only   Only applicable to &#x60;MARGIN&#x60;
func (r ApiGetAccountMaxAvailSizeV5Request) ReduceOnly(reduceOnly bool) ApiGetAccountMaxAvailSizeV5Request {
	r.reduceOnly = &reduceOnly
	return r
}

// The price of closing position.   Only applicable to reduceOnly &#x60;MARGIN&#x60;.
func (r ApiGetAccountMaxAvailSizeV5Request) Px(px string) ApiGetAccountMaxAvailSizeV5Request {
	r.px = &px
	return r
}

func (r ApiGetAccountMaxAvailSizeV5Request) Execute() (*GetAccountMaxAvailSizeV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountMaxAvailSizeV5Execute(r)
}

/*
GetAccountMaxAvailSizeV5 Get maximum available balance/equity

Available balance for isolated margin positions and SPOT, available equity for cross margin positions.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountMaxAvailSizeV5Request
*/
func (a *TradingAccountAPIService) GetAccountMaxAvailSizeV5(ctx context.Context) ApiGetAccountMaxAvailSizeV5Request {
	return ApiGetAccountMaxAvailSizeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountMaxAvailSizeV5Resp
func (a *TradingAccountAPIService) GetAccountMaxAvailSizeV5Execute(r ApiGetAccountMaxAvailSizeV5Request) (*GetAccountMaxAvailSizeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountMaxAvailSizeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountMaxAvailSizeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/max-avail-size"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}
	if r.tdMode == nil {
		return localVarReturnValue, nil, reportError("tdMode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tdMode", r.tdMode, "form", "")
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduceOnly", r.reduceOnly, "form", "")
	}
	if r.px != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "px", r.px, "form", "")
	} else {
		var defaultValue string = ""
		r.px = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountMaxLoanV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	mgnMode *string
	instId *string
	ccy *string
	mgnCcy *string
}

// Margin mode  &#x60;isolated&#x60; &#x60;cross&#x60;
func (r ApiGetAccountMaxLoanV5Request) MgnMode(mgnMode string) ApiGetAccountMaxLoanV5Request {
	r.mgnMode = &mgnMode
	return r
}

// Single instrument or multiple instruments (no more than 5) separated with comma, e.g. &#x60;BTC-USDT,ETH-USDT&#x60;
func (r ApiGetAccountMaxLoanV5Request) InstId(instId string) ApiGetAccountMaxLoanV5Request {
	r.instId = &instId
	return r
}

// Currency  Applicable to get Max loan of manual borrow for the currency in &#x60;Spot mode&#x60; (enabled borrowing)
func (r ApiGetAccountMaxLoanV5Request) Ccy(ccy string) ApiGetAccountMaxLoanV5Request {
	r.ccy = &ccy
	return r
}

// Margin currency  Applicable to &#x60;isolated&#x60; &#x60;MARGIN&#x60; and &#x60;cross&#x60; &#x60;MARGIN&#x60; in &#x60;Spot and futures mode&#x60;.
func (r ApiGetAccountMaxLoanV5Request) MgnCcy(mgnCcy string) ApiGetAccountMaxLoanV5Request {
	r.mgnCcy = &mgnCcy
	return r
}

func (r ApiGetAccountMaxLoanV5Request) Execute() (*GetAccountMaxLoanV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountMaxLoanV5Execute(r)
}

/*
GetAccountMaxLoanV5 Get the maximum loan of instrument

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountMaxLoanV5Request
*/
func (a *TradingAccountAPIService) GetAccountMaxLoanV5(ctx context.Context) ApiGetAccountMaxLoanV5Request {
	return ApiGetAccountMaxLoanV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountMaxLoanV5Resp
func (a *TradingAccountAPIService) GetAccountMaxLoanV5Execute(r ApiGetAccountMaxLoanV5Request) (*GetAccountMaxLoanV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountMaxLoanV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountMaxLoanV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/max-loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mgnMode == nil {
		return localVarReturnValue, nil, reportError("mgnMode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "mgnMode", r.mgnMode, "form", "")
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.mgnCcy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mgnCcy", r.mgnCcy, "form", "")
	} else {
		var defaultValue string = ""
		r.mgnCcy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountMaxSizeV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instId *string
	tdMode *string
	ccy *string
	px *string
	leverage *string
}

// Single instrument or multiple instruments (no more than 5) in the smae instrument type separated with comma, e.g. &#x60;BTC-USDT,ETH-USDT&#x60;
func (r ApiGetAccountMaxSizeV5Request) InstId(instId string) ApiGetAccountMaxSizeV5Request {
	r.instId = &instId
	return r
}

// Trade mode  &#x60;cross&#x60;  &#x60;isolated&#x60;  &#x60;cash&#x60;  &#x60;spot_isolated&#x60;
func (r ApiGetAccountMaxSizeV5Request) TdMode(tdMode string) ApiGetAccountMaxSizeV5Request {
	r.tdMode = &tdMode
	return r
}

// Currency used for margin   Applicable to &#x60;isolated&#x60; &#x60;MARGIN&#x60; and &#x60;cross&#x60; &#x60;MARGIN&#x60; orders in &#x60;Spot and futures mode&#x60;.
func (r ApiGetAccountMaxSizeV5Request) Ccy(ccy string) ApiGetAccountMaxSizeV5Request {
	r.ccy = &ccy
	return r
}

// Price  When the price is not specified, it will be calculated according to the current limit price for &#x60;FUTURES&#x60; and &#x60;SWAP&#x60;, the last traded price for other instrument types.  The parameter will be ignored when multiple instruments are specified.
func (r ApiGetAccountMaxSizeV5Request) Px(px string) ApiGetAccountMaxSizeV5Request {
	r.px = &px
	return r
}

// Leverage for instrument  The default is current leverage  Only applicable to &#x60;MARGIN/FUTURES/SWAP&#x60;
func (r ApiGetAccountMaxSizeV5Request) Leverage(leverage string) ApiGetAccountMaxSizeV5Request {
	r.leverage = &leverage
	return r
}

func (r ApiGetAccountMaxSizeV5Request) Execute() (*GetAccountMaxSizeV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountMaxSizeV5Execute(r)
}

/*
GetAccountMaxSizeV5 Get maximum order quantity

The maximum quantity to buy or sell. It corresponds to the "sz" from placement.

**_Under the Portfolio Margin account, the calculation of the maximum buy/sell amount or open amount is not supported under the cross mode of derivatives._**

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountMaxSizeV5Request
*/
func (a *TradingAccountAPIService) GetAccountMaxSizeV5(ctx context.Context) ApiGetAccountMaxSizeV5Request {
	return ApiGetAccountMaxSizeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountMaxSizeV5Resp
func (a *TradingAccountAPIService) GetAccountMaxSizeV5Execute(r ApiGetAccountMaxSizeV5Request) (*GetAccountMaxSizeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountMaxSizeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountMaxSizeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/max-size"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}
	if r.tdMode == nil {
		return localVarReturnValue, nil, reportError("tdMode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tdMode", r.tdMode, "form", "")
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.px != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "px", r.px, "form", "")
	} else {
		var defaultValue string = ""
		r.px = &defaultValue
	}
	if r.leverage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leverage", r.leverage, "form", "")
	} else {
		var defaultValue string = ""
		r.leverage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountMaxWithdrawalV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	ccy *string
}

// Single currency or multiple currencies (no more than 20) separated with comma, e.g. &#x60;BTC&#x60; or &#x60;BTC,ETH&#x60;.
func (r ApiGetAccountMaxWithdrawalV5Request) Ccy(ccy string) ApiGetAccountMaxWithdrawalV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAccountMaxWithdrawalV5Request) Execute() (*GetAccountMaxWithdrawalV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountMaxWithdrawalV5Execute(r)
}

/*
GetAccountMaxWithdrawalV5 Get maximum withdrawals

Retrieve the maximum transferable amount from trading account to funding account. If no currency is specified, the transferable amount of all owned currencies will be returned.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountMaxWithdrawalV5Request
*/
func (a *TradingAccountAPIService) GetAccountMaxWithdrawalV5(ctx context.Context) ApiGetAccountMaxWithdrawalV5Request {
	return ApiGetAccountMaxWithdrawalV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountMaxWithdrawalV5Resp
func (a *TradingAccountAPIService) GetAccountMaxWithdrawalV5Execute(r ApiGetAccountMaxWithdrawalV5Request) (*GetAccountMaxWithdrawalV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountMaxWithdrawalV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountMaxWithdrawalV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/max-withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountMmpConfigV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instFamily *string
}

// Instrument Family
func (r ApiGetAccountMmpConfigV5Request) InstFamily(instFamily string) ApiGetAccountMmpConfigV5Request {
	r.instFamily = &instFamily
	return r
}

func (r ApiGetAccountMmpConfigV5Request) Execute() (*GetAccountMmpConfigV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountMmpConfigV5Execute(r)
}

/*
GetAccountMmpConfigV5 GET MMP Config

This endpoint is used to get MMP configure information



Only applicable to Option in Portfolio Margin mode, and MMP privilege is required.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountMmpConfigV5Request
*/
func (a *TradingAccountAPIService) GetAccountMmpConfigV5(ctx context.Context) ApiGetAccountMmpConfigV5Request {
	return ApiGetAccountMmpConfigV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountMmpConfigV5Resp
func (a *TradingAccountAPIService) GetAccountMmpConfigV5Execute(r ApiGetAccountMmpConfigV5Request) (*GetAccountMmpConfigV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountMmpConfigV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountMmpConfigV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/mmp-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountPositionTiersV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	uly *string
	instFamily *string
}

// Instrument type  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetAccountPositionTiersV5Request) InstType(instType string) ApiGetAccountPositionTiersV5Request {
	r.instType = &instType
	return r
}

// Single underlying or multiple underlyings (no more than 3) separated with comma.  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetAccountPositionTiersV5Request) Uly(uly string) ApiGetAccountPositionTiersV5Request {
	r.uly = &uly
	return r
}

// Single instrument family or instrument families (no more than 5) separated with comma.  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetAccountPositionTiersV5Request) InstFamily(instFamily string) ApiGetAccountPositionTiersV5Request {
	r.instFamily = &instFamily
	return r
}

func (r ApiGetAccountPositionTiersV5Request) Execute() (*GetAccountPositionTiersV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountPositionTiersV5Execute(r)
}

/*
GetAccountPositionTiersV5 Get PM position limitation

Retrieve cross position limitation of SWAP/FUTURES/OPTION under Portfolio margin mode.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountPositionTiersV5Request
*/
func (a *TradingAccountAPIService) GetAccountPositionTiersV5(ctx context.Context) ApiGetAccountPositionTiersV5Request {
	return ApiGetAccountPositionTiersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountPositionTiersV5Resp
func (a *TradingAccountAPIService) GetAccountPositionTiersV5Execute(r ApiGetAccountPositionTiersV5Request) (*GetAccountPositionTiersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountPositionTiersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountPositionTiersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/position-tiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountPositionsHistoryV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	instId *string
	mgnMode *string
	type_ *string
	posId *string
	after *string
	before *string
	limit *string
}

// Instrument type  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetAccountPositionsHistoryV5Request) InstType(instType string) ApiGetAccountPositionsHistoryV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. &#x60;BTC-USD-SWAP&#x60;
func (r ApiGetAccountPositionsHistoryV5Request) InstId(instId string) ApiGetAccountPositionsHistoryV5Request {
	r.instId = &instId
	return r
}

// Margin mode  &#x60;cross&#x60; &#x60;isolated&#x60;
func (r ApiGetAccountPositionsHistoryV5Request) MgnMode(mgnMode string) ApiGetAccountPositionsHistoryV5Request {
	r.mgnMode = &mgnMode
	return r
}

// The type of latest close position  &#x60;1&#x60;: Close position partially;&#x60;2&#x60;ï¼šClose all;&#x60;3&#x60;ï¼šLiquidation;&#x60;4&#x60;ï¼šPartial liquidation; &#x60;5&#x60;ï¼šADL;   It is the latest type if there are several types for the same position.
func (r ApiGetAccountPositionsHistoryV5Request) Type_(type_ string) ApiGetAccountPositionsHistoryV5Request {
	r.type_ = &type_
	return r
}

// Position ID. There is attribute expiration. The posId will be expired if it is more than 30 days after the last full close position, then position will use new posId.
func (r ApiGetAccountPositionsHistoryV5Request) PosId(posId string) ApiGetAccountPositionsHistoryV5Request {
	r.posId = &posId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;uTime&#x60;, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountPositionsHistoryV5Request) After(after string) ApiGetAccountPositionsHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;uTime&#x60;, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountPositionsHistoryV5Request) Before(before string) ApiGetAccountPositionsHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100. All records that have the same &#x60;uTime&#x60; will be returned at the current request
func (r ApiGetAccountPositionsHistoryV5Request) Limit(limit string) ApiGetAccountPositionsHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAccountPositionsHistoryV5Request) Execute() (*GetAccountPositionsHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountPositionsHistoryV5Execute(r)
}

/*
GetAccountPositionsHistoryV5 Get positions history

Retrieve the updated position data for the last 3 months. Return in reverse chronological order using utime. Getting positions history is supported under Portfolio margin mode since .

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountPositionsHistoryV5Request
*/
func (a *TradingAccountAPIService) GetAccountPositionsHistoryV5(ctx context.Context) ApiGetAccountPositionsHistoryV5Request {
	return ApiGetAccountPositionsHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountPositionsHistoryV5Resp
func (a *TradingAccountAPIService) GetAccountPositionsHistoryV5Execute(r ApiGetAccountPositionsHistoryV5Request) (*GetAccountPositionsHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountPositionsHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountPositionsHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/positions-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.mgnMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mgnMode", r.mgnMode, "form", "")
	} else {
		var defaultValue string = ""
		r.mgnMode = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.posId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "posId", r.posId, "form", "")
	} else {
		var defaultValue string = ""
		r.posId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountPositionsV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	instId *string
	posId *string
}

// Instrument type  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;  &#x60;instId&#x60; will be checked against &#x60;instType&#x60; when both parameters are passed.
func (r ApiGetAccountPositionsV5Request) InstType(instType string) ApiGetAccountPositionsV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT-SWAP&#x60;. Single instrument ID or multiple instrument IDs (no more than 10) separated with comma
func (r ApiGetAccountPositionsV5Request) InstId(instId string) ApiGetAccountPositionsV5Request {
	r.instId = &instId
	return r
}

// Single position ID or multiple position IDs (no more than 20) separated with comma.   There is attribute expiration, the posId and position information will be cleared if it is more than 30 days after the last full close position.
func (r ApiGetAccountPositionsV5Request) PosId(posId string) ApiGetAccountPositionsV5Request {
	r.posId = &posId
	return r
}

func (r ApiGetAccountPositionsV5Request) Execute() (*GetAccountPositionsV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountPositionsV5Execute(r)
}

/*
GetAccountPositionsV5 Get positions

Retrieve information on your positions. When the account is in `net` mode, `net` positions will be displayed, and when the account is in `long/short` mode, `long` or `short` positions will be displayed. Return in reverse chronological order using ctime.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountPositionsV5Request
*/
func (a *TradingAccountAPIService) GetAccountPositionsV5(ctx context.Context) ApiGetAccountPositionsV5Request {
	return ApiGetAccountPositionsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountPositionsV5Resp
func (a *TradingAccountAPIService) GetAccountPositionsV5Execute(r ApiGetAccountPositionsV5Request) (*GetAccountPositionsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountPositionsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountPositionsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/positions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.posId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "posId", r.posId, "form", "")
	} else {
		var defaultValue string = ""
		r.posId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountQuickMarginBorrowRepayHistoryV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instId *string
	ccy *string
	side *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
}

// Instrument ID, e.g. BTC-USDT
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) InstId(instId string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.instId = &instId
	return r
}

// Loan currency, e.g. &#x60;BTC&#x60;
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) Ccy(ccy string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.ccy = &ccy
	return r
}

// &#x60;borrow&#x60;  &#x60;repay&#x60;
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) Side(side string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.side = &side
	return r
}

// Pagination of data to return records earlier than the requested &#x60;refId&#x60;
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) After(after string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;refId&#x60;
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) Before(before string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.before = &before
	return r
}

// Filter with a begin timestamp. Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) Begin(begin string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp. Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) End(end string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) Limit(limit string) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) Execute() (*GetAccountQuickMarginBorrowRepayHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountQuickMarginBorrowRepayHistoryV5Execute(r)
}

/*
GetAccountQuickMarginBorrowRepayHistoryV5 Get borrow and repay history in Quick Margin Mode

Get record in the past 3 months.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountQuickMarginBorrowRepayHistoryV5Request
*/
func (a *TradingAccountAPIService) GetAccountQuickMarginBorrowRepayHistoryV5(ctx context.Context) ApiGetAccountQuickMarginBorrowRepayHistoryV5Request {
	return ApiGetAccountQuickMarginBorrowRepayHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountQuickMarginBorrowRepayHistoryV5Resp
func (a *TradingAccountAPIService) GetAccountQuickMarginBorrowRepayHistoryV5Execute(r ApiGetAccountQuickMarginBorrowRepayHistoryV5Request) (*GetAccountQuickMarginBorrowRepayHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountQuickMarginBorrowRepayHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountQuickMarginBorrowRepayHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/quick-margin-borrow-repay-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.side != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "side", r.side, "form", "")
	} else {
		var defaultValue string = ""
		r.side = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountRiskStateV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
}

func (r ApiGetAccountRiskStateV5Request) Execute() (*GetAccountRiskStateV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountRiskStateV5Execute(r)
}

/*
GetAccountRiskStateV5 Get account risk state

Only applicable to Portfolio margin account

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountRiskStateV5Request
*/
func (a *TradingAccountAPIService) GetAccountRiskStateV5(ctx context.Context) ApiGetAccountRiskStateV5Request {
	return ApiGetAccountRiskStateV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountRiskStateV5Resp
func (a *TradingAccountAPIService) GetAccountRiskStateV5Execute(r ApiGetAccountRiskStateV5Request) (*GetAccountRiskStateV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountRiskStateV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountRiskStateV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/risk-state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountSetAccountSwitchPrecheckV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	acctLv *string
}

// Account mode   &#x60;1&#x60;: Spot mode   &#x60;2&#x60;: Spot and futures mode   &#x60;3&#x60;: Multi-currency margin code   &#x60;4&#x60;: Portfolio margin mode
func (r ApiGetAccountSetAccountSwitchPrecheckV5Request) AcctLv(acctLv string) ApiGetAccountSetAccountSwitchPrecheckV5Request {
	r.acctLv = &acctLv
	return r
}

func (r ApiGetAccountSetAccountSwitchPrecheckV5Request) Execute() (*GetAccountSetAccountSwitchPrecheckV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountSetAccountSwitchPrecheckV5Execute(r)
}

/*
GetAccountSetAccountSwitchPrecheckV5 Precheck account mode switch

Retrieve precheck information for account mode switching.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountSetAccountSwitchPrecheckV5Request
*/
func (a *TradingAccountAPIService) GetAccountSetAccountSwitchPrecheckV5(ctx context.Context) ApiGetAccountSetAccountSwitchPrecheckV5Request {
	return ApiGetAccountSetAccountSwitchPrecheckV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountSetAccountSwitchPrecheckV5Resp
func (a *TradingAccountAPIService) GetAccountSetAccountSwitchPrecheckV5Execute(r ApiGetAccountSetAccountSwitchPrecheckV5Request) (*GetAccountSetAccountSwitchPrecheckV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountSetAccountSwitchPrecheckV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountSetAccountSwitchPrecheckV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/set-account-switch-precheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acctLv == nil {
		return localVarReturnValue, nil, reportError("acctLv is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "acctLv", r.acctLv, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountSpotBorrowRepayHistoryV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	ccy *string
	type_ *string
	after *string
	before *string
	limit *string
}

// Currency, e.g. &#x60;BTC&#x60;
func (r ApiGetAccountSpotBorrowRepayHistoryV5Request) Ccy(ccy string) ApiGetAccountSpotBorrowRepayHistoryV5Request {
	r.ccy = &ccy
	return r
}

// Event type  &#x60;auto_borrow&#x60;  &#x60;auto_repay&#x60;  &#x60;manual_borrow&#x60;  &#x60;manual_repay&#x60;
func (r ApiGetAccountSpotBorrowRepayHistoryV5Request) Type_(type_ string) ApiGetAccountSpotBorrowRepayHistoryV5Request {
	r.type_ = &type_
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60; (included), Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountSpotBorrowRepayHistoryV5Request) After(after string) ApiGetAccountSpotBorrowRepayHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;(included), Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAccountSpotBorrowRepayHistoryV5Request) Before(before string) ApiGetAccountSpotBorrowRepayHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetAccountSpotBorrowRepayHistoryV5Request) Limit(limit string) ApiGetAccountSpotBorrowRepayHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAccountSpotBorrowRepayHistoryV5Request) Execute() (*GetAccountSpotBorrowRepayHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountSpotBorrowRepayHistoryV5Execute(r)
}

/*
GetAccountSpotBorrowRepayHistoryV5 Get borrow/repay history

Retrieve the borrow/repay history under `Spot mode`

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountSpotBorrowRepayHistoryV5Request
*/
func (a *TradingAccountAPIService) GetAccountSpotBorrowRepayHistoryV5(ctx context.Context) ApiGetAccountSpotBorrowRepayHistoryV5Request {
	return ApiGetAccountSpotBorrowRepayHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountSpotBorrowRepayHistoryV5Resp
func (a *TradingAccountAPIService) GetAccountSpotBorrowRepayHistoryV5Execute(r ApiGetAccountSpotBorrowRepayHistoryV5Request) (*GetAccountSpotBorrowRepayHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountSpotBorrowRepayHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountSpotBorrowRepayHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/spot-borrow-repay-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountTradeFeeV5Request struct {
	ctx context.Context
	ApiService *TradingAccountAPIService
	instType *string
	ruleType *string
	instId *string
	uly *string
	instFamily *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetAccountTradeFeeV5Request) InstType(instType string) ApiGetAccountTradeFeeV5Request {
	r.instType = &instType
	return r
}

// Trading rule types   &#x60;normal&#x60;: normal trading   &#x60;pre_market&#x60;: pre-market trading   ruleType can not be passed through together with instId/instFamily/uly
func (r ApiGetAccountTradeFeeV5Request) RuleType(ruleType string) ApiGetAccountTradeFeeV5Request {
	r.ruleType = &ruleType
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;  Applicable to &#x60;SPOT&#x60;/&#x60;MARGIN&#x60;
func (r ApiGetAccountTradeFeeV5Request) InstId(instId string) ApiGetAccountTradeFeeV5Request {
	r.instId = &instId
	return r
}

// Underlying, e.g. &#x60;BTC-USD&#x60;  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetAccountTradeFeeV5Request) Uly(uly string) ApiGetAccountTradeFeeV5Request {
	r.uly = &uly
	return r
}

// Instrument family, e.g. &#x60;BTC-USD&#x60;  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetAccountTradeFeeV5Request) InstFamily(instFamily string) ApiGetAccountTradeFeeV5Request {
	r.instFamily = &instFamily
	return r
}

func (r ApiGetAccountTradeFeeV5Request) Execute() (*GetAccountTradeFeeV5Resp, *http.Response, error) {
	return r.ApiService.GetAccountTradeFeeV5Execute(r)
}

/*
GetAccountTradeFeeV5 Get fee rates

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountTradeFeeV5Request
*/
func (a *TradingAccountAPIService) GetAccountTradeFeeV5(ctx context.Context) ApiGetAccountTradeFeeV5Request {
	return ApiGetAccountTradeFeeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountTradeFeeV5Resp
func (a *TradingAccountAPIService) GetAccountTradeFeeV5Execute(r ApiGetAccountTradeFeeV5Request) (*GetAccountTradeFeeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountTradeFeeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAccountAPIService.GetAccountTradeFeeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/account/trade-fee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}
	if r.ruleType == nil {
		return localVarReturnValue, nil, reportError("ruleType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ruleType", r.ruleType, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
