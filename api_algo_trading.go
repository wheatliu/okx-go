/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AlgoTradingAPIService AlgoTradingAPI service
type AlgoTradingAPIService service

type ApiCreateTradeAmendAlgosV5Request struct {
	ctx context.Context
	ApiService *AlgoTradingAPIService
	createTradeAmendAlgosV5Req *CreateTradeAmendAlgosV5Req
}

// The request body for CreateTradeAmendAlgosV5
func (r ApiCreateTradeAmendAlgosV5Request) CreateTradeAmendAlgosV5Req(createTradeAmendAlgosV5Req CreateTradeAmendAlgosV5Req) ApiCreateTradeAmendAlgosV5Request {
	r.createTradeAmendAlgosV5Req = &createTradeAmendAlgosV5Req
	return r
}

func (r ApiCreateTradeAmendAlgosV5Request) Execute() (*CreateTradeAmendAlgosV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeAmendAlgosV5Execute(r)
}

/*
CreateTradeAmendAlgosV5 Amend unfilled algo orders (Support Stop order and Trigger order only, not including Move_order_stop order, Iceberg order, TWAP order, Trailing Stop order).    

Amend unfilled algo orders (Support Stop order and Trigger order only, not including Move_order_stop order, Iceberg order, TWAP order, Trailing Stop order).



#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID + Instrument ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeAmendAlgosV5Request
*/
func (a *AlgoTradingAPIService) CreateTradeAmendAlgosV5(ctx context.Context) ApiCreateTradeAmendAlgosV5Request {
	return ApiCreateTradeAmendAlgosV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeAmendAlgosV5Resp
func (a *AlgoTradingAPIService) CreateTradeAmendAlgosV5Execute(r ApiCreateTradeAmendAlgosV5Request) (*CreateTradeAmendAlgosV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeAmendAlgosV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlgoTradingAPIService.CreateTradeAmendAlgosV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/amend-algos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeAmendAlgosV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeAmendAlgosV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeAmendAlgosV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeCancelAdvanceAlgosV5Request struct {
	ctx context.Context
	ApiService *AlgoTradingAPIService
	createTradeCancelAdvanceAlgosV5Req *CreateTradeCancelAdvanceAlgosV5Req
}

// The request body for CreateTradeCancelAdvanceAlgosV5
func (r ApiCreateTradeCancelAdvanceAlgosV5Request) CreateTradeCancelAdvanceAlgosV5Req(createTradeCancelAdvanceAlgosV5Req CreateTradeCancelAdvanceAlgosV5Req) ApiCreateTradeCancelAdvanceAlgosV5Request {
	r.createTradeCancelAdvanceAlgosV5Req = &createTradeCancelAdvanceAlgosV5Req
	return r
}

func (r ApiCreateTradeCancelAdvanceAlgosV5Request) Execute() (*CreateTradeCancelAdvanceAlgosV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeCancelAdvanceAlgosV5Execute(r)
}

/*
CreateTradeCancelAdvanceAlgosV5 This endpoint will be offline soon, please use      Cancel unfilled algo orders (including Iceberg order, TWAP order, Trailing Stop order). A maximum of 10 orders can be canceled per request. Request parameters should be passed in the form of an array.  

This endpoint will be offline soon, please use  



Cancel unfilled algo orders (including Iceberg order, TWAP order, Trailing Stop order). A maximum of 10 orders can be canceled per request. Request parameters should be passed in the form of an array.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeCancelAdvanceAlgosV5Request
*/
func (a *AlgoTradingAPIService) CreateTradeCancelAdvanceAlgosV5(ctx context.Context) ApiCreateTradeCancelAdvanceAlgosV5Request {
	return ApiCreateTradeCancelAdvanceAlgosV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeCancelAdvanceAlgosV5Resp
func (a *AlgoTradingAPIService) CreateTradeCancelAdvanceAlgosV5Execute(r ApiCreateTradeCancelAdvanceAlgosV5Request) (*CreateTradeCancelAdvanceAlgosV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeCancelAdvanceAlgosV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlgoTradingAPIService.CreateTradeCancelAdvanceAlgosV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/cancel-advance-algos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeCancelAdvanceAlgosV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeCancelAdvanceAlgosV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeCancelAdvanceAlgosV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeCancelAlgosV5Request struct {
	ctx context.Context
	ApiService *AlgoTradingAPIService
	createTradeCancelAlgosV5Req *CreateTradeCancelAlgosV5Req
}

// The request body for CreateTradeCancelAlgosV5
func (r ApiCreateTradeCancelAlgosV5Request) CreateTradeCancelAlgosV5Req(createTradeCancelAlgosV5Req CreateTradeCancelAlgosV5Req) ApiCreateTradeCancelAlgosV5Request {
	r.createTradeCancelAlgosV5Req = &createTradeCancelAlgosV5Req
	return r
}

func (r ApiCreateTradeCancelAlgosV5Request) Execute() (*CreateTradeCancelAlgosV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeCancelAlgosV5Execute(r)
}

/*
CreateTradeCancelAlgosV5 Cancel unfilled algo orders. A maximum of 10 orders can be canceled per request. Request parameters should be passed in the form of an array.  

Cancel unfilled algo orders. A maximum of 10 orders can be canceled per request. Request parameters should be passed in the form of an array.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeCancelAlgosV5Request
*/
func (a *AlgoTradingAPIService) CreateTradeCancelAlgosV5(ctx context.Context) ApiCreateTradeCancelAlgosV5Request {
	return ApiCreateTradeCancelAlgosV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeCancelAlgosV5Resp
func (a *AlgoTradingAPIService) CreateTradeCancelAlgosV5Execute(r ApiCreateTradeCancelAlgosV5Request) (*CreateTradeCancelAlgosV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeCancelAlgosV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlgoTradingAPIService.CreateTradeCancelAlgosV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/cancel-algos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeCancelAlgosV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeCancelAlgosV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeCancelAlgosV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeOrderAlgoV5Request struct {
	ctx context.Context
	ApiService *AlgoTradingAPIService
	createTradeOrderAlgoV5Req *CreateTradeOrderAlgoV5Req
}

// The request body for CreateTradeOrderAlgoV5
func (r ApiCreateTradeOrderAlgoV5Request) CreateTradeOrderAlgoV5Req(createTradeOrderAlgoV5Req CreateTradeOrderAlgoV5Req) ApiCreateTradeOrderAlgoV5Request {
	r.createTradeOrderAlgoV5Req = &createTradeOrderAlgoV5Req
	return r
}

func (r ApiCreateTradeOrderAlgoV5Request) Execute() (*CreateTradeOrderAlgoV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeOrderAlgoV5Execute(r)
}

/*
CreateTradeOrderAlgoV5 The algo order includes `trigger` order, `oco` order, `chase` order, `conditional` order, `twap` order and trailing order.  

The algo order includes `trigger` order, `oco` order, `chase` order, `conditional` order, `twap` order and trailing order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate Limit of lead instruments for Copy Trading: 1 request per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeOrderAlgoV5Request
*/
func (a *AlgoTradingAPIService) CreateTradeOrderAlgoV5(ctx context.Context) ApiCreateTradeOrderAlgoV5Request {
	return ApiCreateTradeOrderAlgoV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeOrderAlgoV5Resp
func (a *AlgoTradingAPIService) CreateTradeOrderAlgoV5Execute(r ApiCreateTradeOrderAlgoV5Request) (*CreateTradeOrderAlgoV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeOrderAlgoV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlgoTradingAPIService.CreateTradeOrderAlgoV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/order-algo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeOrderAlgoV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeOrderAlgoV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeOrderAlgoV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOrderAlgoV5Request struct {
	ctx context.Context
	ApiService *AlgoTradingAPIService
	algoId *string
	algoClOrdId *string
}

// Algo ID  Either &#x60;algoId&#x60; or &#x60;algoClOrdId&#x60; is required.If both are passed, &#x60;algoId&#x60; will be used.
func (r ApiGetTradeOrderAlgoV5Request) AlgoId(algoId string) ApiGetTradeOrderAlgoV5Request {
	r.algoId = &algoId
	return r
}

// Client-supplied Algo ID  A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
func (r ApiGetTradeOrderAlgoV5Request) AlgoClOrdId(algoClOrdId string) ApiGetTradeOrderAlgoV5Request {
	r.algoClOrdId = &algoClOrdId
	return r
}

func (r ApiGetTradeOrderAlgoV5Request) Execute() (*GetTradeOrderAlgoV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOrderAlgoV5Execute(r)
}

/*
GetTradeOrderAlgoV5 Method for GetTradeOrderAlgoV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOrderAlgoV5Request
*/
func (a *AlgoTradingAPIService) GetTradeOrderAlgoV5(ctx context.Context) ApiGetTradeOrderAlgoV5Request {
	return ApiGetTradeOrderAlgoV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOrderAlgoV5Resp
func (a *AlgoTradingAPIService) GetTradeOrderAlgoV5Execute(r ApiGetTradeOrderAlgoV5Request) (*GetTradeOrderAlgoV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOrderAlgoV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlgoTradingAPIService.GetTradeOrderAlgoV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/order-algo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.algoId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	} else {
		var defaultValue string = ""
		r.algoId = &defaultValue
	}
	if r.algoClOrdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algoClOrdId", r.algoClOrdId, "form", "")
	} else {
		var defaultValue string = ""
		r.algoClOrdId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOrdersAlgoHistoryV5Request struct {
	ctx context.Context
	ApiService *AlgoTradingAPIService
	ordType *string
	state *string
	algoId *string
	instType *string
	instId *string
	after *string
	before *string
	limit *string
}

// Order type    &#x60;conditional&#x60;: One-way stop order    &#x60;oco&#x60;: One-cancels-the-other order   &#x60;chase&#x60;: chase order, only applicable to FUTURES and SWAP  &#x60;trigger&#x60;: Trigger order   &#x60;move_order_stop&#x60;: Trailing order   &#x60;iceberg&#x60;: Iceberg order   &#x60;twap&#x60;: TWAP order   For every request, unlike other ordType which only can use one type, &#x60;conditional&#x60; and &#x60;oco&#x60; both can be used and separated with comma.
func (r ApiGetTradeOrdersAlgoHistoryV5Request) OrdType(ordType string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.ordType = &ordType
	return r
}

// State  &#x60;effective&#x60;  &#x60;canceled&#x60;  &#x60;order_failed&#x60;  Either &#x60;state&#x60; or &#x60;algoId&#x60; is required
func (r ApiGetTradeOrdersAlgoHistoryV5Request) State(state string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.state = &state
	return r
}

// Algo ID   Either &#x60;state&#x60; or &#x60;algoId&#x60; is required.
func (r ApiGetTradeOrdersAlgoHistoryV5Request) AlgoId(algoId string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.algoId = &algoId
	return r
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;MARGIN&#x60;
func (r ApiGetTradeOrdersAlgoHistoryV5Request) InstType(instType string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetTradeOrdersAlgoHistoryV5Request) InstId(instId string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;algoId&#x60;
func (r ApiGetTradeOrdersAlgoHistoryV5Request) After(after string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records new than the requested &#x60;algoId&#x60;
func (r ApiGetTradeOrdersAlgoHistoryV5Request) Before(before string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;
func (r ApiGetTradeOrdersAlgoHistoryV5Request) Limit(limit string) ApiGetTradeOrdersAlgoHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeOrdersAlgoHistoryV5Request) Execute() (*GetTradeOrdersAlgoHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOrdersAlgoHistoryV5Execute(r)
}

/*
GetTradeOrdersAlgoHistoryV5 Retrieve a list of all algo orders under the current account in the last 3 months.  

Retrieve a list of all algo orders under the current account in the last 3 months.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOrdersAlgoHistoryV5Request
*/
func (a *AlgoTradingAPIService) GetTradeOrdersAlgoHistoryV5(ctx context.Context) ApiGetTradeOrdersAlgoHistoryV5Request {
	return ApiGetTradeOrdersAlgoHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOrdersAlgoHistoryV5Resp
func (a *AlgoTradingAPIService) GetTradeOrdersAlgoHistoryV5Execute(r ApiGetTradeOrdersAlgoHistoryV5Request) (*GetTradeOrdersAlgoHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOrdersAlgoHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlgoTradingAPIService.GetTradeOrdersAlgoHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/orders-algo-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ordType == nil {
		return localVarReturnValue, nil, reportError("ordType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.algoId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	} else {
		var defaultValue string = ""
		r.algoId = &defaultValue
	}
	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOrdersAlgoPendingV5Request struct {
	ctx context.Context
	ApiService *AlgoTradingAPIService
	ordType *string
	algoId *string
	algoClOrdId *string
	instType *string
	instId *string
	after *string
	before *string
	limit *string
}

// Order type  &#x60;conditional&#x60;: One-way stop order    &#x60;oco&#x60;: One-cancels-the-other order   &#x60;chase&#x60;: chase order, only applicable to FUTURES and SWAP  &#x60;trigger&#x60;: Trigger order   &#x60;move_order_stop&#x60;: Trailing order   &#x60;iceberg&#x60;: Iceberg order   &#x60;twap&#x60;: TWAP order  For every request, unlike other ordType which only can use one type, &#x60;conditional&#x60; and &#x60;oco&#x60; both can be used and separated with comma.
func (r ApiGetTradeOrdersAlgoPendingV5Request) OrdType(ordType string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.ordType = &ordType
	return r
}

// Algo ID
func (r ApiGetTradeOrdersAlgoPendingV5Request) AlgoId(algoId string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.algoId = &algoId
	return r
}

// Client-supplied Algo ID  A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
func (r ApiGetTradeOrdersAlgoPendingV5Request) AlgoClOrdId(algoClOrdId string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.algoClOrdId = &algoClOrdId
	return r
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;MARGIN&#x60;
func (r ApiGetTradeOrdersAlgoPendingV5Request) InstType(instType string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetTradeOrdersAlgoPendingV5Request) InstId(instId string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;algoId&#x60;.
func (r ApiGetTradeOrdersAlgoPendingV5Request) After(after string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;algoId&#x60;.
func (r ApiGetTradeOrdersAlgoPendingV5Request) Before(before string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;
func (r ApiGetTradeOrdersAlgoPendingV5Request) Limit(limit string) ApiGetTradeOrdersAlgoPendingV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeOrdersAlgoPendingV5Request) Execute() (*GetTradeOrdersAlgoPendingV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOrdersAlgoPendingV5Execute(r)
}

/*
GetTradeOrdersAlgoPendingV5 Retrieve a list of untriggered Algo orders under the current account.  

Retrieve a list of untriggered Algo orders under the current account.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOrdersAlgoPendingV5Request
*/
func (a *AlgoTradingAPIService) GetTradeOrdersAlgoPendingV5(ctx context.Context) ApiGetTradeOrdersAlgoPendingV5Request {
	return ApiGetTradeOrdersAlgoPendingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOrdersAlgoPendingV5Resp
func (a *AlgoTradingAPIService) GetTradeOrdersAlgoPendingV5Execute(r ApiGetTradeOrdersAlgoPendingV5Request) (*GetTradeOrdersAlgoPendingV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOrdersAlgoPendingV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlgoTradingAPIService.GetTradeOrdersAlgoPendingV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/orders-algo-pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ordType == nil {
		return localVarReturnValue, nil, reportError("ordType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	if r.algoId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	} else {
		var defaultValue string = ""
		r.algoId = &defaultValue
	}
	if r.algoClOrdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algoClOrdId", r.algoClOrdId, "form", "")
	} else {
		var defaultValue string = ""
		r.algoClOrdId = &defaultValue
	}
	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
