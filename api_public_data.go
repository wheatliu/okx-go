/*
Okx Rest API

OpenAPI specification for Okx cryptocurrency exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PublicDataAPIService PublicDataAPI service
type PublicDataAPIService service

type ApiGetMarketExchangeRateV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
}

func (r ApiGetMarketExchangeRateV5Request) Execute() (*GetMarketExchangeRateV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketExchangeRateV5Execute(r)
}

/*
GetMarketExchangeRateV5 This interface provides the average exchange rate data for 2 weeks  

This interface provides the average exchange rate data for 2 weeks

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketExchangeRateV5Request
*/
func (a *PublicDataAPIService) GetMarketExchangeRateV5(ctx context.Context) ApiGetMarketExchangeRateV5Request {
	return ApiGetMarketExchangeRateV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketExchangeRateV5Resp
func (a *PublicDataAPIService) GetMarketExchangeRateV5Execute(r ApiGetMarketExchangeRateV5Request) (*GetMarketExchangeRateV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketExchangeRateV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetMarketExchangeRateV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/exchange-rate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketHistoryIndexCandlesV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
	after *string
	before *string
	bar *string
	limit *string
}

// Index, e.g. &#x60;BTC-USD&#x60;
func (r ApiGetMarketHistoryIndexCandlesV5Request) InstId(instId string) ApiGetMarketHistoryIndexCandlesV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetMarketHistoryIndexCandlesV5Request) After(after string) ApiGetMarketHistoryIndexCandlesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;. The latest data will be returned when using &#x60;before&#x60; individually
func (r ApiGetMarketHistoryIndexCandlesV5Request) Before(before string) ApiGetMarketHistoryIndexCandlesV5Request {
	r.before = &before
	return r
}

// Bar size, the default is &#x60;1m&#x60;  e.g. [1m/3m/5m/15m/30m/1H/2H/4H]   Hong Kong time opening price k-line: [6H/12H/1D/1W/1M]  UTC time opening price k-line: [/6Hutc/12Hutc/1Dutc/1Wutc/1Mutc]
func (r ApiGetMarketHistoryIndexCandlesV5Request) Bar(bar string) ApiGetMarketHistoryIndexCandlesV5Request {
	r.bar = &bar
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetMarketHistoryIndexCandlesV5Request) Limit(limit string) ApiGetMarketHistoryIndexCandlesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketHistoryIndexCandlesV5Request) Execute() (*http.Response, error) {
	return r.ApiService.GetMarketHistoryIndexCandlesV5Execute(r)
}

/*
GetMarketHistoryIndexCandlesV5 Retrieve the candlestick charts of the index from recent years.  

Retrieve the candlestick charts of the index from recent years.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketHistoryIndexCandlesV5Request
*/
func (a *PublicDataAPIService) GetMarketHistoryIndexCandlesV5(ctx context.Context) ApiGetMarketHistoryIndexCandlesV5Request {
	return ApiGetMarketHistoryIndexCandlesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PublicDataAPIService) GetMarketHistoryIndexCandlesV5Execute(r ApiGetMarketHistoryIndexCandlesV5Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetMarketHistoryIndexCandlesV5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/history-index-candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "form", "")
	} else {
		var defaultValue string = ""
		r.bar = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMarketHistoryMarkPriceCandlesV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
	after *string
	before *string
	bar *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USD-SWAP&#x60;
func (r ApiGetMarketHistoryMarkPriceCandlesV5Request) InstId(instId string) ApiGetMarketHistoryMarkPriceCandlesV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetMarketHistoryMarkPriceCandlesV5Request) After(after string) ApiGetMarketHistoryMarkPriceCandlesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;. The latest data will be returned when using &#x60;before&#x60; individually
func (r ApiGetMarketHistoryMarkPriceCandlesV5Request) Before(before string) ApiGetMarketHistoryMarkPriceCandlesV5Request {
	r.before = &before
	return r
}

// Bar size, the default is &#x60;1m&#x60;  e.g. [1m/3m/5m/15m/30m/1H/2H/4H]   Hong Kong time opening price k-line: [6H/12H/1D/1W/1M]  UTC time opening price k-line: [6Hutc/12Hutc/1Dutc/1Wutc/1Mutc]
func (r ApiGetMarketHistoryMarkPriceCandlesV5Request) Bar(bar string) ApiGetMarketHistoryMarkPriceCandlesV5Request {
	r.bar = &bar
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetMarketHistoryMarkPriceCandlesV5Request) Limit(limit string) ApiGetMarketHistoryMarkPriceCandlesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketHistoryMarkPriceCandlesV5Request) Execute() (*http.Response, error) {
	return r.ApiService.GetMarketHistoryMarkPriceCandlesV5Execute(r)
}

/*
GetMarketHistoryMarkPriceCandlesV5 Retrieve the candlestick charts of mark price from recent years.  

Retrieve the candlestick charts of mark price from recent years.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketHistoryMarkPriceCandlesV5Request
*/
func (a *PublicDataAPIService) GetMarketHistoryMarkPriceCandlesV5(ctx context.Context) ApiGetMarketHistoryMarkPriceCandlesV5Request {
	return ApiGetMarketHistoryMarkPriceCandlesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PublicDataAPIService) GetMarketHistoryMarkPriceCandlesV5Execute(r ApiGetMarketHistoryMarkPriceCandlesV5Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetMarketHistoryMarkPriceCandlesV5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/history-mark-price-candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "form", "")
	} else {
		var defaultValue string = ""
		r.bar = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMarketIndexCandlesV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
	after *string
	before *string
	bar *string
	limit *string
}

// Index, e.g. &#x60;BTC-USD&#x60;
func (r ApiGetMarketIndexCandlesV5Request) InstId(instId string) ApiGetMarketIndexCandlesV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetMarketIndexCandlesV5Request) After(after string) ApiGetMarketIndexCandlesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;. The latest data will be returned when using &#x60;before&#x60; individually
func (r ApiGetMarketIndexCandlesV5Request) Before(before string) ApiGetMarketIndexCandlesV5Request {
	r.before = &before
	return r
}

// Bar size, the default is &#x60;1m&#x60;  e.g. [&#x60;1m&#x60;/&#x60;3m&#x60;/&#x60;5m&#x60;/&#x60;15m&#x60;/&#x60;30m&#x60;/&#x60;1H&#x60;/&#x60;2H&#x60;/&#x60;4H&#x60;]   Hong Kong time opening price k-line: [&#x60;6H&#x60;/&#x60;12H&#x60;/&#x60;1D&#x60;/&#x60;1W&#x60;/&#x60;1M&#x60;/&#x60;3M&#x60;]  UTC time opening price k-line: [&#x60;6Hutc&#x60;/&#x60;12Hutc&#x60;/&#x60;1Dutc&#x60;/&#x60;1Wutc&#x60;/&#x60;1Mutc&#x60;/&#x60;3Mutc&#x60;]
func (r ApiGetMarketIndexCandlesV5Request) Bar(bar string) ApiGetMarketIndexCandlesV5Request {
	r.bar = &bar
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;
func (r ApiGetMarketIndexCandlesV5Request) Limit(limit string) ApiGetMarketIndexCandlesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketIndexCandlesV5Request) Execute() (*http.Response, error) {
	return r.ApiService.GetMarketIndexCandlesV5Execute(r)
}

/*
GetMarketIndexCandlesV5 Retrieve the candlestick charts of the index. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.   

Retrieve the candlestick charts of the index. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar. 

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketIndexCandlesV5Request
*/
func (a *PublicDataAPIService) GetMarketIndexCandlesV5(ctx context.Context) ApiGetMarketIndexCandlesV5Request {
	return ApiGetMarketIndexCandlesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PublicDataAPIService) GetMarketIndexCandlesV5Execute(r ApiGetMarketIndexCandlesV5Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetMarketIndexCandlesV5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/index-candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "form", "")
	} else {
		var defaultValue string = ""
		r.bar = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMarketIndexComponentsV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	index *string
}

// index, e.g &#x60;BTC-USDT&#x60;
func (r ApiGetMarketIndexComponentsV5Request) Index(index string) ApiGetMarketIndexComponentsV5Request {
	r.index = &index
	return r
}

func (r ApiGetMarketIndexComponentsV5Request) Execute() (*GetMarketIndexComponentsV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketIndexComponentsV5Execute(r)
}

/*
GetMarketIndexComponentsV5 Get the index component information data on the market  

Get the index component information data on the market

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketIndexComponentsV5Request
*/
func (a *PublicDataAPIService) GetMarketIndexComponentsV5(ctx context.Context) ApiGetMarketIndexComponentsV5Request {
	return ApiGetMarketIndexComponentsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketIndexComponentsV5Resp
func (a *PublicDataAPIService) GetMarketIndexComponentsV5Execute(r ApiGetMarketIndexComponentsV5Request) (*GetMarketIndexComponentsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketIndexComponentsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetMarketIndexComponentsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/index-components"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.index == nil {
		return localVarReturnValue, nil, reportError("index is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketIndexTickersV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	quoteCcy *string
	instId *string
}

// Quote currency   Currently there is only an index with &#x60;USD/USDT/BTC/USDC&#x60; as the quote currency.
func (r ApiGetMarketIndexTickersV5Request) QuoteCcy(quoteCcy string) ApiGetMarketIndexTickersV5Request {
	r.quoteCcy = &quoteCcy
	return r
}

// Index, e.g. &#x60;BTC-USD&#x60;  Either &#x60;quoteCcy&#x60; or &#x60;instId&#x60; is required.
func (r ApiGetMarketIndexTickersV5Request) InstId(instId string) ApiGetMarketIndexTickersV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetMarketIndexTickersV5Request) Execute() (*GetMarketIndexTickersV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketIndexTickersV5Execute(r)
}

/*
GetMarketIndexTickersV5 Retrieve index tickers.  

Retrieve index tickers.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketIndexTickersV5Request
*/
func (a *PublicDataAPIService) GetMarketIndexTickersV5(ctx context.Context) ApiGetMarketIndexTickersV5Request {
	return ApiGetMarketIndexTickersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketIndexTickersV5Resp
func (a *PublicDataAPIService) GetMarketIndexTickersV5Execute(r ApiGetMarketIndexTickersV5Request) (*GetMarketIndexTickersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketIndexTickersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetMarketIndexTickersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/index-tickers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.quoteCcy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quoteCcy", r.quoteCcy, "form", "")
	} else {
		var defaultValue string = ""
		r.quoteCcy = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketMarkPriceCandlesV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
	after *string
	before *string
	bar *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USD-SWAP&#x60;
func (r ApiGetMarketMarkPriceCandlesV5Request) InstId(instId string) ApiGetMarketMarkPriceCandlesV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetMarketMarkPriceCandlesV5Request) After(after string) ApiGetMarketMarkPriceCandlesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;. The latest data will be returned when using &#x60;before&#x60; individually
func (r ApiGetMarketMarkPriceCandlesV5Request) Before(before string) ApiGetMarketMarkPriceCandlesV5Request {
	r.before = &before
	return r
}

// Bar size, the default is &#x60;1m&#x60;  e.g. [1m/3m/5m/15m/30m/1H/2H/4H]   Hong Kong time opening price k-line: [6H/12H/1D/1W/1M/3M]  UTC time opening price k-line: [6Hutc/12Hutc/1Dutc/1Wutc/1Mutc/3Mutc]
func (r ApiGetMarketMarkPriceCandlesV5Request) Bar(bar string) ApiGetMarketMarkPriceCandlesV5Request {
	r.bar = &bar
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetMarketMarkPriceCandlesV5Request) Limit(limit string) ApiGetMarketMarkPriceCandlesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketMarkPriceCandlesV5Request) Execute() (*http.Response, error) {
	return r.ApiService.GetMarketMarkPriceCandlesV5Execute(r)
}

/*
GetMarketMarkPriceCandlesV5 Retrieve the candlestick charts of mark price. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.  

Retrieve the candlestick charts of mark price. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketMarkPriceCandlesV5Request
*/
func (a *PublicDataAPIService) GetMarketMarkPriceCandlesV5(ctx context.Context) ApiGetMarketMarkPriceCandlesV5Request {
	return ApiGetMarketMarkPriceCandlesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PublicDataAPIService) GetMarketMarkPriceCandlesV5Execute(r ApiGetMarketMarkPriceCandlesV5Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetMarketMarkPriceCandlesV5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/mark-price-candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "form", "")
	} else {
		var defaultValue string = ""
		r.bar = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPublicConvertContractCoinV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
	sz *string
	type_ *string
	px *string
	unit *string
	opType *string
}

// Instrument ID  only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetPublicConvertContractCoinV5Request) InstId(instId string) ApiGetPublicConvertContractCoinV5Request {
	r.instId = &instId
	return r
}

// Quantity to buy or sell  It is quantity of currency while converting currency to contract;   It is quantity of contract while converting contract to currency.
func (r ApiGetPublicConvertContractCoinV5Request) Sz(sz string) ApiGetPublicConvertContractCoinV5Request {
	r.sz = &sz
	return r
}

// Convert type  &#x60;1&#x60;: Convert currency to contract  &#x60;2&#x60;: Convert contract to currency  The default is &#x60;1&#x60;
func (r ApiGetPublicConvertContractCoinV5Request) Type_(type_ string) ApiGetPublicConvertContractCoinV5Request {
	r.type_ = &type_
	return r
}

// Order price  For crypto-margined contracts, it is necessary while converting.  For USDT-margined contracts, it is necessary while converting between usdt and contract.  It is optional while converting between coin and contract.   For OPTION, it is optional.
func (r ApiGetPublicConvertContractCoinV5Request) Px(px string) ApiGetPublicConvertContractCoinV5Request {
	r.px = &px
	return r
}

// The unit of currency  &#x60;coin&#x60;  &#x60;usds&#x60;: USDT/USDC  only applicable to USDⓈ-margined contracts from &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;
func (r ApiGetPublicConvertContractCoinV5Request) Unit(unit string) ApiGetPublicConvertContractCoinV5Request {
	r.unit = &unit
	return r
}

// Order type  &#x60;open&#x60;: round down sz when opening positions   &#x60;close&#x60;: round sz to the nearest when closing positions   The default is &#x60;close&#x60;   Applicable to &#x60;FUTURES&#x60; &#x60;SWAP&#x60;
func (r ApiGetPublicConvertContractCoinV5Request) OpType(opType string) ApiGetPublicConvertContractCoinV5Request {
	r.opType = &opType
	return r
}

func (r ApiGetPublicConvertContractCoinV5Request) Execute() (*GetPublicConvertContractCoinV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicConvertContractCoinV5Execute(r)
}

/*
GetPublicConvertContractCoinV5 Convert the crypto value to the number of contracts, or vice versa  

Convert the crypto value to the number of contracts, or vice versa

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicConvertContractCoinV5Request
*/
func (a *PublicDataAPIService) GetPublicConvertContractCoinV5(ctx context.Context) ApiGetPublicConvertContractCoinV5Request {
	return ApiGetPublicConvertContractCoinV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicConvertContractCoinV5Resp
func (a *PublicDataAPIService) GetPublicConvertContractCoinV5Execute(r ApiGetPublicConvertContractCoinV5Request) (*GetPublicConvertContractCoinV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicConvertContractCoinV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicConvertContractCoinV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/convert-contract-coin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}
	if r.sz == nil {
		return localVarReturnValue, nil, reportError("sz is required and must be specified")
	}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sz", r.sz, "form", "")
	if r.px != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "px", r.px, "form", "")
	} else {
		var defaultValue string = ""
		r.px = &defaultValue
	}
	if r.unit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit", r.unit, "form", "")
	} else {
		var defaultValue string = ""
		r.unit = &defaultValue
	}
	if r.opType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "opType", r.opType, "form", "")
	} else {
		var defaultValue string = ""
		r.opType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicDeliveryExerciseHistoryV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
	uly *string
	instFamily *string
	after *string
	before *string
	limit *string
}

// Instrument type  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetPublicDeliveryExerciseHistoryV5Request) InstType(instType string) ApiGetPublicDeliveryExerciseHistoryV5Request {
	r.instType = &instType
	return r
}

// Underlying, only applicable to &#x60;FUTURES&#x60;/&#x60;OPTION&#x60;  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicDeliveryExerciseHistoryV5Request) Uly(uly string) ApiGetPublicDeliveryExerciseHistoryV5Request {
	r.uly = &uly
	return r
}

// Instrument family, only applicable to &#x60;FUTURES&#x60;/&#x60;OPTION&#x60;  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicDeliveryExerciseHistoryV5Request) InstFamily(instFamily string) ApiGetPublicDeliveryExerciseHistoryV5Request {
	r.instFamily = &instFamily
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetPublicDeliveryExerciseHistoryV5Request) After(after string) ApiGetPublicDeliveryExerciseHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;
func (r ApiGetPublicDeliveryExerciseHistoryV5Request) Before(before string) ApiGetPublicDeliveryExerciseHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetPublicDeliveryExerciseHistoryV5Request) Limit(limit string) ApiGetPublicDeliveryExerciseHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetPublicDeliveryExerciseHistoryV5Request) Execute() (*GetPublicDeliveryExerciseHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicDeliveryExerciseHistoryV5Execute(r)
}

/*
GetPublicDeliveryExerciseHistoryV5 Retrieve delivery records of Futures and exercise records of Options in the last 3 months.  

Retrieve delivery records of Futures and exercise records of Options in the last 3 months.

#### Rate Limit: 40 requests per 2 seconds 

#### Rate limit rule: IP + (Instrument Type + uly) 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicDeliveryExerciseHistoryV5Request
*/
func (a *PublicDataAPIService) GetPublicDeliveryExerciseHistoryV5(ctx context.Context) ApiGetPublicDeliveryExerciseHistoryV5Request {
	return ApiGetPublicDeliveryExerciseHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicDeliveryExerciseHistoryV5Resp
func (a *PublicDataAPIService) GetPublicDeliveryExerciseHistoryV5Execute(r ApiGetPublicDeliveryExerciseHistoryV5Request) (*GetPublicDeliveryExerciseHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicDeliveryExerciseHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicDeliveryExerciseHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/delivery-exercise-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicDiscountRateInterestFreeQuotaV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	ccy *string
	discountLv *string
}

// Currency
func (r ApiGetPublicDiscountRateInterestFreeQuotaV5Request) Ccy(ccy string) ApiGetPublicDiscountRateInterestFreeQuotaV5Request {
	r.ccy = &ccy
	return r
}

// Discount level (Deprecated) 
func (r ApiGetPublicDiscountRateInterestFreeQuotaV5Request) DiscountLv(discountLv string) ApiGetPublicDiscountRateInterestFreeQuotaV5Request {
	r.discountLv = &discountLv
	return r
}

func (r ApiGetPublicDiscountRateInterestFreeQuotaV5Request) Execute() (*GetPublicDiscountRateInterestFreeQuotaV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicDiscountRateInterestFreeQuotaV5Execute(r)
}

/*
GetPublicDiscountRateInterestFreeQuotaV5 Retrieve discount rate level and interest-free quota.  

Retrieve discount rate level and interest-free quota.

#### Rate Limit: 2 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicDiscountRateInterestFreeQuotaV5Request
*/
func (a *PublicDataAPIService) GetPublicDiscountRateInterestFreeQuotaV5(ctx context.Context) ApiGetPublicDiscountRateInterestFreeQuotaV5Request {
	return ApiGetPublicDiscountRateInterestFreeQuotaV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicDiscountRateInterestFreeQuotaV5Resp
func (a *PublicDataAPIService) GetPublicDiscountRateInterestFreeQuotaV5Execute(r ApiGetPublicDiscountRateInterestFreeQuotaV5Request) (*GetPublicDiscountRateInterestFreeQuotaV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicDiscountRateInterestFreeQuotaV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicDiscountRateInterestFreeQuotaV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/discount-rate-interest-free-quota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.discountLv != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountLv", r.discountLv, "form", "")
	} else {
		var defaultValue string = ""
		r.discountLv = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicEconomicCalendarV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	region *string
	importance *string
	before *string
	after *string
	limit *string
}

// Country, region or entity   &#x60;afghanistan&#x60;, &#x60;albania&#x60;, &#x60;algeria&#x60;, &#x60;andorra&#x60;, &#x60;angola&#x60;, &#x60;antigua_and_barbuda&#x60;, &#x60;argentina&#x60;, &#x60;armenia&#x60;, &#x60;aruba&#x60;, &#x60;australia&#x60;, &#x60;austria&#x60;, &#x60;azerbaijan&#x60;, &#x60;bahamas&#x60;, &#x60;bahrain&#x60;, &#x60;bangladesh&#x60;, &#x60;barbados&#x60;, &#x60;belarus&#x60;, &#x60;belgium&#x60;, &#x60;belize&#x60;, &#x60;benin&#x60;, &#x60;bermuda&#x60;, &#x60;bhutan&#x60;, &#x60;bolivia&#x60;, &#x60;bosnia_and_herzegovina&#x60;, &#x60;botswana&#x60;, &#x60;brazil&#x60;, &#x60;brunei&#x60;, &#x60;bulgaria&#x60;, &#x60;burkina_faso&#x60;, &#x60;burundi&#x60;, &#x60;cambodia&#x60;, &#x60;cameroon&#x60;, &#x60;canada&#x60;, &#x60;cape_verde&#x60;, &#x60;cayman_islands&#x60;, &#x60;central_african_republic&#x60;, &#x60;chad&#x60;, &#x60;chile&#x60;, &#x60;china&#x60;, &#x60;colombia&#x60;, &#x60;comoros&#x60;, &#x60;congo&#x60;, &#x60;costa_rica&#x60;, &#x60;croatia&#x60;, &#x60;cuba&#x60;, &#x60;cyprus&#x60;, &#x60;czech_republic&#x60;, &#x60;denmark&#x60;, &#x60;djibouti&#x60;, &#x60;dominica&#x60;, &#x60;dominican_republic&#x60;, &#x60;east_timor&#x60;, &#x60;ecuador&#x60;, &#x60;egypt&#x60;, &#x60;el_salvador&#x60;, &#x60;equatorial_guinea&#x60;, &#x60;eritrea&#x60;, &#x60;estonia&#x60;, &#x60;ethiopia&#x60;, &#x60;euro_area&#x60;, &#x60;european_union&#x60;, &#x60;faroe_islands&#x60;, &#x60;fiji&#x60;, &#x60;finland&#x60;, &#x60;france&#x60;, &#x60;g20&#x60;, &#x60;g7&#x60;, &#x60;gabon&#x60;, &#x60;gambia&#x60;, &#x60;georgia&#x60;, &#x60;germany&#x60;, &#x60;ghana&#x60;, &#x60;greece&#x60;, &#x60;greenland&#x60;, &#x60;grenada&#x60;, &#x60;guatemala&#x60;, &#x60;guinea&#x60;, &#x60;guinea_bissau&#x60;, &#x60;guyana&#x60;, &#x60;hungary&#x60;, &#x60;haiti&#x60;, &#x60;honduras&#x60;, &#x60;hong_kong&#x60;, &#x60;hungary&#x60;, &#x60;imf&#x60;, &#x60;indonesia&#x60;, &#x60;iceland&#x60;, &#x60;india&#x60;, &#x60;indonesia&#x60;, &#x60;iran&#x60;, &#x60;iraq&#x60;, &#x60;ireland&#x60;, &#x60;isle_of_man&#x60;, &#x60;israel&#x60;, &#x60;italy&#x60;, &#x60;ivory_coast&#x60;, &#x60;jamaica&#x60;, &#x60;japan&#x60;, &#x60;jordan&#x60;, &#x60;kazakhstan&#x60;, &#x60;kenya&#x60;, &#x60;kiribati&#x60;, &#x60;kosovo&#x60;, &#x60;kuwait&#x60;, &#x60;kyrgyzstan&#x60;, &#x60;laos&#x60;, &#x60;latvia&#x60;, &#x60;lebanon&#x60;, &#x60;lesotho&#x60;, &#x60;liberia&#x60;, &#x60;libya&#x60;, &#x60;liechtenstein&#x60;, &#x60;lithuania&#x60;, &#x60;luxembourg&#x60;, &#x60;macau&#x60;, &#x60;macedonia&#x60;, &#x60;madagascar&#x60;, &#x60;malawi&#x60;, &#x60;malaysia&#x60;, &#x60;maldives&#x60;, &#x60;mali&#x60;, &#x60;malta&#x60;, &#x60;mauritania&#x60;, &#x60;mauritius&#x60;, &#x60;mexico&#x60;, &#x60;micronesia&#x60;, &#x60;moldova&#x60;, &#x60;monaco&#x60;, &#x60;mongolia&#x60;, &#x60;montenegro&#x60;, &#x60;morocco&#x60;, &#x60;mozambique&#x60;, &#x60;myanmar&#x60;, &#x60;namibia&#x60;, &#x60;nepal&#x60;, &#x60;netherlands&#x60;, &#x60;new_caledonia&#x60;, &#x60;new_zealand&#x60;, &#x60;nicaragua&#x60;, &#x60;niger&#x60;, &#x60;nigeria&#x60;, &#x60;north_korea&#x60;, &#x60;northern_mariana_islands&#x60;, &#x60;norway&#x60;, &#x60;opec&#x60;, &#x60;oman&#x60;, &#x60;pakistan&#x60;, &#x60;palau&#x60;, &#x60;palestine&#x60;, &#x60;panama&#x60;, &#x60;papua_new_guinea&#x60;, &#x60;paraguay&#x60;, &#x60;peru&#x60;, &#x60;philippines&#x60;, &#x60;poland&#x60;, &#x60;portugal&#x60;, &#x60;puerto_rico&#x60;, &#x60;qatar&#x60;, &#x60;russia&#x60;, &#x60;republic_of_the_congo&#x60;, &#x60;romania&#x60;, &#x60;russia&#x60;, &#x60;rwanda&#x60;, &#x60;slovakia&#x60;, &#x60;samoa&#x60;, &#x60;san_marino&#x60;, &#x60;sao_tome_and_principe&#x60;, &#x60;saudi_arabia&#x60;, &#x60;senegal&#x60;, &#x60;serbia&#x60;, &#x60;seychelles&#x60;, &#x60;sierra_leone&#x60;, &#x60;singapore&#x60;, &#x60;slovakia&#x60;, &#x60;slovenia&#x60;, &#x60;solomon_islands&#x60;, &#x60;somalia&#x60;, &#x60;south_africa&#x60;, &#x60;south_korea&#x60;, &#x60;south_sudan&#x60;, &#x60;spain&#x60;, &#x60;sri_lanka&#x60;, &#x60;st_kitts_and_nevis&#x60;, &#x60;st_lucia&#x60;, &#x60;sudan&#x60;, &#x60;suriname&#x60;, &#x60;swaziland&#x60;, &#x60;sweden&#x60;, &#x60;switzerland&#x60;, &#x60;syria&#x60;, &#x60;taiwan&#x60;, &#x60;tajikistan&#x60;, &#x60;tanzania&#x60;, &#x60;thailand&#x60;, &#x60;togo&#x60;, &#x60;tonga&#x60;, &#x60;trinidad_and_tobago&#x60;, &#x60;tunisia&#x60;, &#x60;turkey&#x60;, &#x60;turkmenistan&#x60;, &#x60;uganda&#x60;, &#x60;ukraine&#x60;, &#x60;united_arab_emirates&#x60;, &#x60;united_kingdom&#x60;, &#x60;united_states&#x60;, &#x60;uruguay&#x60;, &#x60;uzbekistan&#x60;, &#x60;vanuatu&#x60;, &#x60;venezuela&#x60;, &#x60;vietnam&#x60;, &#x60;world&#x60;, &#x60;yemen&#x60;, &#x60;zambia&#x60;, &#x60;zimbabwe&#x60;
func (r ApiGetPublicEconomicCalendarV5Request) Region(region string) ApiGetPublicEconomicCalendarV5Request {
	r.region = &region
	return r
}

// Level of importance   &#x60;1&#x60;: low   &#x60;2&#x60;: medium   &#x60;3&#x60;: high
func (r ApiGetPublicEconomicCalendarV5Request) Importance(importance string) ApiGetPublicEconomicCalendarV5Request {
	r.importance = &importance
	return r
}

// Pagination of data to return records newer than the requested ts based on the date parameter. Unix timestamp format in milliseconds.
func (r ApiGetPublicEconomicCalendarV5Request) Before(before string) ApiGetPublicEconomicCalendarV5Request {
	r.before = &before
	return r
}

// Pagination of data to return records earlier than the requested ts based on the date parameter. Unix timestamp format in milliseconds. The default is the timestamp of the request moment.
func (r ApiGetPublicEconomicCalendarV5Request) After(after string) ApiGetPublicEconomicCalendarV5Request {
	r.after = &after
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetPublicEconomicCalendarV5Request) Limit(limit string) ApiGetPublicEconomicCalendarV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetPublicEconomicCalendarV5Request) Execute() (*GetPublicEconomicCalendarV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicEconomicCalendarV5Execute(r)
}

/*
GetPublicEconomicCalendarV5 Get the macro-economic calendar data within 3 months. Historical data from 3 months ago is only available to users with trading fee tier VIP1 and above.  

**_Authentication is required for this endpoint. This endpoint is only supported in production environment._**

Get the macro-economic calendar data within 3 months. Historical data from 3 months ago is only available to users with trading fee tier VIP1 and above.

#### Rate Limit: 1 request per 5 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicEconomicCalendarV5Request
*/
func (a *PublicDataAPIService) GetPublicEconomicCalendarV5(ctx context.Context) ApiGetPublicEconomicCalendarV5Request {
	return ApiGetPublicEconomicCalendarV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicEconomicCalendarV5Resp
func (a *PublicDataAPIService) GetPublicEconomicCalendarV5Execute(r ApiGetPublicEconomicCalendarV5Request) (*GetPublicEconomicCalendarV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicEconomicCalendarV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicEconomicCalendarV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/economic-calendar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "form", "")
	} else {
		var defaultValue string = ""
		r.region = &defaultValue
	}
	if r.importance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importance", r.importance, "form", "")
	} else {
		var defaultValue string = ""
		r.importance = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicEstimatedPriceV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
}

// Instrument ID, e.g. &#x60;BTC-USD-200214&#x60;   only applicable to &#x60;FUTURES&#x60;/&#x60;OPTION&#x60;
func (r ApiGetPublicEstimatedPriceV5Request) InstId(instId string) ApiGetPublicEstimatedPriceV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetPublicEstimatedPriceV5Request) Execute() (*GetPublicEstimatedPriceV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicEstimatedPriceV5Execute(r)
}

/*
GetPublicEstimatedPriceV5 Retrieve the estimated delivery price which will only have a return value one hour before the delivery/exercise.  

Retrieve the estimated delivery price which will only have a return value one hour before the delivery/exercise.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicEstimatedPriceV5Request
*/
func (a *PublicDataAPIService) GetPublicEstimatedPriceV5(ctx context.Context) ApiGetPublicEstimatedPriceV5Request {
	return ApiGetPublicEstimatedPriceV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicEstimatedPriceV5Resp
func (a *PublicDataAPIService) GetPublicEstimatedPriceV5Execute(r ApiGetPublicEstimatedPriceV5Request) (*GetPublicEstimatedPriceV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicEstimatedPriceV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicEstimatedPriceV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/estimated-price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicEstimatedSettlementInfoV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
}

// Instrument ID, e.g. &#x60;XRP-USDT-250307&#x60;   only applicable to &#x60;FUTURES&#x60;
func (r ApiGetPublicEstimatedSettlementInfoV5Request) InstId(instId string) ApiGetPublicEstimatedSettlementInfoV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetPublicEstimatedSettlementInfoV5Request) Execute() (*GetPublicEstimatedSettlementInfoV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicEstimatedSettlementInfoV5Execute(r)
}

/*
GetPublicEstimatedSettlementInfoV5 Retrieve the estimated settlement price which will only have a return value one hour before the settlement.  

Retrieve the estimated settlement price which will only have a return value one hour before the settlement.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicEstimatedSettlementInfoV5Request
*/
func (a *PublicDataAPIService) GetPublicEstimatedSettlementInfoV5(ctx context.Context) ApiGetPublicEstimatedSettlementInfoV5Request {
	return ApiGetPublicEstimatedSettlementInfoV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicEstimatedSettlementInfoV5Resp
func (a *PublicDataAPIService) GetPublicEstimatedSettlementInfoV5Execute(r ApiGetPublicEstimatedSettlementInfoV5Request) (*GetPublicEstimatedSettlementInfoV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicEstimatedSettlementInfoV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicEstimatedSettlementInfoV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/estimated-settlement-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicFundingRateHistoryV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
	before *string
	after *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USD-SWAP&#x60;   only applicable to &#x60;SWAP&#x60;
func (r ApiGetPublicFundingRateHistoryV5Request) InstId(instId string) ApiGetPublicFundingRateHistoryV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records newer than the requested &#x60;fundingTime&#x60;
func (r ApiGetPublicFundingRateHistoryV5Request) Before(before string) ApiGetPublicFundingRateHistoryV5Request {
	r.before = &before
	return r
}

// Pagination of data to return records earlier than the requested &#x60;fundingTime&#x60;
func (r ApiGetPublicFundingRateHistoryV5Request) After(after string) ApiGetPublicFundingRateHistoryV5Request {
	r.after = &after
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetPublicFundingRateHistoryV5Request) Limit(limit string) ApiGetPublicFundingRateHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetPublicFundingRateHistoryV5Request) Execute() (*GetPublicFundingRateHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicFundingRateHistoryV5Execute(r)
}

/*
GetPublicFundingRateHistoryV5 Retrieve funding rate history. This endpoint can retrieve data from the last 3 months.  

Retrieve funding rate history. This endpoint can retrieve data from the last 3 months.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicFundingRateHistoryV5Request
*/
func (a *PublicDataAPIService) GetPublicFundingRateHistoryV5(ctx context.Context) ApiGetPublicFundingRateHistoryV5Request {
	return ApiGetPublicFundingRateHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicFundingRateHistoryV5Resp
func (a *PublicDataAPIService) GetPublicFundingRateHistoryV5Execute(r ApiGetPublicFundingRateHistoryV5Request) (*GetPublicFundingRateHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicFundingRateHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicFundingRateHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/funding-rate-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicFundingRateV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
}

// Instrument ID, e.g. &#x60;BTC-USD-SWAP&#x60;   only applicable to &#x60;SWAP&#x60;
func (r ApiGetPublicFundingRateV5Request) InstId(instId string) ApiGetPublicFundingRateV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetPublicFundingRateV5Request) Execute() (*GetPublicFundingRateV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicFundingRateV5Execute(r)
}

/*
GetPublicFundingRateV5 Retrieve funding rate.  

Retrieve funding rate.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicFundingRateV5Request
*/
func (a *PublicDataAPIService) GetPublicFundingRateV5(ctx context.Context) ApiGetPublicFundingRateV5Request {
	return ApiGetPublicFundingRateV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicFundingRateV5Resp
func (a *PublicDataAPIService) GetPublicFundingRateV5Execute(r ApiGetPublicFundingRateV5Request) (*GetPublicFundingRateV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicFundingRateV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicFundingRateV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/funding-rate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicInstrumentTickBandsV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
	instFamily *string
}

// Instrument type  &#x60;OPTION&#x60;
func (r ApiGetPublicInstrumentTickBandsV5Request) InstType(instType string) ApiGetPublicInstrumentTickBandsV5Request {
	r.instType = &instType
	return r
}

// Instrument family  Only applicable to OPTION
func (r ApiGetPublicInstrumentTickBandsV5Request) InstFamily(instFamily string) ApiGetPublicInstrumentTickBandsV5Request {
	r.instFamily = &instFamily
	return r
}

func (r ApiGetPublicInstrumentTickBandsV5Request) Execute() (*GetPublicInstrumentTickBandsV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicInstrumentTickBandsV5Execute(r)
}

/*
GetPublicInstrumentTickBandsV5 Get option tick bands information  

Get option tick bands information

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicInstrumentTickBandsV5Request
*/
func (a *PublicDataAPIService) GetPublicInstrumentTickBandsV5(ctx context.Context) ApiGetPublicInstrumentTickBandsV5Request {
	return ApiGetPublicInstrumentTickBandsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicInstrumentTickBandsV5Resp
func (a *PublicDataAPIService) GetPublicInstrumentTickBandsV5Execute(r ApiGetPublicInstrumentTickBandsV5Request) (*GetPublicInstrumentTickBandsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicInstrumentTickBandsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicInstrumentTickBandsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/instrument-tick-bands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicInstrumentsV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
}

// Instrument type  &#x60;SPOT&#x60;: Spot  &#x60;MARGIN&#x60;: Margin  &#x60;SWAP&#x60;: Perpetual Futures  &#x60;FUTURES&#x60;: Expiry Futures  &#x60;OPTION&#x60;: Option
func (r ApiGetPublicInstrumentsV5Request) InstType(instType string) ApiGetPublicInstrumentsV5Request {
	r.instType = &instType
	return r
}

// Underlying   Only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;.If instType is &#x60;OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.
func (r ApiGetPublicInstrumentsV5Request) Uly(uly string) ApiGetPublicInstrumentsV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;. If instType is &#x60;OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.
func (r ApiGetPublicInstrumentsV5Request) InstFamily(instFamily string) ApiGetPublicInstrumentsV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID
func (r ApiGetPublicInstrumentsV5Request) InstId(instId string) ApiGetPublicInstrumentsV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetPublicInstrumentsV5Request) Execute() (*GetPublicInstrumentsV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicInstrumentsV5Execute(r)
}

/*
GetPublicInstrumentsV5 Retrieve a list of instruments with open contracts for OKX. Retrieve available instruments info of current account, please refer to .  

Retrieve a list of instruments with open contracts for OKX. Retrieve available instruments info of current account, please refer to .

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP + Instrument Type 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicInstrumentsV5Request
*/
func (a *PublicDataAPIService) GetPublicInstrumentsV5(ctx context.Context) ApiGetPublicInstrumentsV5Request {
	return ApiGetPublicInstrumentsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicInstrumentsV5Resp
func (a *PublicDataAPIService) GetPublicInstrumentsV5Execute(r ApiGetPublicInstrumentsV5Request) (*GetPublicInstrumentsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicInstrumentsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicInstrumentsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/instruments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicInsuranceFundV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
	type_ *string
	uly *string
	instFamily *string
	ccy *string
	before *string
	after *string
	limit *string
}

// Instrument type  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetPublicInsuranceFundV5Request) InstType(instType string) ApiGetPublicInsuranceFundV5Request {
	r.instType = &instType
	return r
}

// Type  &#x60;regular_update&#x60;   &#x60;liquidation_balance_deposit&#x60;  &#x60;bankruptcy_loss&#x60;  &#x60;platform_revenue&#x60;   &#x60;adl&#x60;: ADL historical data   The default is &#x60;all type&#x60;
func (r ApiGetPublicInsuranceFundV5Request) Type_(type_ string) ApiGetPublicInsuranceFundV5Request {
	r.type_ = &type_
	return r
}

// Underlying  Required for &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicInsuranceFundV5Request) Uly(uly string) ApiGetPublicInsuranceFundV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Required for &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicInsuranceFundV5Request) InstFamily(instFamily string) ApiGetPublicInsuranceFundV5Request {
	r.instFamily = &instFamily
	return r
}

// Currency, only applicable to &#x60;MARGIN&#x60;
func (r ApiGetPublicInsuranceFundV5Request) Ccy(ccy string) ApiGetPublicInsuranceFundV5Request {
	r.ccy = &ccy
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;
func (r ApiGetPublicInsuranceFundV5Request) Before(before string) ApiGetPublicInsuranceFundV5Request {
	r.before = &before
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetPublicInsuranceFundV5Request) After(after string) ApiGetPublicInsuranceFundV5Request {
	r.after = &after
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetPublicInsuranceFundV5Request) Limit(limit string) ApiGetPublicInsuranceFundV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetPublicInsuranceFundV5Request) Execute() (*GetPublicInsuranceFundV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicInsuranceFundV5Execute(r)
}

/*
GetPublicInsuranceFundV5 Get insurance fund balance information  

Get insurance fund balance information

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicInsuranceFundV5Request
*/
func (a *PublicDataAPIService) GetPublicInsuranceFundV5(ctx context.Context) ApiGetPublicInsuranceFundV5Request {
	return ApiGetPublicInsuranceFundV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicInsuranceFundV5Resp
func (a *PublicDataAPIService) GetPublicInsuranceFundV5Execute(r ApiGetPublicInsuranceFundV5Request) (*GetPublicInsuranceFundV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicInsuranceFundV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicInsuranceFundV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/insurance-fund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicInterestRateLoanQuotaV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
}

func (r ApiGetPublicInterestRateLoanQuotaV5Request) Execute() (*GetPublicInterestRateLoanQuotaV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicInterestRateLoanQuotaV5Execute(r)
}

/*
GetPublicInterestRateLoanQuotaV5 Retrieve interest rate  

Retrieve interest rate

#### Rate Limit: 2 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicInterestRateLoanQuotaV5Request
*/
func (a *PublicDataAPIService) GetPublicInterestRateLoanQuotaV5(ctx context.Context) ApiGetPublicInterestRateLoanQuotaV5Request {
	return ApiGetPublicInterestRateLoanQuotaV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicInterestRateLoanQuotaV5Resp
func (a *PublicDataAPIService) GetPublicInterestRateLoanQuotaV5Execute(r ApiGetPublicInterestRateLoanQuotaV5Request) (*GetPublicInterestRateLoanQuotaV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicInterestRateLoanQuotaV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicInterestRateLoanQuotaV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/interest-rate-loan-quota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicMarkPriceV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
}

// Instrument type  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetPublicMarkPriceV5Request) InstType(instType string) ApiGetPublicMarkPriceV5Request {
	r.instType = &instType
	return r
}

// Underlying  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetPublicMarkPriceV5Request) Uly(uly string) ApiGetPublicMarkPriceV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetPublicMarkPriceV5Request) InstFamily(instFamily string) ApiGetPublicMarkPriceV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID, e.g. &#x60;BTC-USD-SWAP&#x60;
func (r ApiGetPublicMarkPriceV5Request) InstId(instId string) ApiGetPublicMarkPriceV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetPublicMarkPriceV5Request) Execute() (*GetPublicMarkPriceV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicMarkPriceV5Execute(r)
}

/*
GetPublicMarkPriceV5 Retrieve mark price.  We set the mark price based on the SPOT index and at a reasonable basis to prevent individual users from manipulating the market and causing the contract price to fluctuate.  

Retrieve mark price.

We set the mark price based on the SPOT index and at a reasonable basis to prevent individual users from manipulating the market and causing the contract price to fluctuate.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicMarkPriceV5Request
*/
func (a *PublicDataAPIService) GetPublicMarkPriceV5(ctx context.Context) ApiGetPublicMarkPriceV5Request {
	return ApiGetPublicMarkPriceV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicMarkPriceV5Resp
func (a *PublicDataAPIService) GetPublicMarkPriceV5Execute(r ApiGetPublicMarkPriceV5Request) (*GetPublicMarkPriceV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicMarkPriceV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicMarkPriceV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/mark-price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicOpenInterestV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
}

// Instrument type  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetPublicOpenInterestV5Request) InstType(instType string) ApiGetPublicOpenInterestV5Request {
	r.instType = &instType
	return r
}

// Underlying  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;.   If instType is &#x60;OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.
func (r ApiGetPublicOpenInterestV5Request) Uly(uly string) ApiGetPublicOpenInterestV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;  If instType is &#x60;OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.
func (r ApiGetPublicOpenInterestV5Request) InstFamily(instFamily string) ApiGetPublicOpenInterestV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT-SWAP&#x60;  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetPublicOpenInterestV5Request) InstId(instId string) ApiGetPublicOpenInterestV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetPublicOpenInterestV5Request) Execute() (*GetPublicOpenInterestV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicOpenInterestV5Execute(r)
}

/*
GetPublicOpenInterestV5 Retrieve the total open interest for contracts on OKX.  

Retrieve the total open interest for contracts on OKX.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicOpenInterestV5Request
*/
func (a *PublicDataAPIService) GetPublicOpenInterestV5(ctx context.Context) ApiGetPublicOpenInterestV5Request {
	return ApiGetPublicOpenInterestV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicOpenInterestV5Resp
func (a *PublicDataAPIService) GetPublicOpenInterestV5Execute(r ApiGetPublicOpenInterestV5Request) (*GetPublicOpenInterestV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicOpenInterestV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicOpenInterestV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/open-interest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicOptSummaryV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	uly *string
	instFamily *string
	expTime *string
}

// Underlying, only applicable to &#x60;OPTION&#x60;  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicOptSummaryV5Request) Uly(uly string) ApiGetPublicOptSummaryV5Request {
	r.uly = &uly
	return r
}

// Instrument family, only applicable to &#x60;OPTION&#x60;  Either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required. If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicOptSummaryV5Request) InstFamily(instFamily string) ApiGetPublicOptSummaryV5Request {
	r.instFamily = &instFamily
	return r
}

// Contract expiry date, the format is \&quot;YYMMDD\&quot;, e.g. \&quot;200527\&quot;
func (r ApiGetPublicOptSummaryV5Request) ExpTime(expTime string) ApiGetPublicOptSummaryV5Request {
	r.expTime = &expTime
	return r
}

func (r ApiGetPublicOptSummaryV5Request) Execute() (*GetPublicOptSummaryV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicOptSummaryV5Execute(r)
}

/*
GetPublicOptSummaryV5 Retrieve option market data.  

Retrieve option market data.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP +uly 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicOptSummaryV5Request
*/
func (a *PublicDataAPIService) GetPublicOptSummaryV5(ctx context.Context) ApiGetPublicOptSummaryV5Request {
	return ApiGetPublicOptSummaryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicOptSummaryV5Resp
func (a *PublicDataAPIService) GetPublicOptSummaryV5Execute(r ApiGetPublicOptSummaryV5Request) (*GetPublicOptSummaryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicOptSummaryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicOptSummaryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/opt-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.expTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expTime", r.expTime, "form", "")
	} else {
		var defaultValue string = ""
		r.expTime = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicPositionTiersV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
	tdMode *string
	uly *string
	instFamily *string
	instId *string
	ccy *string
	tier *string
}

// Instrument type  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetPublicPositionTiersV5Request) InstType(instType string) ApiGetPublicPositionTiersV5Request {
	r.instType = &instType
	return r
}

// Trade mode  Margin mode &#x60;cross&#x60; &#x60;isolated&#x60;
func (r ApiGetPublicPositionTiersV5Request) TdMode(tdMode string) ApiGetPublicPositionTiersV5Request {
	r.tdMode = &tdMode
	return r
}

// Single underlying or multiple underlyings (no more than 3) separated with comma.  If instType is &#x60;SWAP/FUTURES/OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.  If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicPositionTiersV5Request) Uly(uly string) ApiGetPublicPositionTiersV5Request {
	r.uly = &uly
	return r
}

// Single instrument familiy or multiple instrument families (no more than 5) separated with comma.  If instType is &#x60;SWAP/FUTURES/OPTION&#x60;, either &#x60;uly&#x60; or &#x60;instFamily&#x60; is required.  If both are passed, &#x60;instFamily&#x60; will be used.
func (r ApiGetPublicPositionTiersV5Request) InstFamily(instFamily string) ApiGetPublicPositionTiersV5Request {
	r.instFamily = &instFamily
	return r
}

// Single instrument or multiple instruments (no more than 5) separated with comma.  Either instId or ccy is required, if both are passed, instId will be used, ignore when instType is one of &#x60;SWAP&#x60;,&#x60;FUTURES&#x60;,&#x60;OPTION&#x60;
func (r ApiGetPublicPositionTiersV5Request) InstId(instId string) ApiGetPublicPositionTiersV5Request {
	r.instId = &instId
	return r
}

// Margin currency  Only applicable to cross MARGIN. It will return borrowing amount for &#x60;Multi-currency margin&#x60; and &#x60;Portfolio margin&#x60; when &#x60;ccy&#x60; takes effect.
func (r ApiGetPublicPositionTiersV5Request) Ccy(ccy string) ApiGetPublicPositionTiersV5Request {
	r.ccy = &ccy
	return r
}

// Tiers
func (r ApiGetPublicPositionTiersV5Request) Tier(tier string) ApiGetPublicPositionTiersV5Request {
	r.tier = &tier
	return r
}

func (r ApiGetPublicPositionTiersV5Request) Execute() (*GetPublicPositionTiersV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicPositionTiersV5Execute(r)
}

/*
GetPublicPositionTiersV5 Retrieve position tiers information, maximum leverage depends on your borrowings and margin ratio.  

Retrieve position tiers information, maximum leverage depends on your borrowings and margin ratio.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicPositionTiersV5Request
*/
func (a *PublicDataAPIService) GetPublicPositionTiersV5(ctx context.Context) ApiGetPublicPositionTiersV5Request {
	return ApiGetPublicPositionTiersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicPositionTiersV5Resp
func (a *PublicDataAPIService) GetPublicPositionTiersV5Execute(r ApiGetPublicPositionTiersV5Request) (*GetPublicPositionTiersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicPositionTiersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicPositionTiersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/position-tiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}
	if r.tdMode == nil {
		return localVarReturnValue, nil, reportError("tdMode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tdMode", r.tdMode, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.tier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tier", r.tier, "form", "")
	} else {
		var defaultValue string = ""
		r.tier = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicPremiumHistoryV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
	after *string
	before *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USDT-SWAP&#x60;  Applicable to &#x60;SWAP&#x60;
func (r ApiGetPublicPremiumHistoryV5Request) InstId(instId string) ApiGetPublicPremiumHistoryV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested ts(not included)
func (r ApiGetPublicPremiumHistoryV5Request) After(after string) ApiGetPublicPremiumHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested ts(not included)
func (r ApiGetPublicPremiumHistoryV5Request) Before(before string) ApiGetPublicPremiumHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetPublicPremiumHistoryV5Request) Limit(limit string) ApiGetPublicPremiumHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetPublicPremiumHistoryV5Request) Execute() (*GetPublicPremiumHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicPremiumHistoryV5Execute(r)
}

/*
GetPublicPremiumHistoryV5 It will return premium data in the past 6 months.  

It will return premium data in the past 6 months.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicPremiumHistoryV5Request
*/
func (a *PublicDataAPIService) GetPublicPremiumHistoryV5(ctx context.Context) ApiGetPublicPremiumHistoryV5Request {
	return ApiGetPublicPremiumHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicPremiumHistoryV5Resp
func (a *PublicDataAPIService) GetPublicPremiumHistoryV5Execute(r ApiGetPublicPremiumHistoryV5Request) (*GetPublicPremiumHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicPremiumHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicPremiumHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/premium-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicPriceLimitV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instId *string
}

// Instrument ID, e.g. &#x60;BTC-USDT-SWAP&#x60;
func (r ApiGetPublicPriceLimitV5Request) InstId(instId string) ApiGetPublicPriceLimitV5Request {
	r.instId = &instId
	return r
}

func (r ApiGetPublicPriceLimitV5Request) Execute() (*GetPublicPriceLimitV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicPriceLimitV5Execute(r)
}

/*
GetPublicPriceLimitV5 Retrieve the highest buy limit and lowest sell limit of the instrument.  

Retrieve the highest buy limit and lowest sell limit of the instrument.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicPriceLimitV5Request
*/
func (a *PublicDataAPIService) GetPublicPriceLimitV5(ctx context.Context) ApiGetPublicPriceLimitV5Request {
	return ApiGetPublicPriceLimitV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicPriceLimitV5Resp
func (a *PublicDataAPIService) GetPublicPriceLimitV5Execute(r ApiGetPublicPriceLimitV5Request) (*GetPublicPriceLimitV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicPriceLimitV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicPriceLimitV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/price-limit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicSettlementHistoryV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instFamily *string
	after *string
	before *string
	limit *string
}

// Instrument family
func (r ApiGetPublicSettlementHistoryV5Request) InstFamily(instFamily string) ApiGetPublicSettlementHistoryV5Request {
	r.instFamily = &instFamily
	return r
}

// Pagination of data to return records earlier than (not include) the requested &#x60;ts&#x60;
func (r ApiGetPublicSettlementHistoryV5Request) After(after string) ApiGetPublicSettlementHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than (not include) the requested &#x60;ts&#x60;
func (r ApiGetPublicSettlementHistoryV5Request) Before(before string) ApiGetPublicSettlementHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;
func (r ApiGetPublicSettlementHistoryV5Request) Limit(limit string) ApiGetPublicSettlementHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetPublicSettlementHistoryV5Request) Execute() (*GetPublicSettlementHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicSettlementHistoryV5Execute(r)
}

/*
GetPublicSettlementHistoryV5 Retrieve settlement records of futures in the last 3 months.  

Retrieve settlement records of futures in the last 3 months.

#### Rate Limit: 40 requests per 2 seconds 

#### Rate limit rule: IP + (Instrument Family) 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicSettlementHistoryV5Request
*/
func (a *PublicDataAPIService) GetPublicSettlementHistoryV5(ctx context.Context) ApiGetPublicSettlementHistoryV5Request {
	return ApiGetPublicSettlementHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicSettlementHistoryV5Resp
func (a *PublicDataAPIService) GetPublicSettlementHistoryV5Execute(r ApiGetPublicSettlementHistoryV5Request) (*GetPublicSettlementHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicSettlementHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicSettlementHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/settlement-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instFamily == nil {
		return localVarReturnValue, nil, reportError("instFamily is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicTimeV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
}

func (r ApiGetPublicTimeV5Request) Execute() (*GetPublicTimeV5Resp, *http.Response, error) {
	return r.ApiService.GetPublicTimeV5Execute(r)
}

/*
GetPublicTimeV5 Retrieve API server time.  

Retrieve API server time.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicTimeV5Request
*/
func (a *PublicDataAPIService) GetPublicTimeV5(ctx context.Context) ApiGetPublicTimeV5Request {
	return ApiGetPublicTimeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPublicTimeV5Resp
func (a *PublicDataAPIService) GetPublicTimeV5Execute(r ApiGetPublicTimeV5Request) (*GetPublicTimeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPublicTimeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicTimeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicUnderlyingV5Request struct {
	ctx context.Context
	ApiService *PublicDataAPIService
	instType *string
}

// Instrument type  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetPublicUnderlyingV5Request) InstType(instType string) ApiGetPublicUnderlyingV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetPublicUnderlyingV5Request) Execute() (*http.Response, error) {
	return r.ApiService.GetPublicUnderlyingV5Execute(r)
}

/*
GetPublicUnderlyingV5 Method for GetPublicUnderlyingV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPublicUnderlyingV5Request
*/
func (a *PublicDataAPIService) GetPublicUnderlyingV5(ctx context.Context) ApiGetPublicUnderlyingV5Request {
	return ApiGetPublicUnderlyingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PublicDataAPIService) GetPublicUnderlyingV5Execute(r ApiGetPublicUnderlyingV5Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicDataAPIService.GetPublicUnderlyingV5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/public/underlying"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
