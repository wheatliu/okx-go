/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TradingStatisticsAPIService TradingStatisticsAPI service
type TradingStatisticsAPIService service

type ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	instId *string
	period *string
	end *string
	begin *string
	limit *string
}

// Instrument ID, eg: BTC-USDT-SWAP   Only applicable to &#x60;FUTURES&#x60;, &#x60;SWAP&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request) InstId(instId string) ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request {
	r.instId = &instId
	return r
}

// Bar size, the default is &#x60;5m&#x60;, e.g. [&#x60;5m/15m/30m/1H/2H/4H&#x60;]   Hong Kong time opening price k-line: [&#x60;6H/12H/1D/2D/3D/5D/1W/1M/3M&#x60;]   UTC time opening price k-line: [&#x60;6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/5Dutc/1Wutc/1Mutc/3Mutc&#x60;]
func (r ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request) Period(period string) ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request {
	r.period = &period
	return r
}

// return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request) End(end string) ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request {
	r.end = &end
	return r
}

// return records newer than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request) Begin(begin string) ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request {
	r.begin = &begin
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request) Limit(limit string) ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request) Execute() (*GetRubikStatContractsLongShortAccountRatioContractTopTraderV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatContractsLongShortAccountRatioContractTopTraderV5Execute(r)
}

/*
GetRubikStatContractsLongShortAccountRatioContractTopTraderV5 Retrieve the account net long/short ratio of a contract for top traders. Top traders refer to the top 5% of traders with the largest open position value. This endpoint can retrieve the latest 1,440 data entries. The data time range is up to March 22, 2024.  

Retrieve the account net long/short ratio of a contract for top traders. Top traders refer to the top 5% of traders with the largest open position value. This endpoint can retrieve the latest 1,440 data entries. The data time range is up to March 22, 2024.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortAccountRatioContractTopTraderV5(ctx context.Context) ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request {
	return ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatContractsLongShortAccountRatioContractTopTraderV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortAccountRatioContractTopTraderV5Execute(r ApiGetRubikStatContractsLongShortAccountRatioContractTopTraderV5Request) (*GetRubikStatContractsLongShortAccountRatioContractTopTraderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatContractsLongShortAccountRatioContractTopTraderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatContractsLongShortAccountRatioContractTopTraderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/contracts/long-short-account-ratio-contract-top-trader"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatContractsLongShortAccountRatioContractV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	instId *string
	period *string
	end *string
	begin *string
	limit *string
}

// Instrument ID, eg: BTC-USDT-SWAP   Only applicable to &#x60;FUTURES&#x60;, &#x60;SWAP&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioContractV5Request) InstId(instId string) ApiGetRubikStatContractsLongShortAccountRatioContractV5Request {
	r.instId = &instId
	return r
}

// Bar size, the default is &#x60;5m&#x60;, e.g. [&#x60;5m/15m/30m/1H/2H/4H&#x60;]   Hong Kong time opening price k-line:[&#x60;6H/12H/1D/2D/3D/5D/1W/1M/3M&#x60;]   UTC time opening price k-line: [&#x60;6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/5Dutc/1Wutc/1Mutc/3Mutc&#x60;]
func (r ApiGetRubikStatContractsLongShortAccountRatioContractV5Request) Period(period string) ApiGetRubikStatContractsLongShortAccountRatioContractV5Request {
	r.period = &period
	return r
}

// return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioContractV5Request) End(end string) ApiGetRubikStatContractsLongShortAccountRatioContractV5Request {
	r.end = &end
	return r
}

// return records newer than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioContractV5Request) Begin(begin string) ApiGetRubikStatContractsLongShortAccountRatioContractV5Request {
	r.begin = &begin
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetRubikStatContractsLongShortAccountRatioContractV5Request) Limit(limit string) ApiGetRubikStatContractsLongShortAccountRatioContractV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetRubikStatContractsLongShortAccountRatioContractV5Request) Execute() (*GetRubikStatContractsLongShortAccountRatioContractV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatContractsLongShortAccountRatioContractV5Execute(r)
}

/*
GetRubikStatContractsLongShortAccountRatioContractV5 Retrieve the account long/short ratio of a contract. This endpoint can retrieve the latest 1,440 data entries.     For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.  

Retrieve the account long/short ratio of a contract. This endpoint can retrieve the latest 1,440 data entries. 



For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatContractsLongShortAccountRatioContractV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortAccountRatioContractV5(ctx context.Context) ApiGetRubikStatContractsLongShortAccountRatioContractV5Request {
	return ApiGetRubikStatContractsLongShortAccountRatioContractV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatContractsLongShortAccountRatioContractV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortAccountRatioContractV5Execute(r ApiGetRubikStatContractsLongShortAccountRatioContractV5Request) (*GetRubikStatContractsLongShortAccountRatioContractV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatContractsLongShortAccountRatioContractV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatContractsLongShortAccountRatioContractV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/contracts/long-short-account-ratio-contract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatContractsLongShortAccountRatioV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	begin *string
	end *string
	period *string
}

// Currency
func (r ApiGetRubikStatContractsLongShortAccountRatioV5Request) Ccy(ccy string) ApiGetRubikStatContractsLongShortAccountRatioV5Request {
	r.ccy = &ccy
	return r
}

// Begin time, e.g. &#x60;1597026383085&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioV5Request) Begin(begin string) ApiGetRubikStatContractsLongShortAccountRatioV5Request {
	r.begin = &begin
	return r
}

// End time, e.g. &#x60;1597026383011&#x60;
func (r ApiGetRubikStatContractsLongShortAccountRatioV5Request) End(end string) ApiGetRubikStatContractsLongShortAccountRatioV5Request {
	r.end = &end
	return r
}

// Period, the default is &#x60;5m&#x60;, e.g. [&#x60;5m/1H/1D&#x60;]    &#x60;5m&#x60; granularity can only query data within two days at most  &#x60;1H&#x60; granularity can only query data within 30 days at most   &#x60;1D&#x60; granularity can only query data within 180 days at most
func (r ApiGetRubikStatContractsLongShortAccountRatioV5Request) Period(period string) ApiGetRubikStatContractsLongShortAccountRatioV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatContractsLongShortAccountRatioV5Request) Execute() (*GetRubikStatContractsLongShortAccountRatioV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatContractsLongShortAccountRatioV5Execute(r)
}

/*
GetRubikStatContractsLongShortAccountRatioV5 Retrieve the ratio of users with net long vs net short positions for Expiry Futures and Perpetual Futures.  

Retrieve the ratio of users with net long vs net short positions for Expiry Futures and Perpetual Futures.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatContractsLongShortAccountRatioV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortAccountRatioV5(ctx context.Context) ApiGetRubikStatContractsLongShortAccountRatioV5Request {
	return ApiGetRubikStatContractsLongShortAccountRatioV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatContractsLongShortAccountRatioV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortAccountRatioV5Execute(r ApiGetRubikStatContractsLongShortAccountRatioV5Request) (*GetRubikStatContractsLongShortAccountRatioV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatContractsLongShortAccountRatioV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatContractsLongShortAccountRatioV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/contracts/long-short-account-ratio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	instId *string
	period *string
	end *string
	begin *string
	limit *string
}

// Instrument ID, e.g. &#x60;BTC-USDT-SWAP&#x60;   Only applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;
func (r ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request) InstId(instId string) ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request {
	r.instId = &instId
	return r
}

// Bar size, the default is &#x60;5m&#x60;, e.g. [&#x60;5m/15m/30m/1H/2H/4H&#x60;]   Hong Kong time opening price k-line: [&#x60;6H/12H/1D/2D/3D/5D/1W/1M/3M&#x60;]   UTC time opening price k-line: [&#x60;6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/5Dutc/1Wutc/1Mutc/3Mutc&#x60;]
func (r ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request) Period(period string) ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request {
	r.period = &period
	return r
}

// return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request) End(end string) ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request {
	r.end = &end
	return r
}

// return records newer than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request) Begin(begin string) ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request {
	r.begin = &begin
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request) Limit(limit string) ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request) Execute() (*GetRubikStatContractsLongShortPositionRatioContractTopTraderV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatContractsLongShortPositionRatioContractTopTraderV5Execute(r)
}

/*
GetRubikStatContractsLongShortPositionRatioContractTopTraderV5 Retrieve the position long/short ratio of a contract for top traders. Top traders refer to the top 5% of traders with the largest open position value. This endpoint can retrieve the latest 1,440 data entries. The data time range is up to March 22, 2024.  

Retrieve the position long/short ratio of a contract for top traders. Top traders refer to the top 5% of traders with the largest open position value. This endpoint can retrieve the latest 1,440 data entries. The data time range is up to March 22, 2024.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortPositionRatioContractTopTraderV5(ctx context.Context) ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request {
	return ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatContractsLongShortPositionRatioContractTopTraderV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatContractsLongShortPositionRatioContractTopTraderV5Execute(r ApiGetRubikStatContractsLongShortPositionRatioContractTopTraderV5Request) (*GetRubikStatContractsLongShortPositionRatioContractTopTraderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatContractsLongShortPositionRatioContractTopTraderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatContractsLongShortPositionRatioContractTopTraderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/contracts/long-short-position-ratio-contract-top-trader"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatContractsOpenInterestHistoryV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	instId *string
	period *string
	end *string
	begin *string
	limit *string
}

// Instrument ID, eg: BTC-USDT-SWAP   Only applicable to &#x60;FUTURES&#x60;, &#x60;SWAP&#x60;
func (r ApiGetRubikStatContractsOpenInterestHistoryV5Request) InstId(instId string) ApiGetRubikStatContractsOpenInterestHistoryV5Request {
	r.instId = &instId
	return r
}

// Bar size, the default is &#x60;5m&#x60;, e.g. [&#x60;5m/15m/30m/1H/2H/4H&#x60;]   Hong Kong time opening price k-line: [&#x60;6H/12H/1D/2D/3D/5D/1W/1M/3M&#x60;]   UTC time opening price k-line: [&#x60;6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/5Dutc/1Wutc/1Mutc/3Mutc&#x60;]
func (r ApiGetRubikStatContractsOpenInterestHistoryV5Request) Period(period string) ApiGetRubikStatContractsOpenInterestHistoryV5Request {
	r.period = &period
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsOpenInterestHistoryV5Request) End(end string) ApiGetRubikStatContractsOpenInterestHistoryV5Request {
	r.end = &end
	return r
}

// return records newer than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatContractsOpenInterestHistoryV5Request) Begin(begin string) ApiGetRubikStatContractsOpenInterestHistoryV5Request {
	r.begin = &begin
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetRubikStatContractsOpenInterestHistoryV5Request) Limit(limit string) ApiGetRubikStatContractsOpenInterestHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetRubikStatContractsOpenInterestHistoryV5Request) Execute() (*GetRubikStatContractsOpenInterestHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatContractsOpenInterestHistoryV5Execute(r)
}

/*
GetRubikStatContractsOpenInterestHistoryV5 Retrieve the contract open interest statistics of futures and perp. This endpoint can retrieve the latest 1,440 data entries.     For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.  

Retrieve the contract open interest statistics of futures and perp. This endpoint can retrieve the latest 1,440 data entries. 



For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.

#### Rate limit: 10 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatContractsOpenInterestHistoryV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatContractsOpenInterestHistoryV5(ctx context.Context) ApiGetRubikStatContractsOpenInterestHistoryV5Request {
	return ApiGetRubikStatContractsOpenInterestHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatContractsOpenInterestHistoryV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatContractsOpenInterestHistoryV5Execute(r ApiGetRubikStatContractsOpenInterestHistoryV5Request) (*GetRubikStatContractsOpenInterestHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatContractsOpenInterestHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatContractsOpenInterestHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/contracts/open-interest-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatContractsOpenInterestVolumeV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	begin *string
	end *string
	period *string
}

// Currency
func (r ApiGetRubikStatContractsOpenInterestVolumeV5Request) Ccy(ccy string) ApiGetRubikStatContractsOpenInterestVolumeV5Request {
	r.ccy = &ccy
	return r
}

// Begin time, e.g. &#x60;1597026383085&#x60;
func (r ApiGetRubikStatContractsOpenInterestVolumeV5Request) Begin(begin string) ApiGetRubikStatContractsOpenInterestVolumeV5Request {
	r.begin = &begin
	return r
}

// End time, e.g. &#x60;1597026383011&#x60;
func (r ApiGetRubikStatContractsOpenInterestVolumeV5Request) End(end string) ApiGetRubikStatContractsOpenInterestVolumeV5Request {
	r.end = &end
	return r
}

// Period, the default is &#x60;5m&#x60;, e.g. [&#x60;5m/1H/1D&#x60;]    &#x60;5m&#x60; granularity can only query data within two days at most  &#x60;1H&#x60; granularity can only query data within 30 days at most   &#x60;1D&#x60; granularity can only query data within 180 days at most
func (r ApiGetRubikStatContractsOpenInterestVolumeV5Request) Period(period string) ApiGetRubikStatContractsOpenInterestVolumeV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatContractsOpenInterestVolumeV5Request) Execute() (*GetRubikStatContractsOpenInterestVolumeV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatContractsOpenInterestVolumeV5Execute(r)
}

/*
GetRubikStatContractsOpenInterestVolumeV5 Retrieve the open interest and trading volume for Expiry Futures and Perpetual Futures.  

Retrieve the open interest and trading volume for Expiry Futures and Perpetual Futures.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatContractsOpenInterestVolumeV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatContractsOpenInterestVolumeV5(ctx context.Context) ApiGetRubikStatContractsOpenInterestVolumeV5Request {
	return ApiGetRubikStatContractsOpenInterestVolumeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatContractsOpenInterestVolumeV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatContractsOpenInterestVolumeV5Execute(r ApiGetRubikStatContractsOpenInterestVolumeV5Request) (*GetRubikStatContractsOpenInterestVolumeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatContractsOpenInterestVolumeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatContractsOpenInterestVolumeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/contracts/open-interest-volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatMarginLoanRatioV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	begin *string
	end *string
	period *string
}

// Currency
func (r ApiGetRubikStatMarginLoanRatioV5Request) Ccy(ccy string) ApiGetRubikStatMarginLoanRatioV5Request {
	r.ccy = &ccy
	return r
}

// Begin time, e.g. &#x60;1597026383085&#x60;
func (r ApiGetRubikStatMarginLoanRatioV5Request) Begin(begin string) ApiGetRubikStatMarginLoanRatioV5Request {
	r.begin = &begin
	return r
}

// End time, e.g. &#x60;1597026383085&#x60;
func (r ApiGetRubikStatMarginLoanRatioV5Request) End(end string) ApiGetRubikStatMarginLoanRatioV5Request {
	r.end = &end
	return r
}

// Period  &#x60;m&#x60;: Minute, &#x60;H&#x60;: Hour, &#x60;D&#x60;: Day  the default is &#x60;5m&#x60;, e.g. [&#x60;5m&#x60;/&#x60;1H&#x60;/&#x60;1D&#x60;]    &#x60;5m&#x60; granularity can only query data within two days at most  &#x60;1H&#x60; granularity can only query data within 30 days at most  &#x60;1D&#x60; granularity can only query data within 180 days at most
func (r ApiGetRubikStatMarginLoanRatioV5Request) Period(period string) ApiGetRubikStatMarginLoanRatioV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatMarginLoanRatioV5Request) Execute() (*GetRubikStatMarginLoanRatioV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatMarginLoanRatioV5Execute(r)
}

/*
GetRubikStatMarginLoanRatioV5 Retrieve the ratio of cumulative amount of quote currency to base currency.  

Retrieve the ratio of cumulative amount of quote currency to base currency.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatMarginLoanRatioV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatMarginLoanRatioV5(ctx context.Context) ApiGetRubikStatMarginLoanRatioV5Request {
	return ApiGetRubikStatMarginLoanRatioV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatMarginLoanRatioV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatMarginLoanRatioV5Execute(r ApiGetRubikStatMarginLoanRatioV5Request) (*GetRubikStatMarginLoanRatioV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatMarginLoanRatioV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatMarginLoanRatioV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/margin/loan-ratio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	period *string
}

// Currency
func (r ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request) Ccy(ccy string) ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request {
	r.ccy = &ccy
	return r
}

// Period, the default is &#x60;8H&#x60;. e.g. [&#x60;8H/1D&#x60;]    Each granularity can provide only one latest piece of data
func (r ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request) Period(period string) ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request) Execute() (*GetRubikStatOptionOpenInterestVolumeExpiryV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatOptionOpenInterestVolumeExpiryV5Execute(r)
}

/*
GetRubikStatOptionOpenInterestVolumeExpiryV5 Retrieve the open interest and trading volume of calls and puts for each upcoming expiration.  

Retrieve the open interest and trading volume of calls and puts for each upcoming expiration.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeExpiryV5(ctx context.Context) ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request {
	return ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatOptionOpenInterestVolumeExpiryV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeExpiryV5Execute(r ApiGetRubikStatOptionOpenInterestVolumeExpiryV5Request) (*GetRubikStatOptionOpenInterestVolumeExpiryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatOptionOpenInterestVolumeExpiryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatOptionOpenInterestVolumeExpiryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/option/open-interest-volume-expiry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	period *string
}

// Currency
func (r ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request) Ccy(ccy string) ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request {
	r.ccy = &ccy
	return r
}

// Period, the default is &#x60;8H&#x60;. e.g. [&#x60;8H/1D&#x60;]    Each granularity can only query 72 pieces of data at the earliest
func (r ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request) Period(period string) ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request) Execute() (*GetRubikStatOptionOpenInterestVolumeRatioV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatOptionOpenInterestVolumeRatioV5Execute(r)
}

/*
GetRubikStatOptionOpenInterestVolumeRatioV5 Retrieve the open interest ratio and trading volume ratio of calls vs puts.  

Retrieve the open interest ratio and trading volume ratio of calls vs puts.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeRatioV5(ctx context.Context) ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request {
	return ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatOptionOpenInterestVolumeRatioV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeRatioV5Execute(r ApiGetRubikStatOptionOpenInterestVolumeRatioV5Request) (*GetRubikStatOptionOpenInterestVolumeRatioV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatOptionOpenInterestVolumeRatioV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatOptionOpenInterestVolumeRatioV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/option/open-interest-volume-ratio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	expTime *string
	period *string
}

// Currency
func (r ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request) Ccy(ccy string) ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request {
	r.ccy = &ccy
	return r
}

// Contract expiry date, the format is &#x60;YYYYMMdd&#x60;, e.g. &#x60;20210623&#x60;
func (r ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request) ExpTime(expTime string) ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request {
	r.expTime = &expTime
	return r
}

// Period, the default is &#x60;8H&#x60;. e.g. [&#x60;8H/1D&#x60;]    Each granularity can provide only one latest piece of data
func (r ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request) Period(period string) ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request) Execute() (*GetRubikStatOptionOpenInterestVolumeStrikeV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatOptionOpenInterestVolumeStrikeV5Execute(r)
}

/*
GetRubikStatOptionOpenInterestVolumeStrikeV5 Retrieve the taker volume for both buyers and sellers of calls and puts.  

Retrieve the taker volume for both buyers and sellers of calls and puts.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeStrikeV5(ctx context.Context) ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request {
	return ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatOptionOpenInterestVolumeStrikeV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeStrikeV5Execute(r ApiGetRubikStatOptionOpenInterestVolumeStrikeV5Request) (*GetRubikStatOptionOpenInterestVolumeStrikeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatOptionOpenInterestVolumeStrikeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatOptionOpenInterestVolumeStrikeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/option/open-interest-volume-strike"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}
	if r.expTime == nil {
		return localVarReturnValue, nil, reportError("expTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "expTime", r.expTime, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatOptionOpenInterestVolumeV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	period *string
}

// Currency
func (r ApiGetRubikStatOptionOpenInterestVolumeV5Request) Ccy(ccy string) ApiGetRubikStatOptionOpenInterestVolumeV5Request {
	r.ccy = &ccy
	return r
}

// Period, the default is &#x60;8H&#x60;. e.g. [&#x60;8H/1D&#x60;]    Each granularity can only query 72 pieces of data at the earliest
func (r ApiGetRubikStatOptionOpenInterestVolumeV5Request) Period(period string) ApiGetRubikStatOptionOpenInterestVolumeV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatOptionOpenInterestVolumeV5Request) Execute() (*GetRubikStatOptionOpenInterestVolumeV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatOptionOpenInterestVolumeV5Execute(r)
}

/*
GetRubikStatOptionOpenInterestVolumeV5 Retrieve the open interest and trading volume for options.  

Retrieve the open interest and trading volume for options.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatOptionOpenInterestVolumeV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeV5(ctx context.Context) ApiGetRubikStatOptionOpenInterestVolumeV5Request {
	return ApiGetRubikStatOptionOpenInterestVolumeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatOptionOpenInterestVolumeV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatOptionOpenInterestVolumeV5Execute(r ApiGetRubikStatOptionOpenInterestVolumeV5Request) (*GetRubikStatOptionOpenInterestVolumeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatOptionOpenInterestVolumeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatOptionOpenInterestVolumeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/option/open-interest-volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatOptionTakerBlockVolumeV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	period *string
}

// currency
func (r ApiGetRubikStatOptionTakerBlockVolumeV5Request) Ccy(ccy string) ApiGetRubikStatOptionTakerBlockVolumeV5Request {
	r.ccy = &ccy
	return r
}

// period, the default is &#x60;8H&#x60;. e.g. [&#x60;8H/1D&#x60;]    Each granularity can provide only one latest piece of data
func (r ApiGetRubikStatOptionTakerBlockVolumeV5Request) Period(period string) ApiGetRubikStatOptionTakerBlockVolumeV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatOptionTakerBlockVolumeV5Request) Execute() (*GetRubikStatOptionTakerBlockVolumeV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatOptionTakerBlockVolumeV5Execute(r)
}

/*
GetRubikStatOptionTakerBlockVolumeV5 This shows the relative buy/sell volume for calls and puts. It shows whether traders are bullish or bearish on price and volatility.  

This shows the relative buy/sell volume for calls and puts. It shows whether traders are bullish or bearish on price and volatility.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatOptionTakerBlockVolumeV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatOptionTakerBlockVolumeV5(ctx context.Context) ApiGetRubikStatOptionTakerBlockVolumeV5Request {
	return ApiGetRubikStatOptionTakerBlockVolumeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatOptionTakerBlockVolumeV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatOptionTakerBlockVolumeV5Execute(r ApiGetRubikStatOptionTakerBlockVolumeV5Request) (*GetRubikStatOptionTakerBlockVolumeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatOptionTakerBlockVolumeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatOptionTakerBlockVolumeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/option/taker-block-volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatTakerVolumeContractV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	instId *string
	period *string
	unit *string
	end *string
	begin *string
	limit *string
}

// Instrument ID, eg: BTC-USDT-SWAP   Only applicable to &#x60;FUTURES&#x60;, &#x60;SWAP&#x60;
func (r ApiGetRubikStatTakerVolumeContractV5Request) InstId(instId string) ApiGetRubikStatTakerVolumeContractV5Request {
	r.instId = &instId
	return r
}

// Bar size, the default is &#x60;5m&#x60;, e.g. [&#x60;5m/15m/30m/1H/2H/4H&#x60;]   Hong Kong time opening price k-line:[&#x60;6H/12H/1D/2D/3D/5D/1W/1M/3M&#x60;]   UTC time opening price k-line: [&#x60;6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/5Dutc/1Wutc/1Mutc/3Mutc&#x60;]
func (r ApiGetRubikStatTakerVolumeContractV5Request) Period(period string) ApiGetRubikStatTakerVolumeContractV5Request {
	r.period = &period
	return r
}

// The unit of buy/sell volume, the default is &#x60;1&#x60;   &#x60;0&#x60;: Crypto   &#x60;1&#x60;: Contracts   &#x60;2&#x60;: U
func (r ApiGetRubikStatTakerVolumeContractV5Request) Unit(unit string) ApiGetRubikStatTakerVolumeContractV5Request {
	r.unit = &unit
	return r
}

// return records earlier than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatTakerVolumeContractV5Request) End(end string) ApiGetRubikStatTakerVolumeContractV5Request {
	r.end = &end
	return r
}

// return records newer than the requested &#x60;ts&#x60;
func (r ApiGetRubikStatTakerVolumeContractV5Request) Begin(begin string) ApiGetRubikStatTakerVolumeContractV5Request {
	r.begin = &begin
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetRubikStatTakerVolumeContractV5Request) Limit(limit string) ApiGetRubikStatTakerVolumeContractV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetRubikStatTakerVolumeContractV5Request) Execute() (*GetRubikStatTakerVolumeContractV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatTakerVolumeContractV5Execute(r)
}

/*
GetRubikStatTakerVolumeContractV5 Retrieve the contract taker volume for both buyers and sellers. This endpoint can retrieve the latest 1,440 data entries.     For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.  

Retrieve the contract taker volume for both buyers and sellers. This endpoint can retrieve the latest 1,440 data entries. 



For period=1D, the data time range is up to January 1, 2024; for other periods, the data time range is up to early February 2024.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP + Instrument ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatTakerVolumeContractV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatTakerVolumeContractV5(ctx context.Context) ApiGetRubikStatTakerVolumeContractV5Request {
	return ApiGetRubikStatTakerVolumeContractV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatTakerVolumeContractV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatTakerVolumeContractV5Execute(r ApiGetRubikStatTakerVolumeContractV5Request) (*GetRubikStatTakerVolumeContractV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatTakerVolumeContractV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatTakerVolumeContractV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/taker-volume-contract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	if r.unit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit", r.unit, "form", "")
	} else {
		var defaultValue string = ""
		r.unit = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatTakerVolumeV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
	ccy *string
	instType *string
	begin *string
	end *string
	period *string
}

// Currency
func (r ApiGetRubikStatTakerVolumeV5Request) Ccy(ccy string) ApiGetRubikStatTakerVolumeV5Request {
	r.ccy = &ccy
	return r
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;CONTRACTS&#x60;
func (r ApiGetRubikStatTakerVolumeV5Request) InstType(instType string) ApiGetRubikStatTakerVolumeV5Request {
	r.instType = &instType
	return r
}

// Begin time, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetRubikStatTakerVolumeV5Request) Begin(begin string) ApiGetRubikStatTakerVolumeV5Request {
	r.begin = &begin
	return r
}

// End time, Unix timestamp format in milliseconds, e.g. &#x60;1597026383011&#x60;
func (r ApiGetRubikStatTakerVolumeV5Request) End(end string) ApiGetRubikStatTakerVolumeV5Request {
	r.end = &end
	return r
}

// Period, the default is &#x60;5m&#x60;, e.g. [&#x60;5m&#x60;/&#x60;1H&#x60;/&#x60;1D&#x60;]    &#x60;5m&#x60; granularity can only query data within two days at most  &#x60;1H&#x60; granularity can only query data within 30 days at most   &#x60;1D&#x60; granularity can only query data within 180 days at most
func (r ApiGetRubikStatTakerVolumeV5Request) Period(period string) ApiGetRubikStatTakerVolumeV5Request {
	r.period = &period
	return r
}

func (r ApiGetRubikStatTakerVolumeV5Request) Execute() (*GetRubikStatTakerVolumeV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatTakerVolumeV5Execute(r)
}

/*
GetRubikStatTakerVolumeV5 Retrieve the taker volume for both buyers and sellers.  

Retrieve the taker volume for both buyers and sellers.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatTakerVolumeV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatTakerVolumeV5(ctx context.Context) ApiGetRubikStatTakerVolumeV5Request {
	return ApiGetRubikStatTakerVolumeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatTakerVolumeV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatTakerVolumeV5Execute(r ApiGetRubikStatTakerVolumeV5Request) (*GetRubikStatTakerVolumeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatTakerVolumeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatTakerVolumeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/taker-volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	} else {
		var defaultValue string = ""
		r.period = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubikStatTradingDataSupportCoinV5Request struct {
	ctx context.Context
	ApiService *TradingStatisticsAPIService
}

func (r ApiGetRubikStatTradingDataSupportCoinV5Request) Execute() (*GetRubikStatTradingDataSupportCoinV5Resp, *http.Response, error) {
	return r.ApiService.GetRubikStatTradingDataSupportCoinV5Execute(r)
}

/*
GetRubikStatTradingDataSupportCoinV5 Retrieve the currencies supported by the trading statistics endpoints.  

Retrieve the currencies supported by the trading statistics endpoints.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRubikStatTradingDataSupportCoinV5Request
*/
func (a *TradingStatisticsAPIService) GetRubikStatTradingDataSupportCoinV5(ctx context.Context) ApiGetRubikStatTradingDataSupportCoinV5Request {
	return ApiGetRubikStatTradingDataSupportCoinV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRubikStatTradingDataSupportCoinV5Resp
func (a *TradingStatisticsAPIService) GetRubikStatTradingDataSupportCoinV5Execute(r ApiGetRubikStatTradingDataSupportCoinV5Request) (*GetRubikStatTradingDataSupportCoinV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRubikStatTradingDataSupportCoinV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingStatisticsAPIService.GetRubikStatTradingDataSupportCoinV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/rubik/stat/trading-data/support-coin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
