/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SignalBotTradingAPIService SignalBotTradingAPI service
type SignalBotTradingAPIService service

type ApiCreateTradingBotSignalAmendTPSLV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalAmendTPSLV5Req *CreateTradingBotSignalAmendTPSLV5Req
}

// The request body for CreateTradingBotSignalAmendTPSLV5
func (r ApiCreateTradingBotSignalAmendTPSLV5Request) CreateTradingBotSignalAmendTPSLV5Req(createTradingBotSignalAmendTPSLV5Req CreateTradingBotSignalAmendTPSLV5Req) ApiCreateTradingBotSignalAmendTPSLV5Request {
	r.createTradingBotSignalAmendTPSLV5Req = &createTradingBotSignalAmendTPSLV5Req
	return r
}

func (r ApiCreateTradingBotSignalAmendTPSLV5Request) Execute() (*CreateTradingBotSignalAmendTPSLV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalAmendTPSLV5Execute(r)
}

/*
CreateTradingBotSignalAmendTPSLV5 Method for CreateTradingBotSignalAmendTPSLV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalAmendTPSLV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalAmendTPSLV5(ctx context.Context) ApiCreateTradingBotSignalAmendTPSLV5Request {
	return ApiCreateTradingBotSignalAmendTPSLV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalAmendTPSLV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalAmendTPSLV5Execute(r ApiCreateTradingBotSignalAmendTPSLV5Request) (*CreateTradingBotSignalAmendTPSLV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalAmendTPSLV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalAmendTPSLV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/amendTPSL"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalAmendTPSLV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalAmendTPSLV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalAmendTPSLV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalCancelSubOrderV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalCancelSubOrderV5Req *CreateTradingBotSignalCancelSubOrderV5Req
}

// The request body for CreateTradingBotSignalCancelSubOrderV5
func (r ApiCreateTradingBotSignalCancelSubOrderV5Request) CreateTradingBotSignalCancelSubOrderV5Req(createTradingBotSignalCancelSubOrderV5Req CreateTradingBotSignalCancelSubOrderV5Req) ApiCreateTradingBotSignalCancelSubOrderV5Request {
	r.createTradingBotSignalCancelSubOrderV5Req = &createTradingBotSignalCancelSubOrderV5Req
	return r
}

func (r ApiCreateTradingBotSignalCancelSubOrderV5Request) Execute() (*CreateTradingBotSignalCancelSubOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalCancelSubOrderV5Execute(r)
}

/*
CreateTradingBotSignalCancelSubOrderV5 Cancel an incomplete order.  

Cancel an incomplete order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalCancelSubOrderV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalCancelSubOrderV5(ctx context.Context) ApiCreateTradingBotSignalCancelSubOrderV5Request {
	return ApiCreateTradingBotSignalCancelSubOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalCancelSubOrderV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalCancelSubOrderV5Execute(r ApiCreateTradingBotSignalCancelSubOrderV5Request) (*CreateTradingBotSignalCancelSubOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalCancelSubOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalCancelSubOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/cancel-sub-order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalCancelSubOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalCancelSubOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalCancelSubOrderV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalClosePositionV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalClosePositionV5Req *CreateTradingBotSignalClosePositionV5Req
}

// The request body for CreateTradingBotSignalClosePositionV5
func (r ApiCreateTradingBotSignalClosePositionV5Request) CreateTradingBotSignalClosePositionV5Req(createTradingBotSignalClosePositionV5Req CreateTradingBotSignalClosePositionV5Req) ApiCreateTradingBotSignalClosePositionV5Request {
	r.createTradingBotSignalClosePositionV5Req = &createTradingBotSignalClosePositionV5Req
	return r
}

func (r ApiCreateTradingBotSignalClosePositionV5Request) Execute() (*CreateTradingBotSignalClosePositionV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalClosePositionV5Execute(r)
}

/*
CreateTradingBotSignalClosePositionV5 Close the position of an instrument via a market order.  

Close the position of an instrument via a market order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalClosePositionV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalClosePositionV5(ctx context.Context) ApiCreateTradingBotSignalClosePositionV5Request {
	return ApiCreateTradingBotSignalClosePositionV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalClosePositionV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalClosePositionV5Execute(r ApiCreateTradingBotSignalClosePositionV5Request) (*CreateTradingBotSignalClosePositionV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalClosePositionV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalClosePositionV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/close-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalClosePositionV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalClosePositionV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalClosePositionV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalCreateSignalV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalCreateSignalV5Req *CreateTradingBotSignalCreateSignalV5Req
}

// The request body for CreateTradingBotSignalCreateSignalV5
func (r ApiCreateTradingBotSignalCreateSignalV5Request) CreateTradingBotSignalCreateSignalV5Req(createTradingBotSignalCreateSignalV5Req CreateTradingBotSignalCreateSignalV5Req) ApiCreateTradingBotSignalCreateSignalV5Request {
	r.createTradingBotSignalCreateSignalV5Req = &createTradingBotSignalCreateSignalV5Req
	return r
}

func (r ApiCreateTradingBotSignalCreateSignalV5Request) Execute() (*CreateTradingBotSignalCreateSignalV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalCreateSignalV5Execute(r)
}

/*
CreateTradingBotSignalCreateSignalV5 Method for CreateTradingBotSignalCreateSignalV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalCreateSignalV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalCreateSignalV5(ctx context.Context) ApiCreateTradingBotSignalCreateSignalV5Request {
	return ApiCreateTradingBotSignalCreateSignalV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalCreateSignalV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalCreateSignalV5Execute(r ApiCreateTradingBotSignalCreateSignalV5Request) (*CreateTradingBotSignalCreateSignalV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalCreateSignalV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalCreateSignalV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/create-signal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalCreateSignalV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalCreateSignalV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalCreateSignalV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalMarginBalanceV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalMarginBalanceV5Req *CreateTradingBotSignalMarginBalanceV5Req
}

// The request body for CreateTradingBotSignalMarginBalanceV5
func (r ApiCreateTradingBotSignalMarginBalanceV5Request) CreateTradingBotSignalMarginBalanceV5Req(createTradingBotSignalMarginBalanceV5Req CreateTradingBotSignalMarginBalanceV5Req) ApiCreateTradingBotSignalMarginBalanceV5Request {
	r.createTradingBotSignalMarginBalanceV5Req = &createTradingBotSignalMarginBalanceV5Req
	return r
}

func (r ApiCreateTradingBotSignalMarginBalanceV5Request) Execute() (*CreateTradingBotSignalMarginBalanceV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalMarginBalanceV5Execute(r)
}

/*
CreateTradingBotSignalMarginBalanceV5 Method for CreateTradingBotSignalMarginBalanceV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalMarginBalanceV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalMarginBalanceV5(ctx context.Context) ApiCreateTradingBotSignalMarginBalanceV5Request {
	return ApiCreateTradingBotSignalMarginBalanceV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalMarginBalanceV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalMarginBalanceV5Execute(r ApiCreateTradingBotSignalMarginBalanceV5Request) (*CreateTradingBotSignalMarginBalanceV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalMarginBalanceV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalMarginBalanceV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/margin-balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalMarginBalanceV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalMarginBalanceV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalMarginBalanceV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalOrderAlgoV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalOrderAlgoV5Req *CreateTradingBotSignalOrderAlgoV5Req
}

// The request body for CreateTradingBotSignalOrderAlgoV5
func (r ApiCreateTradingBotSignalOrderAlgoV5Request) CreateTradingBotSignalOrderAlgoV5Req(createTradingBotSignalOrderAlgoV5Req CreateTradingBotSignalOrderAlgoV5Req) ApiCreateTradingBotSignalOrderAlgoV5Request {
	r.createTradingBotSignalOrderAlgoV5Req = &createTradingBotSignalOrderAlgoV5Req
	return r
}

func (r ApiCreateTradingBotSignalOrderAlgoV5Request) Execute() (*CreateTradingBotSignalOrderAlgoV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalOrderAlgoV5Execute(r)
}

/*
CreateTradingBotSignalOrderAlgoV5 Method for CreateTradingBotSignalOrderAlgoV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalOrderAlgoV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalOrderAlgoV5(ctx context.Context) ApiCreateTradingBotSignalOrderAlgoV5Request {
	return ApiCreateTradingBotSignalOrderAlgoV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalOrderAlgoV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalOrderAlgoV5Execute(r ApiCreateTradingBotSignalOrderAlgoV5Request) (*CreateTradingBotSignalOrderAlgoV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalOrderAlgoV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalOrderAlgoV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/order-algo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalOrderAlgoV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalOrderAlgoV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalOrderAlgoV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalSetInstrumentsV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalSetInstrumentsV5Req *CreateTradingBotSignalSetInstrumentsV5Req
}

// The request body for CreateTradingBotSignalSetInstrumentsV5
func (r ApiCreateTradingBotSignalSetInstrumentsV5Request) CreateTradingBotSignalSetInstrumentsV5Req(createTradingBotSignalSetInstrumentsV5Req CreateTradingBotSignalSetInstrumentsV5Req) ApiCreateTradingBotSignalSetInstrumentsV5Request {
	r.createTradingBotSignalSetInstrumentsV5Req = &createTradingBotSignalSetInstrumentsV5Req
	return r
}

func (r ApiCreateTradingBotSignalSetInstrumentsV5Request) Execute() (*CreateTradingBotSignalSetInstrumentsV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalSetInstrumentsV5Execute(r)
}

/*
CreateTradingBotSignalSetInstrumentsV5 Method for CreateTradingBotSignalSetInstrumentsV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalSetInstrumentsV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalSetInstrumentsV5(ctx context.Context) ApiCreateTradingBotSignalSetInstrumentsV5Request {
	return ApiCreateTradingBotSignalSetInstrumentsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalSetInstrumentsV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalSetInstrumentsV5Execute(r ApiCreateTradingBotSignalSetInstrumentsV5Request) (*CreateTradingBotSignalSetInstrumentsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalSetInstrumentsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalSetInstrumentsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/set-instruments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalSetInstrumentsV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalSetInstrumentsV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalSetInstrumentsV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalStopOrderAlgoV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalStopOrderAlgoV5Req *CreateTradingBotSignalStopOrderAlgoV5Req
}

// The request body for CreateTradingBotSignalStopOrderAlgoV5
func (r ApiCreateTradingBotSignalStopOrderAlgoV5Request) CreateTradingBotSignalStopOrderAlgoV5Req(createTradingBotSignalStopOrderAlgoV5Req CreateTradingBotSignalStopOrderAlgoV5Req) ApiCreateTradingBotSignalStopOrderAlgoV5Request {
	r.createTradingBotSignalStopOrderAlgoV5Req = &createTradingBotSignalStopOrderAlgoV5Req
	return r
}

func (r ApiCreateTradingBotSignalStopOrderAlgoV5Request) Execute() (*CreateTradingBotSignalStopOrderAlgoV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalStopOrderAlgoV5Execute(r)
}

/*
CreateTradingBotSignalStopOrderAlgoV5 A maximum of 10 orders can be stopped per request.  

A maximum of 10 orders can be stopped per request.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalStopOrderAlgoV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalStopOrderAlgoV5(ctx context.Context) ApiCreateTradingBotSignalStopOrderAlgoV5Request {
	return ApiCreateTradingBotSignalStopOrderAlgoV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalStopOrderAlgoV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalStopOrderAlgoV5Execute(r ApiCreateTradingBotSignalStopOrderAlgoV5Request) (*CreateTradingBotSignalStopOrderAlgoV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalStopOrderAlgoV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalStopOrderAlgoV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/stop-order-algo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalStopOrderAlgoV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalStopOrderAlgoV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalStopOrderAlgoV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradingBotSignalSubOrderV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	createTradingBotSignalSubOrderV5Req *CreateTradingBotSignalSubOrderV5Req
}

// The request body for CreateTradingBotSignalSubOrderV5
func (r ApiCreateTradingBotSignalSubOrderV5Request) CreateTradingBotSignalSubOrderV5Req(createTradingBotSignalSubOrderV5Req CreateTradingBotSignalSubOrderV5Req) ApiCreateTradingBotSignalSubOrderV5Request {
	r.createTradingBotSignalSubOrderV5Req = &createTradingBotSignalSubOrderV5Req
	return r
}

func (r ApiCreateTradingBotSignalSubOrderV5Request) Execute() (*CreateTradingBotSignalSubOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradingBotSignalSubOrderV5Execute(r)
}

/*
CreateTradingBotSignalSubOrderV5 You can place an order only if you have sufficient funds.      

You can place an order only if you have sufficient funds.





#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradingBotSignalSubOrderV5Request
*/
func (a *SignalBotTradingAPIService) CreateTradingBotSignalSubOrderV5(ctx context.Context) ApiCreateTradingBotSignalSubOrderV5Request {
	return ApiCreateTradingBotSignalSubOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradingBotSignalSubOrderV5Resp
func (a *SignalBotTradingAPIService) CreateTradingBotSignalSubOrderV5Execute(r ApiCreateTradingBotSignalSubOrderV5Request) (*CreateTradingBotSignalSubOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradingBotSignalSubOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.CreateTradingBotSignalSubOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/sub-order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradingBotSignalSubOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradingBotSignalSubOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradingBotSignalSubOrderV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalEventHistoryV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	algoId *string
	after *string
	before *string
	limit *string
}

// Algo ID
func (r ApiGetTradingBotSignalEventHistoryV5Request) AlgoId(algoId string) ApiGetTradingBotSignalEventHistoryV5Request {
	r.algoId = &algoId
	return r
}

// Pagination of data to return records &#x60;eventCtime&#x60; earlier than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalEventHistoryV5Request) After(after string) ApiGetTradingBotSignalEventHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records &#x60;eventCtime&#x60; newer than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalEventHistoryV5Request) Before(before string) ApiGetTradingBotSignalEventHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradingBotSignalEventHistoryV5Request) Limit(limit string) ApiGetTradingBotSignalEventHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradingBotSignalEventHistoryV5Request) Execute() (*GetTradingBotSignalEventHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalEventHistoryV5Execute(r)
}

/*
GetTradingBotSignalEventHistoryV5 Method for GetTradingBotSignalEventHistoryV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalEventHistoryV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalEventHistoryV5(ctx context.Context) ApiGetTradingBotSignalEventHistoryV5Request {
	return ApiGetTradingBotSignalEventHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalEventHistoryV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalEventHistoryV5Execute(r ApiGetTradingBotSignalEventHistoryV5Request) (*GetTradingBotSignalEventHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalEventHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalEventHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/event-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algoId == nil {
		return localVarReturnValue, nil, reportError("algoId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalOrdersAlgoDetailsV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	algoOrdType *string
	algoId *string
}

// Algo order type  &#x60;contract&#x60;: Contract signal
func (r ApiGetTradingBotSignalOrdersAlgoDetailsV5Request) AlgoOrdType(algoOrdType string) ApiGetTradingBotSignalOrdersAlgoDetailsV5Request {
	r.algoOrdType = &algoOrdType
	return r
}

// Algo ID
func (r ApiGetTradingBotSignalOrdersAlgoDetailsV5Request) AlgoId(algoId string) ApiGetTradingBotSignalOrdersAlgoDetailsV5Request {
	r.algoId = &algoId
	return r
}

func (r ApiGetTradingBotSignalOrdersAlgoDetailsV5Request) Execute() (*GetTradingBotSignalOrdersAlgoDetailsV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalOrdersAlgoDetailsV5Execute(r)
}

/*
GetTradingBotSignalOrdersAlgoDetailsV5 Method for GetTradingBotSignalOrdersAlgoDetailsV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalOrdersAlgoDetailsV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalOrdersAlgoDetailsV5(ctx context.Context) ApiGetTradingBotSignalOrdersAlgoDetailsV5Request {
	return ApiGetTradingBotSignalOrdersAlgoDetailsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalOrdersAlgoDetailsV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalOrdersAlgoDetailsV5Execute(r ApiGetTradingBotSignalOrdersAlgoDetailsV5Request) (*GetTradingBotSignalOrdersAlgoDetailsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalOrdersAlgoDetailsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalOrdersAlgoDetailsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/orders-algo-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algoOrdType == nil {
		return localVarReturnValue, nil, reportError("algoOrdType is required and must be specified")
	}
	if r.algoId == nil {
		return localVarReturnValue, nil, reportError("algoId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algoOrdType", r.algoOrdType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalOrdersAlgoHistoryV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	algoOrdType *string
	algoId *string
	after *string
	before *string
	limit *string
}

// Algo order type  &#x60;contract&#x60;: Contract signal
func (r ApiGetTradingBotSignalOrdersAlgoHistoryV5Request) AlgoOrdType(algoOrdType string) ApiGetTradingBotSignalOrdersAlgoHistoryV5Request {
	r.algoOrdType = &algoOrdType
	return r
}

// Algo ID
func (r ApiGetTradingBotSignalOrdersAlgoHistoryV5Request) AlgoId(algoId string) ApiGetTradingBotSignalOrdersAlgoHistoryV5Request {
	r.algoId = &algoId
	return r
}

// Pagination of data to return records &#x60;algoId&#x60; earlier than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalOrdersAlgoHistoryV5Request) After(after string) ApiGetTradingBotSignalOrdersAlgoHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records &#x60;algoId&#x60; newer than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalOrdersAlgoHistoryV5Request) Before(before string) ApiGetTradingBotSignalOrdersAlgoHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradingBotSignalOrdersAlgoHistoryV5Request) Limit(limit string) ApiGetTradingBotSignalOrdersAlgoHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradingBotSignalOrdersAlgoHistoryV5Request) Execute() (*GetTradingBotSignalOrdersAlgoHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalOrdersAlgoHistoryV5Execute(r)
}

/*
GetTradingBotSignalOrdersAlgoHistoryV5 Method for GetTradingBotSignalOrdersAlgoHistoryV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalOrdersAlgoHistoryV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalOrdersAlgoHistoryV5(ctx context.Context) ApiGetTradingBotSignalOrdersAlgoHistoryV5Request {
	return ApiGetTradingBotSignalOrdersAlgoHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalOrdersAlgoHistoryV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalOrdersAlgoHistoryV5Execute(r ApiGetTradingBotSignalOrdersAlgoHistoryV5Request) (*GetTradingBotSignalOrdersAlgoHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalOrdersAlgoHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalOrdersAlgoHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/orders-algo-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algoOrdType == nil {
		return localVarReturnValue, nil, reportError("algoOrdType is required and must be specified")
	}
	if r.algoId == nil {
		return localVarReturnValue, nil, reportError("algoId is required and must be specified")
	}
	if r.after == nil {
		return localVarReturnValue, nil, reportError("after is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algoOrdType", r.algoOrdType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalOrdersAlgoPendingV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	algoOrdType *string
	after *string
	algoId *string
	before *string
	limit *string
}

// Algo order type  &#x60;contract&#x60;: Contract signal
func (r ApiGetTradingBotSignalOrdersAlgoPendingV5Request) AlgoOrdType(algoOrdType string) ApiGetTradingBotSignalOrdersAlgoPendingV5Request {
	r.algoOrdType = &algoOrdType
	return r
}

// Pagination of data to return records &#x60;algoId&#x60; earlier than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalOrdersAlgoPendingV5Request) After(after string) ApiGetTradingBotSignalOrdersAlgoPendingV5Request {
	r.after = &after
	return r
}

// Algo ID
func (r ApiGetTradingBotSignalOrdersAlgoPendingV5Request) AlgoId(algoId string) ApiGetTradingBotSignalOrdersAlgoPendingV5Request {
	r.algoId = &algoId
	return r
}

// Pagination of data to return records &#x60;algoId&#x60; newer than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalOrdersAlgoPendingV5Request) Before(before string) ApiGetTradingBotSignalOrdersAlgoPendingV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradingBotSignalOrdersAlgoPendingV5Request) Limit(limit string) ApiGetTradingBotSignalOrdersAlgoPendingV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradingBotSignalOrdersAlgoPendingV5Request) Execute() (*GetTradingBotSignalOrdersAlgoPendingV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalOrdersAlgoPendingV5Execute(r)
}

/*
GetTradingBotSignalOrdersAlgoPendingV5 Method for GetTradingBotSignalOrdersAlgoPendingV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalOrdersAlgoPendingV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalOrdersAlgoPendingV5(ctx context.Context) ApiGetTradingBotSignalOrdersAlgoPendingV5Request {
	return ApiGetTradingBotSignalOrdersAlgoPendingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalOrdersAlgoPendingV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalOrdersAlgoPendingV5Execute(r ApiGetTradingBotSignalOrdersAlgoPendingV5Request) (*GetTradingBotSignalOrdersAlgoPendingV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalOrdersAlgoPendingV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalOrdersAlgoPendingV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/orders-algo-pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algoOrdType == nil {
		return localVarReturnValue, nil, reportError("algoOrdType is required and must be specified")
	}
	if r.after == nil {
		return localVarReturnValue, nil, reportError("after is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algoOrdType", r.algoOrdType, "form", "")
	if r.algoId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	} else {
		var defaultValue string = ""
		r.algoId = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalPositionsHistoryV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	algoId *string
	instId *string
	after *string
	before *string
	limit *string
}

// Algo ID
func (r ApiGetTradingBotSignalPositionsHistoryV5Request) AlgoId(algoId string) ApiGetTradingBotSignalPositionsHistoryV5Request {
	r.algoId = &algoId
	return r
}

// Instrument ID, e.g.：&#x60;BTC-USD-SWAP&#x60;
func (r ApiGetTradingBotSignalPositionsHistoryV5Request) InstId(instId string) ApiGetTradingBotSignalPositionsHistoryV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;uTime&#x60;, Unix timestamp format in milliseconds, e.g.&#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalPositionsHistoryV5Request) After(after string) ApiGetTradingBotSignalPositionsHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;uTime&#x60;, Unix timestamp format in milliseconds, e.g &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalPositionsHistoryV5Request) Before(before string) ApiGetTradingBotSignalPositionsHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradingBotSignalPositionsHistoryV5Request) Limit(limit string) ApiGetTradingBotSignalPositionsHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradingBotSignalPositionsHistoryV5Request) Execute() (*GetTradingBotSignalPositionsHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalPositionsHistoryV5Execute(r)
}

/*
GetTradingBotSignalPositionsHistoryV5 Retrieve the updated position data for the last 3 months. Return in reverse chronological order using utime.  

Retrieve the updated position data for the last 3 months. Return in reverse chronological order using utime.

#### Rate Limit: 1 request per 10 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalPositionsHistoryV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalPositionsHistoryV5(ctx context.Context) ApiGetTradingBotSignalPositionsHistoryV5Request {
	return ApiGetTradingBotSignalPositionsHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalPositionsHistoryV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalPositionsHistoryV5Execute(r ApiGetTradingBotSignalPositionsHistoryV5Request) (*GetTradingBotSignalPositionsHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalPositionsHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalPositionsHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/positions-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algoId == nil {
		return localVarReturnValue, nil, reportError("algoId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalPositionsV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	algoOrdType *string
	algoId *string
}

// Algo order type  &#x60;contract&#x60;: Contract signal
func (r ApiGetTradingBotSignalPositionsV5Request) AlgoOrdType(algoOrdType string) ApiGetTradingBotSignalPositionsV5Request {
	r.algoOrdType = &algoOrdType
	return r
}

// Algo ID
func (r ApiGetTradingBotSignalPositionsV5Request) AlgoId(algoId string) ApiGetTradingBotSignalPositionsV5Request {
	r.algoId = &algoId
	return r
}

func (r ApiGetTradingBotSignalPositionsV5Request) Execute() (*GetTradingBotSignalPositionsV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalPositionsV5Execute(r)
}

/*
GetTradingBotSignalPositionsV5 Method for GetTradingBotSignalPositionsV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalPositionsV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalPositionsV5(ctx context.Context) ApiGetTradingBotSignalPositionsV5Request {
	return ApiGetTradingBotSignalPositionsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalPositionsV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalPositionsV5Execute(r ApiGetTradingBotSignalPositionsV5Request) (*GetTradingBotSignalPositionsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalPositionsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalPositionsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/positions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algoOrdType == nil {
		return localVarReturnValue, nil, reportError("algoOrdType is required and must be specified")
	}
	if r.algoId == nil {
		return localVarReturnValue, nil, reportError("algoId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algoOrdType", r.algoOrdType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalSignalsV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	signalSourceType *string
	signalChanId *string
	after *string
	before *string
	limit *string
}

// Signal source type  &#x60;1&#x60;: Created by yourself  &#x60;2&#x60;: Subscribe  &#x60;3&#x60;: Free signal
func (r ApiGetTradingBotSignalSignalsV5Request) SignalSourceType(signalSourceType string) ApiGetTradingBotSignalSignalsV5Request {
	r.signalSourceType = &signalSourceType
	return r
}

// Signal channel id
func (r ApiGetTradingBotSignalSignalsV5Request) SignalChanId(signalChanId string) ApiGetTradingBotSignalSignalsV5Request {
	r.signalChanId = &signalChanId
	return r
}

// Pagination of data to return records &#x60;signalChanId&#x60; earlier than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalSignalsV5Request) After(after string) ApiGetTradingBotSignalSignalsV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records &#x60;signalChanId&#x60; newer than the requested timestamp, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalSignalsV5Request) Before(before string) ApiGetTradingBotSignalSignalsV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradingBotSignalSignalsV5Request) Limit(limit string) ApiGetTradingBotSignalSignalsV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradingBotSignalSignalsV5Request) Execute() (*GetTradingBotSignalSignalsV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalSignalsV5Execute(r)
}

/*
GetTradingBotSignalSignalsV5 Method for GetTradingBotSignalSignalsV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalSignalsV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalSignalsV5(ctx context.Context) ApiGetTradingBotSignalSignalsV5Request {
	return ApiGetTradingBotSignalSignalsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalSignalsV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalSignalsV5Execute(r ApiGetTradingBotSignalSignalsV5Request) (*GetTradingBotSignalSignalsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalSignalsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalSignalsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/signals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.signalSourceType == nil {
		return localVarReturnValue, nil, reportError("signalSourceType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "signalSourceType", r.signalSourceType, "form", "")
	if r.signalChanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signalChanId", r.signalChanId, "form", "")
	} else {
		var defaultValue string = ""
		r.signalChanId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradingBotSignalSubOrdersV5Request struct {
	ctx context.Context
	ApiService *SignalBotTradingAPIService
	algoId *string
	algoOrdType *string
	state *string
	signalOrdId *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
	type_ *string
	clOrdId *string
}

// Algo ID
func (r ApiGetTradingBotSignalSubOrdersV5Request) AlgoId(algoId string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.algoId = &algoId
	return r
}

// Algo order type  &#x60;contract&#x60;: Contract signal
func (r ApiGetTradingBotSignalSubOrdersV5Request) AlgoOrdType(algoOrdType string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.algoOrdType = &algoOrdType
	return r
}

// Sub order state  &#x60;live&#x60;  &#x60;partially_filled&#x60;  &#x60;filled&#x60;  &#x60;cancelled&#x60;  Either &#x60;state&#x60; or &#x60;signalOrdId&#x60; is required, if both are passed in, only &#x60;state&#x60; is valid.
func (r ApiGetTradingBotSignalSubOrdersV5Request) State(state string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.state = &state
	return r
}

// Sub order ID
func (r ApiGetTradingBotSignalSubOrdersV5Request) SignalOrdId(signalOrdId string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.signalOrdId = &signalOrdId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ordId&#x60;
func (r ApiGetTradingBotSignalSubOrdersV5Request) After(after string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ordId&#x60;.
func (r ApiGetTradingBotSignalSubOrdersV5Request) Before(before string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.before = &before
	return r
}

// Return records of &#x60;ctime&#x60; after than the requested timestamp (include), Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalSubOrdersV5Request) Begin(begin string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.begin = &begin
	return r
}

// Return records of &#x60;ctime&#x60; before than the requested timestamp (include), Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradingBotSignalSubOrdersV5Request) End(end string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradingBotSignalSubOrdersV5Request) Limit(limit string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.limit = &limit
	return r
}

// Sub order type   &#x60;live&#x60;  &#x60;filled&#x60;  Either &#x60;type&#x60; or &#x60;clOrdId&#x60; is required, if both are passed in, only &#x60;clOrdId&#x60; is valid.
func (r ApiGetTradingBotSignalSubOrdersV5Request) Type_(type_ string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.type_ = &type_
	return r
}

// Sub order client-supplied ID.   &#x60;It will be deprecated soon&#x60;
func (r ApiGetTradingBotSignalSubOrdersV5Request) ClOrdId(clOrdId string) ApiGetTradingBotSignalSubOrdersV5Request {
	r.clOrdId = &clOrdId
	return r
}

func (r ApiGetTradingBotSignalSubOrdersV5Request) Execute() (*GetTradingBotSignalSubOrdersV5Resp, *http.Response, error) {
	return r.ApiService.GetTradingBotSignalSubOrdersV5Execute(r)
}

/*
GetTradingBotSignalSubOrdersV5 Method for GetTradingBotSignalSubOrdersV5

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradingBotSignalSubOrdersV5Request
*/
func (a *SignalBotTradingAPIService) GetTradingBotSignalSubOrdersV5(ctx context.Context) ApiGetTradingBotSignalSubOrdersV5Request {
	return ApiGetTradingBotSignalSubOrdersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradingBotSignalSubOrdersV5Resp
func (a *SignalBotTradingAPIService) GetTradingBotSignalSubOrdersV5Execute(r ApiGetTradingBotSignalSubOrdersV5Request) (*GetTradingBotSignalSubOrdersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradingBotSignalSubOrdersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalBotTradingAPIService.GetTradingBotSignalSubOrdersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/tradingBot/signal/sub-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algoId == nil {
		return localVarReturnValue, nil, reportError("algoId is required and must be specified")
	}
	if r.algoOrdType == nil {
		return localVarReturnValue, nil, reportError("algoOrdType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algoId", r.algoId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "algoOrdType", r.algoOrdType, "form", "")
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.signalOrdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signalOrdId", r.signalOrdId, "form", "")
	} else {
		var defaultValue string = ""
		r.signalOrdId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.clOrdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clOrdId", r.clOrdId, "form", "")
	} else {
		var defaultValue string = ""
		r.clOrdId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
