/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"fmt"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FundingAccountAPIService FundingAccountAPI service
type FundingAccountAPIService service

type ApiCreateAssetCancelWithdrawalV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createAssetCancelWithdrawalV5Req *CreateAssetCancelWithdrawalV5Req
}

// The request body for CreateAssetCancelWithdrawalV5
func (r ApiCreateAssetCancelWithdrawalV5Request) CreateAssetCancelWithdrawalV5Req(createAssetCancelWithdrawalV5Req CreateAssetCancelWithdrawalV5Req) ApiCreateAssetCancelWithdrawalV5Request {
	r.createAssetCancelWithdrawalV5Req = &createAssetCancelWithdrawalV5Req
	return r
}

func (r ApiCreateAssetCancelWithdrawalV5Request) Execute() (*CreateAssetCancelWithdrawalV5Resp, *http.Response, error) {
	return r.ApiService.CreateAssetCancelWithdrawalV5Execute(r)
}

/*
CreateAssetCancelWithdrawalV5 Cancel withdrawal

You can cancel normal withdrawal requests, but you cannot cancel withdrawal requests on Lightning.

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetCancelWithdrawalV5Request
*/
func (a *FundingAccountAPIService) CreateAssetCancelWithdrawalV5(ctx context.Context) ApiCreateAssetCancelWithdrawalV5Request {
	return ApiCreateAssetCancelWithdrawalV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetCancelWithdrawalV5Resp
func (a *FundingAccountAPIService) CreateAssetCancelWithdrawalV5Execute(r ApiCreateAssetCancelWithdrawalV5Request) (*CreateAssetCancelWithdrawalV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetCancelWithdrawalV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateAssetCancelWithdrawalV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/cancel-withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssetCancelWithdrawalV5Req == nil {
		return localVarReturnValue, nil, reportError("createAssetCancelWithdrawalV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetCancelWithdrawalV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetConvertEstimateQuoteV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createAssetConvertEstimateQuoteV5Req *CreateAssetConvertEstimateQuoteV5Req
}

// The request body for CreateAssetConvertEstimateQuoteV5
func (r ApiCreateAssetConvertEstimateQuoteV5Request) CreateAssetConvertEstimateQuoteV5Req(createAssetConvertEstimateQuoteV5Req CreateAssetConvertEstimateQuoteV5Req) ApiCreateAssetConvertEstimateQuoteV5Request {
	r.createAssetConvertEstimateQuoteV5Req = &createAssetConvertEstimateQuoteV5Req
	return r
}

func (r ApiCreateAssetConvertEstimateQuoteV5Request) Execute() (*CreateAssetConvertEstimateQuoteV5Resp, *http.Response, error) {
	return r.ApiService.CreateAssetConvertEstimateQuoteV5Execute(r)
}

/*
CreateAssetConvertEstimateQuoteV5 Estimate quote

#### Rate Limit: 10 requests per second 

#### Rate limit rule: User ID 

#### Rate Limit: 1 request per 5 seconds 

#### Rate limit rule: Instrument 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetConvertEstimateQuoteV5Request
*/
func (a *FundingAccountAPIService) CreateAssetConvertEstimateQuoteV5(ctx context.Context) ApiCreateAssetConvertEstimateQuoteV5Request {
	return ApiCreateAssetConvertEstimateQuoteV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetConvertEstimateQuoteV5Resp
func (a *FundingAccountAPIService) CreateAssetConvertEstimateQuoteV5Execute(r ApiCreateAssetConvertEstimateQuoteV5Request) (*CreateAssetConvertEstimateQuoteV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetConvertEstimateQuoteV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateAssetConvertEstimateQuoteV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/convert/estimate-quote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssetConvertEstimateQuoteV5Req == nil {
		return localVarReturnValue, nil, reportError("createAssetConvertEstimateQuoteV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetConvertEstimateQuoteV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetConvertTradeV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createAssetConvertTradeV5Req *CreateAssetConvertTradeV5Req
}

// The request body for CreateAssetConvertTradeV5
func (r ApiCreateAssetConvertTradeV5Request) CreateAssetConvertTradeV5Req(createAssetConvertTradeV5Req CreateAssetConvertTradeV5Req) ApiCreateAssetConvertTradeV5Request {
	r.createAssetConvertTradeV5Req = &createAssetConvertTradeV5Req
	return r
}

func (r ApiCreateAssetConvertTradeV5Request) Execute() (*CreateAssetConvertTradeV5Resp, *http.Response, error) {
	return r.ApiService.CreateAssetConvertTradeV5Execute(r)
}

/*
CreateAssetConvertTradeV5 Convert trade

You should make  before convert trade. 

**_Only assets in the trading account supported convert._**

#### Rate Limit: 10 requests per second 

#### Rate limit rule: User ID 

#### Permission: Trade 

For the same side (buy/sell), there's a trading limit of 1 request per 5 seconds.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetConvertTradeV5Request
*/
func (a *FundingAccountAPIService) CreateAssetConvertTradeV5(ctx context.Context) ApiCreateAssetConvertTradeV5Request {
	return ApiCreateAssetConvertTradeV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetConvertTradeV5Resp
func (a *FundingAccountAPIService) CreateAssetConvertTradeV5Execute(r ApiCreateAssetConvertTradeV5Request) (*CreateAssetConvertTradeV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetConvertTradeV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateAssetConvertTradeV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/convert/trade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssetConvertTradeV5Req == nil {
		return localVarReturnValue, nil, reportError("createAssetConvertTradeV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetConvertTradeV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetMonthlyStatementV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createAssetMonthlyStatementV5Req *CreateAssetMonthlyStatementV5Req
}

// The request body for CreateAssetMonthlyStatementV5
func (r ApiCreateAssetMonthlyStatementV5Request) CreateAssetMonthlyStatementV5Req(createAssetMonthlyStatementV5Req CreateAssetMonthlyStatementV5Req) ApiCreateAssetMonthlyStatementV5Request {
	r.createAssetMonthlyStatementV5Req = &createAssetMonthlyStatementV5Req
	return r
}

func (r ApiCreateAssetMonthlyStatementV5Request) Execute() (*CreateAssetMonthlyStatementV5Resp, *http.Response, error) {
	return r.ApiService.CreateAssetMonthlyStatementV5Execute(r)
}

/*
CreateAssetMonthlyStatementV5 Apply for monthly statement (last year)

Apply for monthly statement in the past year.

#### Rate Limit: 20 requests per month 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetMonthlyStatementV5Request
*/
func (a *FundingAccountAPIService) CreateAssetMonthlyStatementV5(ctx context.Context) ApiCreateAssetMonthlyStatementV5Request {
	return ApiCreateAssetMonthlyStatementV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetMonthlyStatementV5Resp
func (a *FundingAccountAPIService) CreateAssetMonthlyStatementV5Execute(r ApiCreateAssetMonthlyStatementV5Request) (*CreateAssetMonthlyStatementV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetMonthlyStatementV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateAssetMonthlyStatementV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/monthly-statement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssetMonthlyStatementV5Req == nil {
		return localVarReturnValue, nil, reportError("createAssetMonthlyStatementV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetMonthlyStatementV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetTransferV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createAssetTransferV5Req *CreateAssetTransferV5Req
}

// The request body for CreateAssetTransferV5
func (r ApiCreateAssetTransferV5Request) CreateAssetTransferV5Req(createAssetTransferV5Req CreateAssetTransferV5Req) ApiCreateAssetTransferV5Request {
	r.createAssetTransferV5Req = &createAssetTransferV5Req
	return r
}

func (r ApiCreateAssetTransferV5Request) Execute() (*CreateAssetTransferV5Resp, *http.Response, error) {
	return r.ApiService.CreateAssetTransferV5Execute(r)
}

/*
CreateAssetTransferV5 Funds transfer

Only API keys with `Trade` privilege can call this endpoint.

This endpoint supports the transfer of funds between your funding account and trading account, and from the master account to sub-accounts.

Sub-account can transfer out to master account by default. Need to call  to grant privilege first if you want sub-account transferring to another sub-account (sub-accounts need to belong to same master account.)

**_Failure of the request does not mean the transfer has failed. Recommend to call "Get funds transfer state" to confirm the status._**

#### Rate Limit: 2 requests per second 

#### Rate limit rule: User ID + Currency 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetTransferV5Request
*/
func (a *FundingAccountAPIService) CreateAssetTransferV5(ctx context.Context) ApiCreateAssetTransferV5Request {
	return ApiCreateAssetTransferV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetTransferV5Resp
func (a *FundingAccountAPIService) CreateAssetTransferV5Execute(r ApiCreateAssetTransferV5Request) (*CreateAssetTransferV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetTransferV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateAssetTransferV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssetTransferV5Req == nil {
		return localVarReturnValue, nil, reportError("createAssetTransferV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetTransferV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetWithdrawalV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createAssetWithdrawalV5Req *CreateAssetWithdrawalV5Req
}

// The request body for CreateAssetWithdrawalV5
func (r ApiCreateAssetWithdrawalV5Request) CreateAssetWithdrawalV5Req(createAssetWithdrawalV5Req CreateAssetWithdrawalV5Req) ApiCreateAssetWithdrawalV5Request {
	r.createAssetWithdrawalV5Req = &createAssetWithdrawalV5Req
	return r
}

func (r ApiCreateAssetWithdrawalV5Request) Execute() (*CreateAssetWithdrawalV5Resp, *http.Response, error) {
	return r.ApiService.CreateAssetWithdrawalV5Execute(r)
}

/*
CreateAssetWithdrawalV5 Withdrawal

Only supported withdrawal of assets from funding account. Common sub-account does not support withdrawal. 

**_The API can only make withdrawal to verified addresses/account, and verified addresses can be set by WEB/APP._**

**_About tagSome token deposits require a deposit address and a tag (e.g. Memo/Payment ID), which is a string that guarantees the uniqueness of your deposit address. Follow the deposit procedure carefully, or you may risk losing your assets.For currencies with labels, if it is a withdrawal between OKX users, please use internal transfer instead of online withdrawal_**

**_The following content only applies to users residing in the United Arab EmiratesDue to local laws and regulations in your country or region, a certain ratio of user assets must be stored in cold wallets. We will perform cold-to-hot wallet asset transfers from time to time. However, if assets in hot wallets are not sufficient to meet user withdrawal demands, an extra step is needed to transfer cold wallet assets to the hot wallet. This may cause delays of up to 24 hours to receive withdrawals.Learn more (https://www.okx.com/help/what-is-a-segregated-wallet-and-why-is-my-withdrawal-delayed)_**

**_Users under certain entities need to provide additional information for withdrawalBahama entity users refer to https://www.okx.com/docs-v5/log_en/#2024-08-08-withdrawal-api-adjustment-for-bahama-entity-users_**

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Withdraw 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetWithdrawalV5Request
*/
func (a *FundingAccountAPIService) CreateAssetWithdrawalV5(ctx context.Context) ApiCreateAssetWithdrawalV5Request {
	return ApiCreateAssetWithdrawalV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetWithdrawalV5Resp
func (a *FundingAccountAPIService) CreateAssetWithdrawalV5Execute(r ApiCreateAssetWithdrawalV5Request) (*CreateAssetWithdrawalV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetWithdrawalV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateAssetWithdrawalV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssetWithdrawalV5Req == nil {
		return localVarReturnValue, nil, reportError("createAssetWithdrawalV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetWithdrawalV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFiatCancelWithdrawalV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createFiatCancelWithdrawalV5Req *CreateFiatCancelWithdrawalV5Req
}

// The request body for CreateFiatCancelWithdrawalV5
func (r ApiCreateFiatCancelWithdrawalV5Request) CreateFiatCancelWithdrawalV5Req(createFiatCancelWithdrawalV5Req CreateFiatCancelWithdrawalV5Req) ApiCreateFiatCancelWithdrawalV5Request {
	r.createFiatCancelWithdrawalV5Req = &createFiatCancelWithdrawalV5Req
	return r
}

func (r ApiCreateFiatCancelWithdrawalV5Request) Execute() (*CreateFiatCancelWithdrawalV5Resp, *http.Response, error) {
	return r.ApiService.CreateFiatCancelWithdrawalV5Execute(r)
}

/*
CreateFiatCancelWithdrawalV5 Cancel withdrawal order

Cancel a pending fiat withdrawal order, currently only applicable to TRY

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFiatCancelWithdrawalV5Request
*/
func (a *FundingAccountAPIService) CreateFiatCancelWithdrawalV5(ctx context.Context) ApiCreateFiatCancelWithdrawalV5Request {
	return ApiCreateFiatCancelWithdrawalV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateFiatCancelWithdrawalV5Resp
func (a *FundingAccountAPIService) CreateFiatCancelWithdrawalV5Execute(r ApiCreateFiatCancelWithdrawalV5Request) (*CreateFiatCancelWithdrawalV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFiatCancelWithdrawalV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateFiatCancelWithdrawalV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/cancel-withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFiatCancelWithdrawalV5Req == nil {
		return localVarReturnValue, nil, reportError("createFiatCancelWithdrawalV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFiatCancelWithdrawalV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFiatCreateWithdrawalV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	createFiatCreateWithdrawalV5Req *CreateFiatCreateWithdrawalV5Req
}

// The request body for CreateFiatCreateWithdrawalV5
func (r ApiCreateFiatCreateWithdrawalV5Request) CreateFiatCreateWithdrawalV5Req(createFiatCreateWithdrawalV5Req CreateFiatCreateWithdrawalV5Req) ApiCreateFiatCreateWithdrawalV5Request {
	r.createFiatCreateWithdrawalV5Req = &createFiatCreateWithdrawalV5Req
	return r
}

func (r ApiCreateFiatCreateWithdrawalV5Request) Execute() (*CreateFiatCreateWithdrawalV5Resp, *http.Response, error) {
	return r.ApiService.CreateFiatCreateWithdrawalV5Execute(r)
}

/*
CreateFiatCreateWithdrawalV5 Create withdrawal order

Initiate a fiat withdrawal request (Authenticated endpoint, Only for API keys with "Withdrawal" access)


Only supported withdrawal of assets from funding account.

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Withdraw 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFiatCreateWithdrawalV5Request
*/
func (a *FundingAccountAPIService) CreateFiatCreateWithdrawalV5(ctx context.Context) ApiCreateFiatCreateWithdrawalV5Request {
	return ApiCreateFiatCreateWithdrawalV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateFiatCreateWithdrawalV5Resp
func (a *FundingAccountAPIService) CreateFiatCreateWithdrawalV5Execute(r ApiCreateFiatCreateWithdrawalV5Request) (*CreateFiatCreateWithdrawalV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateFiatCreateWithdrawalV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.CreateFiatCreateWithdrawalV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/create-withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFiatCreateWithdrawalV5Req == nil {
		return localVarReturnValue, nil, reportError("createFiatCreateWithdrawalV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFiatCreateWithdrawalV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetAssetValuationV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
}

// Asset valuation calculation unit   BTC, USDT  USD, CNY, JP, KRW, RUB, EUR  VND, IDR, INR, PHP, THB, TRY   AUD, SGD, ARS, SAR, AED, IQD   The default is the valuation in BTC.
func (r ApiGetAssetAssetValuationV5Request) Ccy(ccy string) ApiGetAssetAssetValuationV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAssetAssetValuationV5Request) Execute() (*GetAssetAssetValuationV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetAssetValuationV5Execute(r)
}

/*
GetAssetAssetValuationV5 Get account asset valuation

View account asset valuation

#### Rate Limit: 1 request per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetAssetValuationV5Request
*/
func (a *FundingAccountAPIService) GetAssetAssetValuationV5(ctx context.Context) ApiGetAssetAssetValuationV5Request {
	return ApiGetAssetAssetValuationV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetAssetValuationV5Resp
func (a *FundingAccountAPIService) GetAssetAssetValuationV5Execute(r ApiGetAssetAssetValuationV5Request) (*GetAssetAssetValuationV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetAssetValuationV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetAssetValuationV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/asset-valuation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetBalancesV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
}

// Single currency or multiple currencies (no more than 20) separated with comma, e.g. &#x60;BTC&#x60; or &#x60;BTC,ETH&#x60;.
func (r ApiGetAssetBalancesV5Request) Ccy(ccy string) ApiGetAssetBalancesV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAssetBalancesV5Request) Execute() (*GetAssetBalancesV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetBalancesV5Execute(r)
}

/*
GetAssetBalancesV5 Get balance

Retrieve the funding account balances of all the assets and the amount that is available or on hold.

**_Only asset information of a currency with a balance greater than 0 will be returned._**

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetBalancesV5Request
*/
func (a *FundingAccountAPIService) GetAssetBalancesV5(ctx context.Context) ApiGetAssetBalancesV5Request {
	return ApiGetAssetBalancesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetBalancesV5Resp
func (a *FundingAccountAPIService) GetAssetBalancesV5Execute(r ApiGetAssetBalancesV5Request) (*GetAssetBalancesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetBalancesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetBalancesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetBillsV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
	type_ *string
	clientId *string
	after *string
	before *string
	limit *string
}

// Currency
func (r ApiGetAssetBillsV5Request) Ccy(ccy string) ApiGetAssetBillsV5Request {
	r.ccy = &ccy
	return r
}

// Bill type  &#x60;1&#x60;: Deposit  &#x60;2&#x60;: Withdrawal  &#x60;13&#x60;: Canceled withdrawal  &#x60;20&#x60;: Transfer to sub account (for master account)  &#x60;21&#x60;: Transfer from sub account (for master account)  &#x60;22&#x60;: Transfer out from sub to master account (for sub-account)  &#x60;23&#x60;: Transfer in from master to sub account (for sub-account)  &#x60;28&#x60;: Manually claimed Airdrop  &#x60;47&#x60;: System reversal  &#x60;48&#x60;: Event Reward  &#x60;49&#x60;: Event Giveaway  &#x60;68&#x60;: Fee rebate (by rebate card)  &#x60;72&#x60;: Token received  &#x60;73&#x60;: Token given away  &#x60;74&#x60;: Token refunded  &#x60;75&#x60;: [Simple earn flexible] Subscription  &#x60;76&#x60;: [Simple earn flexible] Redemption  &#x60;77&#x60;: Jumpstart distribute  &#x60;78&#x60;: Jumpstart lock up  &#x60;80&#x60;: DEFI/Staking subscription  &#x60;82&#x60;: DEFI/Staking redemption  &#x60;83&#x60;: Staking yield  &#x60;84&#x60;: Violation fee  &#x60;89&#x60;: Deposit yield  &#x60;116&#x60;: [Fiat] Place an order  &#x60;117&#x60;: [Fiat] Fulfill an order  &#x60;118&#x60;: [Fiat] Cancel an order  &#x60;124&#x60;: Jumpstart unlocking  &#x60;130&#x60;: Transferred from Trading account  &#x60;131&#x60;: Transferred to Trading account  &#x60;132&#x60;: [P2P] Frozen by customer service  &#x60;133&#x60;: [P2P] Unfrozen by customer service  &#x60;134&#x60;: [P2P] Transferred by customer service  &#x60;135&#x60;: Cross chain exchange  &#x60;137&#x60;: [ETH Staking] Subscription  &#x60;138&#x60;: [ETH Staking] Swapping  &#x60;139&#x60;: [ETH Staking] Earnings  &#x60;146&#x60;: Customer feedback  &#x60;150&#x60;: Affiliate commission  &#x60;151&#x60;: Referral reward  &#x60;152&#x60;: Broker reward  &#x60;160&#x60;: Dual Investment subscribe  &#x60;161&#x60;: Dual Investment collection  &#x60;162&#x60;: Dual Investment profit  &#x60;163&#x60;: Dual Investment refund  &#x60;172&#x60;: [Affiliate] Sub-affiliate commission  &#x60;173&#x60;: [Affiliate] Fee rebate (by trading fee)  &#x60;174&#x60;: Jumpstart Pay  &#x60;175&#x60;: Locked collateral  &#x60;176&#x60;: Loan  &#x60;177&#x60;: Added collateral  &#x60;178&#x60;: Returned collateral  &#x60;179&#x60;: Repayment  &#x60;180&#x60;: Unlocked collateral  &#x60;181&#x60;: Airdrop payment  &#x60;185&#x60;: [Broker] Convert reward  &#x60;187&#x60;: [Broker] Convert transfer  &#x60;189&#x60;: Mystery box bonus  &#x60;195&#x60;: Untradable asset withdrawal  &#x60;196&#x60;: Untradable asset withdrawal revoked  &#x60;197&#x60;: Untradable asset deposit  &#x60;198&#x60;: Untradable asset collection reduce  &#x60;199&#x60;: Untradable asset collection increase  &#x60;200&#x60;: Buy  &#x60;202&#x60;: Price Lock Subscribe  &#x60;203&#x60;: Price Lock Collection  &#x60;204&#x60;: Price Lock Profit  &#x60;205&#x60;: Price Lock Refund  &#x60;207&#x60;: Dual Investment Lite Subscribe  &#x60;208&#x60;: Dual Investment Lite Collection  &#x60;209&#x60;: Dual Investment Lite Profit  &#x60;210&#x60;: Dual Investment Lite Refund  &#x60;212&#x60;: [Flexible loan] Multi-collateral loan collateral locked  &#x60;215&#x60;: [Flexible loan] Multi-collateral loan collateral released  &#x60;217&#x60;: [Flexible loan] Multi-collateral loan borrowed  &#x60;218&#x60;: [Flexible loan] Multi-collateral loan repaid  &#x60;232&#x60;: [Flexible loan] Subsidized interest received  &#x60;220&#x60;: Delisted crypto  &#x60;221&#x60;: Blockchain&#39;s withdrawal fee  &#x60;222&#x60;: Withdrawal fee refund  &#x60;223&#x60;: SWAP lead trading profit share  &#x60;225&#x60;: Shark Fin subscribe  &#x60;226&#x60;: Shark Fin collection  &#x60;227&#x60;: Shark Fin profit  &#x60;228&#x60;: Shark Fin refund  &#x60;229&#x60;: Airdrop  &#x60;232&#x60;: Subsidized interest received  &#x60;233&#x60;: Broker rebate compensation  &#x60;240&#x60;: Snowball subscribe  &#x60;241&#x60;: Snowball refund  &#x60;242&#x60;: Snowball profit  &#x60;243&#x60;: Snowball trading failed  &#x60;249&#x60;: Seagull subscribe  &#x60;250&#x60;: Seagull collection  &#x60;251&#x60;: Seagull profit  &#x60;252&#x60;: Seagull refund  &#x60;263&#x60;: Strategy bots profit share  &#x60;265&#x60;: Signal revenue  &#x60;266&#x60;: SPOT lead trading profit share  &#x60;270&#x60;: DCD broker transfer  &#x60;271&#x60;: DCD broker rebate  &#x60;272&#x60;: [Convert] Buy Crypto/Fiat  &#x60;273&#x60;: [Convert] Sell Crypto/Fiat  &#x60;284&#x60;: [Custody] Transfer out trading sub-account  &#x60;285&#x60;: [Custody] Transfer in trading sub-account  &#x60;286&#x60;: [Custody] Transfer out custody funding account  &#x60;287&#x60;: [Custody] Transfer in custody funding account  &#x60;288&#x60;: [Custody] Fund delegation   &#x60;289&#x60;: [Custody] Fund undelegation  &#x60;299&#x60;: Affiliate recommendation commission  &#x60;300&#x60;: Fee discount rebate  &#x60;303&#x60;: Snowball market maker transfer  &#x60;304&#x60;: [Simple Earn Fixed] Order submission  &#x60;305&#x60;: [Simple Earn Fixed] Order redemption  &#x60;306&#x60;: [Simple Earn Fixed] Principal distribution  &#x60;307&#x60;: [Simple Earn Fixed] Interest distribution (early termination compensation)  &#x60;308&#x60;: [Simple Earn Fixed] Interest distribution  &#x60;309&#x60;: [Simple Earn Fixed] Interest distribution (extension compensation)   &#x60;311&#x60;: Crypto dust auto-transfer in  &#x60;313&#x60;: Sent by gift  &#x60;314&#x60;: Received from gift  &#x60;315&#x60;: Refunded from gift  &#x60;328&#x60;: [SOL staking] Send Liquidity Staking Token reward  &#x60;329&#x60;: [SOL staking] Subscribe Liquidity Staking Token staking  &#x60;330&#x60;: [SOL staking] Mint Liquidity Staking Token  &#x60;331&#x60;: [SOL staking] Redeem Liquidity Staking Token order  &#x60;332&#x60;: [SOL staking] Settle Liquidity Staking Token order  &#x60;333&#x60;: Trial fund reward  &#x60;336&#x60;: [Credit line] Loan Forced Repayment  &#x60;338&#x60;: [Credit line] Forced Repayment Refund  &#x60;354&#x60;: Copy and bot rewards  &#x60;361&#x60;: Deposit from closed sub-account
func (r ApiGetAssetBillsV5Request) Type_(type_ string) ApiGetAssetBillsV5Request {
	r.type_ = &type_
	return r
}

// Client-supplied ID for transfer or withdrawal  A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
func (r ApiGetAssetBillsV5Request) ClientId(clientId string) ApiGetAssetBillsV5Request {
	r.clientId = &clientId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAssetBillsV5Request) After(after string) ApiGetAssetBillsV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAssetBillsV5Request) Before(before string) ApiGetAssetBillsV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetAssetBillsV5Request) Limit(limit string) ApiGetAssetBillsV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAssetBillsV5Request) Execute() (*GetAssetBillsV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetBillsV5Execute(r)
}

/*
GetAssetBillsV5 Asset bills details

Query the billing record in the past month.

#### Rate Limit: 6 Requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetBillsV5Request
*/
func (a *FundingAccountAPIService) GetAssetBillsV5(ctx context.Context) ApiGetAssetBillsV5Request {
	return ApiGetAssetBillsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetBillsV5Resp
func (a *FundingAccountAPIService) GetAssetBillsV5Execute(r ApiGetAssetBillsV5Request) (*GetAssetBillsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetBillsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetBillsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/bills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientId", r.clientId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetConvertCurrenciesV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
}

func (r ApiGetAssetConvertCurrenciesV5Request) Execute() (*GetAssetConvertCurrenciesV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetConvertCurrenciesV5Execute(r)
}

/*
GetAssetConvertCurrenciesV5 Get convert currencies

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetConvertCurrenciesV5Request
*/
func (a *FundingAccountAPIService) GetAssetConvertCurrenciesV5(ctx context.Context) ApiGetAssetConvertCurrenciesV5Request {
	return ApiGetAssetConvertCurrenciesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetConvertCurrenciesV5Resp
func (a *FundingAccountAPIService) GetAssetConvertCurrenciesV5Execute(r ApiGetAssetConvertCurrenciesV5Request) (*GetAssetConvertCurrenciesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetConvertCurrenciesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetConvertCurrenciesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/convert/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetConvertCurrencyPairV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	fromCcy *string
	toCcy *string
}

// Currency to convert from, e.g. &#x60;USDT&#x60;
func (r ApiGetAssetConvertCurrencyPairV5Request) FromCcy(fromCcy string) ApiGetAssetConvertCurrencyPairV5Request {
	r.fromCcy = &fromCcy
	return r
}

// Currency to convert to, e.g. &#x60;BTC&#x60;
func (r ApiGetAssetConvertCurrencyPairV5Request) ToCcy(toCcy string) ApiGetAssetConvertCurrencyPairV5Request {
	r.toCcy = &toCcy
	return r
}

func (r ApiGetAssetConvertCurrencyPairV5Request) Execute() (*GetAssetConvertCurrencyPairV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetConvertCurrencyPairV5Execute(r)
}

/*
GetAssetConvertCurrencyPairV5 Get convert currency pair

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetConvertCurrencyPairV5Request
*/
func (a *FundingAccountAPIService) GetAssetConvertCurrencyPairV5(ctx context.Context) ApiGetAssetConvertCurrencyPairV5Request {
	return ApiGetAssetConvertCurrencyPairV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetConvertCurrencyPairV5Resp
func (a *FundingAccountAPIService) GetAssetConvertCurrencyPairV5Execute(r ApiGetAssetConvertCurrencyPairV5Request) (*GetAssetConvertCurrencyPairV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetConvertCurrencyPairV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetConvertCurrencyPairV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/convert/currency-pair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromCcy == nil {
		return localVarReturnValue, nil, reportError("fromCcy is required and must be specified")
	}
	if r.toCcy == nil {
		return localVarReturnValue, nil, reportError("toCcy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromCcy", r.fromCcy, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toCcy", r.toCcy, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetConvertHistoryV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	clTReqId *string
	after *string
	before *string
	limit *string
	tag *string
}

// Client Order ID as assigned by the client  A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
func (r ApiGetAssetConvertHistoryV5Request) ClTReqId(clTReqId string) ApiGetAssetConvertHistoryV5Request {
	r.clTReqId = &clTReqId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ts&#x60;, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAssetConvertHistoryV5Request) After(after string) ApiGetAssetConvertHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ts&#x60;, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetAssetConvertHistoryV5Request) Before(before string) ApiGetAssetConvertHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;. The default is &#x60;100&#x60;.
func (r ApiGetAssetConvertHistoryV5Request) Limit(limit string) ApiGetAssetConvertHistoryV5Request {
	r.limit = &limit
	return r
}

// Order tag  Applicable to broker user  If the convert trading used &#x60;tag&#x60;, this parameter is also required.
func (r ApiGetAssetConvertHistoryV5Request) Tag(tag string) ApiGetAssetConvertHistoryV5Request {
	r.tag = &tag
	return r
}

func (r ApiGetAssetConvertHistoryV5Request) Execute() (*GetAssetConvertHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetConvertHistoryV5Execute(r)
}

/*
GetAssetConvertHistoryV5 Get convert history

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetConvertHistoryV5Request
*/
func (a *FundingAccountAPIService) GetAssetConvertHistoryV5(ctx context.Context) ApiGetAssetConvertHistoryV5Request {
	return ApiGetAssetConvertHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetConvertHistoryV5Resp
func (a *FundingAccountAPIService) GetAssetConvertHistoryV5Execute(r ApiGetAssetConvertHistoryV5Request) (*GetAssetConvertHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetConvertHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetConvertHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/convert/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clTReqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clTReqId", r.clTReqId, "form", "")
	} else {
		var defaultValue string = ""
		r.clTReqId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	} else {
		var defaultValue string = ""
		r.tag = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetCurrenciesV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
}

// Single currency or multiple currencies separated with comma, e.g. &#x60;BTC&#x60; or &#x60;BTC,ETH&#x60;.
func (r ApiGetAssetCurrenciesV5Request) Ccy(ccy string) ApiGetAssetCurrenciesV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAssetCurrenciesV5Request) Execute() (*GetAssetCurrenciesV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetCurrenciesV5Execute(r)
}

/*
GetAssetCurrenciesV5 Get currencies

Retrieve a list of all currencies available which are related to the current account's KYC entity.

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetCurrenciesV5Request
*/
func (a *FundingAccountAPIService) GetAssetCurrenciesV5(ctx context.Context) ApiGetAssetCurrenciesV5Request {
	return ApiGetAssetCurrenciesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetCurrenciesV5Resp
func (a *FundingAccountAPIService) GetAssetCurrenciesV5Execute(r ApiGetAssetCurrenciesV5Request) (*GetAssetCurrenciesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetCurrenciesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetCurrenciesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetDepositAddressV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
}

// Currency, e.g. &#x60;BTC&#x60;
func (r ApiGetAssetDepositAddressV5Request) Ccy(ccy string) ApiGetAssetDepositAddressV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAssetDepositAddressV5Request) Execute() (*GetAssetDepositAddressV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetDepositAddressV5Execute(r)
}

/*
GetAssetDepositAddressV5 Get deposit address

Retrieve the deposit addresses of currencies, including previously-used addresses.

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetDepositAddressV5Request
*/
func (a *FundingAccountAPIService) GetAssetDepositAddressV5(ctx context.Context) ApiGetAssetDepositAddressV5Request {
	return ApiGetAssetDepositAddressV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetDepositAddressV5Resp
func (a *FundingAccountAPIService) GetAssetDepositAddressV5Execute(r ApiGetAssetDepositAddressV5Request) (*GetAssetDepositAddressV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetDepositAddressV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetDepositAddressV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/deposit-address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetDepositHistoryV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
	depId *string
	fromWdId *string
	txId *string
	type_ *string
	state *string
	after *string
	before *string
	limit *string
}

// Currency, e.g. &#x60;BTC&#x60;
func (r ApiGetAssetDepositHistoryV5Request) Ccy(ccy string) ApiGetAssetDepositHistoryV5Request {
	r.ccy = &ccy
	return r
}

// Deposit ID
func (r ApiGetAssetDepositHistoryV5Request) DepId(depId string) ApiGetAssetDepositHistoryV5Request {
	r.depId = &depId
	return r
}

// Internal transfer initiator&#39;s withdrawal ID  If the deposit comes from internal transfer, this field displays the withdrawal ID of the internal transfer initiator
func (r ApiGetAssetDepositHistoryV5Request) FromWdId(fromWdId string) ApiGetAssetDepositHistoryV5Request {
	r.fromWdId = &fromWdId
	return r
}

// Hash record of the deposit
func (r ApiGetAssetDepositHistoryV5Request) TxId(txId string) ApiGetAssetDepositHistoryV5Request {
	r.txId = &txId
	return r
}

// Deposit Type  &#x60;3&#x60;: internal transfer  &#x60;4&#x60;: deposit from chain
func (r ApiGetAssetDepositHistoryV5Request) Type_(type_ string) ApiGetAssetDepositHistoryV5Request {
	r.type_ = &type_
	return r
}

// Status of deposit    &#x60;0&#x60;: waiting for confirmation  &#x60;1&#x60;: deposit credited    &#x60;2&#x60;: deposit successful   &#x60;8&#x60;: pending due to temporary deposit suspension on this crypto currency  &#x60;11&#x60;: match the address blacklist  &#x60;12&#x60;: account or deposit is frozen  &#x60;13&#x60;: sub-account deposit interception  &#x60;14&#x60;: KYC limit
func (r ApiGetAssetDepositHistoryV5Request) State(state string) ApiGetAssetDepositHistoryV5Request {
	r.state = &state
	return r
}

// Pagination of data to return records earlier than the requested ts, Unix timestamp format in milliseconds, e.g. &#x60;1654041600000&#x60;
func (r ApiGetAssetDepositHistoryV5Request) After(after string) ApiGetAssetDepositHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested ts, Unix timestamp format in milliseconds, e.g. &#x60;1656633600000&#x60;
func (r ApiGetAssetDepositHistoryV5Request) Before(before string) ApiGetAssetDepositHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetAssetDepositHistoryV5Request) Limit(limit string) ApiGetAssetDepositHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAssetDepositHistoryV5Request) Execute() (*GetAssetDepositHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetDepositHistoryV5Execute(r)
}

/*
GetAssetDepositHistoryV5 Get deposit history

Retrieve the deposit records according to the currency, deposit status, and time range in reverse chronological order. The 100 most recent records are returned by default.


Websocket API is also available, refer to .

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetDepositHistoryV5Request
*/
func (a *FundingAccountAPIService) GetAssetDepositHistoryV5(ctx context.Context) ApiGetAssetDepositHistoryV5Request {
	return ApiGetAssetDepositHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetDepositHistoryV5Resp
func (a *FundingAccountAPIService) GetAssetDepositHistoryV5Execute(r ApiGetAssetDepositHistoryV5Request) (*GetAssetDepositHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetDepositHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetDepositHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/deposit-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.depId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depId", r.depId, "form", "")
	} else {
		var defaultValue string = ""
		r.depId = &defaultValue
	}
	if r.fromWdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromWdId", r.fromWdId, "form", "")
	} else {
		var defaultValue string = ""
		r.fromWdId = &defaultValue
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetDepositWithdrawStatusV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	wdId *string
	txId *string
	ccy *string
	to *string
	chain *string
}

// Withdrawal ID, use to retrieve withdrawal status   Required to input one and only one of &#x60;wdId&#x60; and &#x60;txId&#x60;
func (r ApiGetAssetDepositWithdrawStatusV5Request) WdId(wdId string) ApiGetAssetDepositWithdrawStatusV5Request {
	r.wdId = &wdId
	return r
}

// Hash record of the deposit, use to retrieve deposit status   Required to input one and only one of &#x60;wdId&#x60; and &#x60;txId&#x60;
func (r ApiGetAssetDepositWithdrawStatusV5Request) TxId(txId string) ApiGetAssetDepositWithdrawStatusV5Request {
	r.txId = &txId
	return r
}

// Currency type, e.g. &#x60;USDT&#x60;   Required when retrieving deposit status with &#x60;txId&#x60;
func (r ApiGetAssetDepositWithdrawStatusV5Request) Ccy(ccy string) ApiGetAssetDepositWithdrawStatusV5Request {
	r.ccy = &ccy
	return r
}

// To address, the destination address in deposit   Required when retrieving deposit status with &#x60;txId&#x60;
func (r ApiGetAssetDepositWithdrawStatusV5Request) To(to string) ApiGetAssetDepositWithdrawStatusV5Request {
	r.to = &to
	return r
}

// Currency chain information, e.g. USDT-ERC20   Required when retrieving deposit status with &#x60;txId&#x60;
func (r ApiGetAssetDepositWithdrawStatusV5Request) Chain(chain string) ApiGetAssetDepositWithdrawStatusV5Request {
	r.chain = &chain
	return r
}

func (r ApiGetAssetDepositWithdrawStatusV5Request) Execute() (*GetAssetDepositWithdrawStatusV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetDepositWithdrawStatusV5Execute(r)
}

/*
GetAssetDepositWithdrawStatusV5 Get deposit withdraw status

Retrieve deposit's and withdrawal's detailed status and estimated complete time.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetDepositWithdrawStatusV5Request
*/
func (a *FundingAccountAPIService) GetAssetDepositWithdrawStatusV5(ctx context.Context) ApiGetAssetDepositWithdrawStatusV5Request {
	return ApiGetAssetDepositWithdrawStatusV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetDepositWithdrawStatusV5Resp
func (a *FundingAccountAPIService) GetAssetDepositWithdrawStatusV5Execute(r ApiGetAssetDepositWithdrawStatusV5Request) (*GetAssetDepositWithdrawStatusV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetDepositWithdrawStatusV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetDepositWithdrawStatusV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/deposit-withdraw-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wdId", r.wdId, "form", "")
	} else {
		var defaultValue string = ""
		r.wdId = &defaultValue
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	} else {
		var defaultValue string = ""
		r.to = &defaultValue
	}
	if r.chain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chain", r.chain, "form", "")
	} else {
		var defaultValue string = ""
		r.chain = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetExchangeListV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
}

func (r ApiGetAssetExchangeListV5Request) Execute() (*GetAssetExchangeListV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetExchangeListV5Execute(r)
}

/*
GetAssetExchangeListV5 Get exchange list (public)

Authentication is not required for this public endpoint.

#### Rate Limit: 6 requests per second 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetExchangeListV5Request
*/
func (a *FundingAccountAPIService) GetAssetExchangeListV5(ctx context.Context) ApiGetAssetExchangeListV5Request {
	return ApiGetAssetExchangeListV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetExchangeListV5Resp
func (a *FundingAccountAPIService) GetAssetExchangeListV5Execute(r ApiGetAssetExchangeListV5Request) (*GetAssetExchangeListV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetExchangeListV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetExchangeListV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/exchange-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetMonthlyStatementV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	month *string
}

// Month, valid value is &#x60;Jan&#x60;, &#x60;Feb&#x60;, &#x60;Mar&#x60;, &#x60;Apr&#x60;,&#x60;May&#x60;, &#x60;Jun&#x60;, &#x60;Jul&#x60;,&#x60;Aug&#x60;, &#x60;Sep&#x60;,&#x60;Oct&#x60;,&#x60;Nov&#x60;,&#x60;Dec&#x60;
func (r ApiGetAssetMonthlyStatementV5Request) Month(month string) ApiGetAssetMonthlyStatementV5Request {
	r.month = &month
	return r
}

func (r ApiGetAssetMonthlyStatementV5Request) Execute() (*GetAssetMonthlyStatementV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetMonthlyStatementV5Execute(r)
}

/*
GetAssetMonthlyStatementV5 Get monthly statement (last year)

Retrieve monthly statement in the past year.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetMonthlyStatementV5Request
*/
func (a *FundingAccountAPIService) GetAssetMonthlyStatementV5(ctx context.Context) ApiGetAssetMonthlyStatementV5Request {
	return ApiGetAssetMonthlyStatementV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetMonthlyStatementV5Resp
func (a *FundingAccountAPIService) GetAssetMonthlyStatementV5Execute(r ApiGetAssetMonthlyStatementV5Request) (*GetAssetMonthlyStatementV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetMonthlyStatementV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetMonthlyStatementV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/monthly-statement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.month == nil {
		return localVarReturnValue, nil, reportError("month is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "month", r.month, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetNonTradableAssetsV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
}

// Single currency or multiple currencies (no more than 20) separated with comma, e.g. &#x60;BTC&#x60; or &#x60;BTC,ETH&#x60;.
func (r ApiGetAssetNonTradableAssetsV5Request) Ccy(ccy string) ApiGetAssetNonTradableAssetsV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetAssetNonTradableAssetsV5Request) Execute() (*GetAssetNonTradableAssetsV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetNonTradableAssetsV5Execute(r)
}

/*
GetAssetNonTradableAssetsV5 Get non-tradable assets

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetNonTradableAssetsV5Request
*/
func (a *FundingAccountAPIService) GetAssetNonTradableAssetsV5(ctx context.Context) ApiGetAssetNonTradableAssetsV5Request {
	return ApiGetAssetNonTradableAssetsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetNonTradableAssetsV5Resp
func (a *FundingAccountAPIService) GetAssetNonTradableAssetsV5Execute(r ApiGetAssetNonTradableAssetsV5Request) (*GetAssetNonTradableAssetsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetNonTradableAssetsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetNonTradableAssetsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/non-tradable-assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetTransferStateV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	transId *string
	clientId *string
	type_ *string
}

// Transfer ID  Either transId or clientId is required. If both are passed, transId will be used.
func (r ApiGetAssetTransferStateV5Request) TransId(transId string) ApiGetAssetTransferStateV5Request {
	r.transId = &transId
	return r
}

// Client-supplied ID  A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
func (r ApiGetAssetTransferStateV5Request) ClientId(clientId string) ApiGetAssetTransferStateV5Request {
	r.clientId = &clientId
	return r
}

// Transfer type  &#x60;0&#x60;: transfer within account   &#x60;1&#x60;: master account to sub-account (Only applicable to API Key from master account)   &#x60;2&#x60;: sub-account to master account (Only applicable to API Key from master account)  &#x60;3&#x60;: sub-account to master account (Only applicable to APIKey from sub-account)  &#x60;4&#x60;: sub-account to sub-account (Only applicable to APIKey from sub-account, and target account needs to be another sub-account which belongs to same master account)  The default is &#x60;0&#x60;.  For Custody accounts, can choose not to pass this parameter or pass &#x60;0&#x60;.
func (r ApiGetAssetTransferStateV5Request) Type_(type_ string) ApiGetAssetTransferStateV5Request {
	r.type_ = &type_
	return r
}

func (r ApiGetAssetTransferStateV5Request) Execute() (*GetAssetTransferStateV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetTransferStateV5Execute(r)
}

/*
GetAssetTransferStateV5 Get funds transfer state

Retrieve the transfer state data of the last 2 weeks.

#### Rate Limit: 10 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetTransferStateV5Request
*/
func (a *FundingAccountAPIService) GetAssetTransferStateV5(ctx context.Context) ApiGetAssetTransferStateV5Request {
	return ApiGetAssetTransferStateV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetTransferStateV5Resp
func (a *FundingAccountAPIService) GetAssetTransferStateV5Execute(r ApiGetAssetTransferStateV5Request) (*GetAssetTransferStateV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetTransferStateV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetTransferStateV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/transfer-state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transId", r.transId, "form", "")
	} else {
		var defaultValue string = ""
		r.transId = &defaultValue
	}
	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientId", r.clientId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientId = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetWithdrawalHistoryV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
	wdId *string
	clientId *string
	txId *string
	type_ *string
	state *string
	after *string
	before *string
	limit *string
}

// Currency, e.g. &#x60;BTC&#x60;
func (r ApiGetAssetWithdrawalHistoryV5Request) Ccy(ccy string) ApiGetAssetWithdrawalHistoryV5Request {
	r.ccy = &ccy
	return r
}

// Withdrawal ID
func (r ApiGetAssetWithdrawalHistoryV5Request) WdId(wdId string) ApiGetAssetWithdrawalHistoryV5Request {
	r.wdId = &wdId
	return r
}

// Client-supplied ID  A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
func (r ApiGetAssetWithdrawalHistoryV5Request) ClientId(clientId string) ApiGetAssetWithdrawalHistoryV5Request {
	r.clientId = &clientId
	return r
}

// Hash record of the deposit
func (r ApiGetAssetWithdrawalHistoryV5Request) TxId(txId string) ApiGetAssetWithdrawalHistoryV5Request {
	r.txId = &txId
	return r
}

// Withdrawal type  &#x60;3&#x60;: Internal transfer  &#x60;4&#x60;: On-chain withdrawal
func (r ApiGetAssetWithdrawalHistoryV5Request) Type_(type_ string) ApiGetAssetWithdrawalHistoryV5Request {
	r.type_ = &type_
	return r
}

// Status of withdrawal    &#x60;17&#x60;: Pending response from Travel Rule vendor  &#x60;10&#x60;: Waiting transfer  &#x60;0&#x60;: Waiting withdrawal  &#x60;4&#x60;/&#x60;5&#x60;/&#x60;6&#x60;/&#x60;8&#x60;/&#x60;9&#x60;/&#x60;12&#x60;: Waiting manual review  &#x60;7&#x60;: Approved    &#x60;1&#x60;: Broadcasting your transaction to chain  &#x60;15&#x60;: Pending transaction validation  &#x60;16&#x60;: Due to local laws and regulations, your withdrawal may take up to 24 hours to arrive  &#x60;-3&#x60;: Canceling     &#x60;-2&#x60;: Canceled   &#x60;-1&#x60;: Failed  &#x60;2&#x60;: Success
func (r ApiGetAssetWithdrawalHistoryV5Request) State(state string) ApiGetAssetWithdrawalHistoryV5Request {
	r.state = &state
	return r
}

// Pagination of data to return records earlier than the requested ts, Unix timestamp format in milliseconds, e.g. &#x60;1654041600000&#x60;
func (r ApiGetAssetWithdrawalHistoryV5Request) After(after string) ApiGetAssetWithdrawalHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested ts, Unix timestamp format in milliseconds, e.g. &#x60;1656633600000&#x60;
func (r ApiGetAssetWithdrawalHistoryV5Request) Before(before string) ApiGetAssetWithdrawalHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetAssetWithdrawalHistoryV5Request) Limit(limit string) ApiGetAssetWithdrawalHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetAssetWithdrawalHistoryV5Request) Execute() (*GetAssetWithdrawalHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetAssetWithdrawalHistoryV5Execute(r)
}

/*
GetAssetWithdrawalHistoryV5 Get withdrawal history

Retrieve the withdrawal records according to the currency, withdrawal status, and time range in reverse chronological order. The 100 most recent records are returned by default.


Websocket API is also available, refer to .

#### Rate Limit: 6 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetWithdrawalHistoryV5Request
*/
func (a *FundingAccountAPIService) GetAssetWithdrawalHistoryV5(ctx context.Context) ApiGetAssetWithdrawalHistoryV5Request {
	return ApiGetAssetWithdrawalHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetWithdrawalHistoryV5Resp
func (a *FundingAccountAPIService) GetAssetWithdrawalHistoryV5Execute(r ApiGetAssetWithdrawalHistoryV5Request) (*GetAssetWithdrawalHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetWithdrawalHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetAssetWithdrawalHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/asset/withdrawal-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.wdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wdId", r.wdId, "form", "")
	} else {
		var defaultValue string = ""
		r.wdId = &defaultValue
	}
	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientId", r.clientId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientId = &defaultValue
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiatDepositOrderHistoryV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
	paymentMethod *string
	state *string
	after *string
	before *string
	limit *string
}

// ISO-4217 3 digit currency code
func (r ApiGetFiatDepositOrderHistoryV5Request) Ccy(ccy string) ApiGetFiatDepositOrderHistoryV5Request {
	r.ccy = &ccy
	return r
}

// Payment Method  &#x60;TR_BANKS&#x60;  &#x60;PIX&#x60;  &#x60;SEPA&#x60;
func (r ApiGetFiatDepositOrderHistoryV5Request) PaymentMethod(paymentMethod string) ApiGetFiatDepositOrderHistoryV5Request {
	r.paymentMethod = &paymentMethod
	return r
}

// State of the order  &#x60;completed&#x60;  &#x60;failed&#x60;  &#x60;pending&#x60;  &#x60;canceled&#x60;  &#x60;inqueue&#x60;  &#x60;processing&#x60;
func (r ApiGetFiatDepositOrderHistoryV5Request) State(state string) ApiGetFiatDepositOrderHistoryV5Request {
	r.state = &state
	return r
}

// Filter with a begin timestamp. Unix timestamp format in milliseconds (inclusive), e.g. &#x60;1597026383085&#x60;
func (r ApiGetFiatDepositOrderHistoryV5Request) After(after string) ApiGetFiatDepositOrderHistoryV5Request {
	r.after = &after
	return r
}

// Filter with an end timestamp. Unix timestamp format in milliseconds (inclusive), e.g. &#x60;1597026383085&#x60;
func (r ApiGetFiatDepositOrderHistoryV5Request) Before(before string) ApiGetFiatDepositOrderHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. Maximum and default is 100
func (r ApiGetFiatDepositOrderHistoryV5Request) Limit(limit string) ApiGetFiatDepositOrderHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetFiatDepositOrderHistoryV5Request) Execute() (*GetFiatDepositOrderHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetFiatDepositOrderHistoryV5Execute(r)
}

/*
GetFiatDepositOrderHistoryV5 Get deposit order history

Get fiat deposit order history

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFiatDepositOrderHistoryV5Request
*/
func (a *FundingAccountAPIService) GetFiatDepositOrderHistoryV5(ctx context.Context) ApiGetFiatDepositOrderHistoryV5Request {
	return ApiGetFiatDepositOrderHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFiatDepositOrderHistoryV5Resp
func (a *FundingAccountAPIService) GetFiatDepositOrderHistoryV5Execute(r ApiGetFiatDepositOrderHistoryV5Request) (*GetFiatDepositOrderHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFiatDepositOrderHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetFiatDepositOrderHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/deposit-order-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "form", "")
	} else {
		var defaultValue string = ""
		r.paymentMethod = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiatDepositPaymentMethodsV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
}

// Fiat currency, ISO-4217 3 digit currency code, e.g. &#x60;TRY&#x60;
func (r ApiGetFiatDepositPaymentMethodsV5Request) Ccy(ccy string) ApiGetFiatDepositPaymentMethodsV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetFiatDepositPaymentMethodsV5Request) Execute() (*GetFiatDepositPaymentMethodsV5Resp, *http.Response, error) {
	return r.ApiService.GetFiatDepositPaymentMethodsV5Execute(r)
}

/*
GetFiatDepositPaymentMethodsV5 Get deposit payment methods

To display all the available fiat deposit payment methods

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFiatDepositPaymentMethodsV5Request
*/
func (a *FundingAccountAPIService) GetFiatDepositPaymentMethodsV5(ctx context.Context) ApiGetFiatDepositPaymentMethodsV5Request {
	return ApiGetFiatDepositPaymentMethodsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFiatDepositPaymentMethodsV5Resp
func (a *FundingAccountAPIService) GetFiatDepositPaymentMethodsV5Execute(r ApiGetFiatDepositPaymentMethodsV5Request) (*GetFiatDepositPaymentMethodsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFiatDepositPaymentMethodsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetFiatDepositPaymentMethodsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/deposit-payment-methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiatDepositV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ordId *string
}

// Order ID
func (r ApiGetFiatDepositV5Request) OrdId(ordId string) ApiGetFiatDepositV5Request {
	r.ordId = &ordId
	return r
}

func (r ApiGetFiatDepositV5Request) Execute() (*GetFiatDepositV5Resp, *http.Response, error) {
	return r.ApiService.GetFiatDepositV5Execute(r)
}

/*
GetFiatDepositV5 Get deposit order detail

Get fiat deposit order detail

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFiatDepositV5Request
*/
func (a *FundingAccountAPIService) GetFiatDepositV5(ctx context.Context) ApiGetFiatDepositV5Request {
	return ApiGetFiatDepositV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFiatDepositV5Resp
func (a *FundingAccountAPIService) GetFiatDepositV5Execute(r ApiGetFiatDepositV5Request) (*GetFiatDepositV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFiatDepositV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetFiatDepositV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/deposit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ordId == nil {
		return localVarReturnValue, nil, reportError("ordId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ordId", r.ordId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiatWithdrawalOrderHistoryV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
	paymentMethod *string
	state *string
	after *string
	before *string
	limit *string
}

// Fiat currency, ISO-4217 3 digit currency code, e.g. &#x60;TRY&#x60;
func (r ApiGetFiatWithdrawalOrderHistoryV5Request) Ccy(ccy string) ApiGetFiatWithdrawalOrderHistoryV5Request {
	r.ccy = &ccy
	return r
}

// Payment Method  &#x60;TR_BANKS&#x60;  &#x60;PIX&#x60;  &#x60;SEPA&#x60;
func (r ApiGetFiatWithdrawalOrderHistoryV5Request) PaymentMethod(paymentMethod string) ApiGetFiatWithdrawalOrderHistoryV5Request {
	r.paymentMethod = &paymentMethod
	return r
}

// State of the order  &#x60;completed&#x60;  &#x60;failed&#x60;  &#x60;pending&#x60;  &#x60;canceled&#x60;  &#x60;inqueue&#x60;  &#x60;processing&#x60;
func (r ApiGetFiatWithdrawalOrderHistoryV5Request) State(state string) ApiGetFiatWithdrawalOrderHistoryV5Request {
	r.state = &state
	return r
}

// Filter with a begin timestamp. Unix timestamp format in milliseconds (inclusive), e.g. &#x60;1597026383085&#x60;
func (r ApiGetFiatWithdrawalOrderHistoryV5Request) After(after string) ApiGetFiatWithdrawalOrderHistoryV5Request {
	r.after = &after
	return r
}

// Filter with an end timestamp. Unix timestamp format in milliseconds (inclusive), e.g. &#x60;1597026383085&#x60;
func (r ApiGetFiatWithdrawalOrderHistoryV5Request) Before(before string) ApiGetFiatWithdrawalOrderHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. Maximum and default is &#x60;100&#x60;
func (r ApiGetFiatWithdrawalOrderHistoryV5Request) Limit(limit string) ApiGetFiatWithdrawalOrderHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetFiatWithdrawalOrderHistoryV5Request) Execute() (*GetFiatWithdrawalOrderHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetFiatWithdrawalOrderHistoryV5Execute(r)
}

/*
GetFiatWithdrawalOrderHistoryV5 Get withdrawal order history

Get fiat withdrawal order history

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFiatWithdrawalOrderHistoryV5Request
*/
func (a *FundingAccountAPIService) GetFiatWithdrawalOrderHistoryV5(ctx context.Context) ApiGetFiatWithdrawalOrderHistoryV5Request {
	return ApiGetFiatWithdrawalOrderHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFiatWithdrawalOrderHistoryV5Resp
func (a *FundingAccountAPIService) GetFiatWithdrawalOrderHistoryV5Execute(r ApiGetFiatWithdrawalOrderHistoryV5Request) (*GetFiatWithdrawalOrderHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFiatWithdrawalOrderHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetFiatWithdrawalOrderHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/withdrawal-order-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ccy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	} else {
		var defaultValue string = ""
		r.ccy = &defaultValue
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "form", "")
	} else {
		var defaultValue string = ""
		r.paymentMethod = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiatWithdrawalPaymentMethodsV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ccy *string
}

// Fiat currency, ISO-4217 3 digit currency code. e.g. &#x60;TRY&#x60;
func (r ApiGetFiatWithdrawalPaymentMethodsV5Request) Ccy(ccy string) ApiGetFiatWithdrawalPaymentMethodsV5Request {
	r.ccy = &ccy
	return r
}

func (r ApiGetFiatWithdrawalPaymentMethodsV5Request) Execute() (*GetFiatWithdrawalPaymentMethodsV5Resp, *http.Response, error) {
	return r.ApiService.GetFiatWithdrawalPaymentMethodsV5Execute(r)
}

/*
GetFiatWithdrawalPaymentMethodsV5 Get withdrawal payment methods

To display all the available fiat withdrawal payment methods

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFiatWithdrawalPaymentMethodsV5Request
*/
func (a *FundingAccountAPIService) GetFiatWithdrawalPaymentMethodsV5(ctx context.Context) ApiGetFiatWithdrawalPaymentMethodsV5Request {
	return ApiGetFiatWithdrawalPaymentMethodsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFiatWithdrawalPaymentMethodsV5Resp
func (a *FundingAccountAPIService) GetFiatWithdrawalPaymentMethodsV5Execute(r ApiGetFiatWithdrawalPaymentMethodsV5Request) (*GetFiatWithdrawalPaymentMethodsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFiatWithdrawalPaymentMethodsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetFiatWithdrawalPaymentMethodsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/withdrawal-payment-methods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFiatWithdrawalV5Request struct {
	ctx context.Context
	ApiService *FundingAccountAPIService
	ordId *string
}

// Order ID
func (r ApiGetFiatWithdrawalV5Request) OrdId(ordId string) ApiGetFiatWithdrawalV5Request {
	r.ordId = &ordId
	return r
}

func (r ApiGetFiatWithdrawalV5Request) Execute() (*GetFiatWithdrawalV5Resp, *http.Response, error) {
	return r.ApiService.GetFiatWithdrawalV5Execute(r)
}

/*
GetFiatWithdrawalV5 Get withdrawal order detail

Get fiat withdraw order detail

#### Rate Limit: 3 requests per second 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFiatWithdrawalV5Request
*/
func (a *FundingAccountAPIService) GetFiatWithdrawalV5(ctx context.Context) ApiGetFiatWithdrawalV5Request {
	return ApiGetFiatWithdrawalV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFiatWithdrawalV5Resp
func (a *FundingAccountAPIService) GetFiatWithdrawalV5Execute(r ApiGetFiatWithdrawalV5Request) (*GetFiatWithdrawalV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFiatWithdrawalV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundingAccountAPIService.GetFiatWithdrawalV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/fiat/withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ordId == nil {
		return localVarReturnValue, nil, reportError("ordId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ordId", r.ordId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
