/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"fmt"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CopyTradingAPIService CopyTradingAPI service
type CopyTradingAPIService service

type ApiCreateCopytradingAlgoOrderV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	createCopytradingAlgoOrderV5Req *CreateCopytradingAlgoOrderV5Req
}

// The request body for CreateCopytradingAlgoOrderV5
func (r ApiCreateCopytradingAlgoOrderV5Request) CreateCopytradingAlgoOrderV5Req(createCopytradingAlgoOrderV5Req CreateCopytradingAlgoOrderV5Req) ApiCreateCopytradingAlgoOrderV5Request {
	r.createCopytradingAlgoOrderV5Req = &createCopytradingAlgoOrderV5Req
	return r
}

func (r ApiCreateCopytradingAlgoOrderV5Request) Execute() (*CreateCopytradingAlgoOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateCopytradingAlgoOrderV5Execute(r)
}

/*
CreateCopytradingAlgoOrderV5 Set TP/SL for the current lead position that are not closed.  

Set TP/SL for the current lead position that are not closed.

#### Rate limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCopytradingAlgoOrderV5Request
*/
func (a *CopyTradingAPIService) CreateCopytradingAlgoOrderV5(ctx context.Context) ApiCreateCopytradingAlgoOrderV5Request {
	return ApiCreateCopytradingAlgoOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCopytradingAlgoOrderV5Resp
func (a *CopyTradingAPIService) CreateCopytradingAlgoOrderV5Execute(r ApiCreateCopytradingAlgoOrderV5Request) (*CreateCopytradingAlgoOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCopytradingAlgoOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.CreateCopytradingAlgoOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/algo-order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCopytradingAlgoOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createCopytradingAlgoOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCopytradingAlgoOrderV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCopytradingAmendCopySettingsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	createCopytradingAmendCopySettingsV5Req *CreateCopytradingAmendCopySettingsV5Req
}

// The request body for CreateCopytradingAmendCopySettingsV5
func (r ApiCreateCopytradingAmendCopySettingsV5Request) CreateCopytradingAmendCopySettingsV5Req(createCopytradingAmendCopySettingsV5Req CreateCopytradingAmendCopySettingsV5Req) ApiCreateCopytradingAmendCopySettingsV5Request {
	r.createCopytradingAmendCopySettingsV5Req = &createCopytradingAmendCopySettingsV5Req
	return r
}

func (r ApiCreateCopytradingAmendCopySettingsV5Request) Execute() (*CreateCopytradingAmendCopySettingsV5Resp, *http.Response, error) {
	return r.ApiService.CreateCopytradingAmendCopySettingsV5Execute(r)
}

/*
CreateCopytradingAmendCopySettingsV5 You need to use this endpoint to amend copy settings  

You need to use this endpoint to amend copy settings

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCopytradingAmendCopySettingsV5Request
*/
func (a *CopyTradingAPIService) CreateCopytradingAmendCopySettingsV5(ctx context.Context) ApiCreateCopytradingAmendCopySettingsV5Request {
	return ApiCreateCopytradingAmendCopySettingsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCopytradingAmendCopySettingsV5Resp
func (a *CopyTradingAPIService) CreateCopytradingAmendCopySettingsV5Execute(r ApiCreateCopytradingAmendCopySettingsV5Request) (*CreateCopytradingAmendCopySettingsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCopytradingAmendCopySettingsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.CreateCopytradingAmendCopySettingsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/amend-copy-settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCopytradingAmendCopySettingsV5Req == nil {
		return localVarReturnValue, nil, reportError("createCopytradingAmendCopySettingsV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCopytradingAmendCopySettingsV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCopytradingAmendProfitSharingRatioV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	createCopytradingAmendProfitSharingRatioV5Req *CreateCopytradingAmendProfitSharingRatioV5Req
}

// The request body for CreateCopytradingAmendProfitSharingRatioV5
func (r ApiCreateCopytradingAmendProfitSharingRatioV5Request) CreateCopytradingAmendProfitSharingRatioV5Req(createCopytradingAmendProfitSharingRatioV5Req CreateCopytradingAmendProfitSharingRatioV5Req) ApiCreateCopytradingAmendProfitSharingRatioV5Request {
	r.createCopytradingAmendProfitSharingRatioV5Req = &createCopytradingAmendProfitSharingRatioV5Req
	return r
}

func (r ApiCreateCopytradingAmendProfitSharingRatioV5Request) Execute() (*CreateCopytradingAmendProfitSharingRatioV5Resp, *http.Response, error) {
	return r.ApiService.CreateCopytradingAmendProfitSharingRatioV5Execute(r)
}

/*
CreateCopytradingAmendProfitSharingRatioV5 It is used to amend profit sharing ratio.   

It is used to amend profit sharing ratio. 

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCopytradingAmendProfitSharingRatioV5Request
*/
func (a *CopyTradingAPIService) CreateCopytradingAmendProfitSharingRatioV5(ctx context.Context) ApiCreateCopytradingAmendProfitSharingRatioV5Request {
	return ApiCreateCopytradingAmendProfitSharingRatioV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCopytradingAmendProfitSharingRatioV5Resp
func (a *CopyTradingAPIService) CreateCopytradingAmendProfitSharingRatioV5Execute(r ApiCreateCopytradingAmendProfitSharingRatioV5Request) (*CreateCopytradingAmendProfitSharingRatioV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCopytradingAmendProfitSharingRatioV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.CreateCopytradingAmendProfitSharingRatioV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/amend-profit-sharing-ratio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCopytradingAmendProfitSharingRatioV5Req == nil {
		return localVarReturnValue, nil, reportError("createCopytradingAmendProfitSharingRatioV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCopytradingAmendProfitSharingRatioV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCopytradingCloseSubpositionV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	createCopytradingCloseSubpositionV5Req *CreateCopytradingCloseSubpositionV5Req
}

// The request body for CreateCopytradingCloseSubpositionV5
func (r ApiCreateCopytradingCloseSubpositionV5Request) CreateCopytradingCloseSubpositionV5Req(createCopytradingCloseSubpositionV5Req CreateCopytradingCloseSubpositionV5Req) ApiCreateCopytradingCloseSubpositionV5Request {
	r.createCopytradingCloseSubpositionV5Req = &createCopytradingCloseSubpositionV5Req
	return r
}

func (r ApiCreateCopytradingCloseSubpositionV5Request) Execute() (*CreateCopytradingCloseSubpositionV5Resp, *http.Response, error) {
	return r.ApiService.CreateCopytradingCloseSubpositionV5Execute(r)
}

/*
CreateCopytradingCloseSubpositionV5 You can only close a lead position once a time.    It is required to pass subPosId which can get from .  

You can only close a lead position once a time. 


It is required to pass subPosId which can get from .

#### Rate limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCopytradingCloseSubpositionV5Request
*/
func (a *CopyTradingAPIService) CreateCopytradingCloseSubpositionV5(ctx context.Context) ApiCreateCopytradingCloseSubpositionV5Request {
	return ApiCreateCopytradingCloseSubpositionV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCopytradingCloseSubpositionV5Resp
func (a *CopyTradingAPIService) CreateCopytradingCloseSubpositionV5Execute(r ApiCreateCopytradingCloseSubpositionV5Request) (*CreateCopytradingCloseSubpositionV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCopytradingCloseSubpositionV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.CreateCopytradingCloseSubpositionV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/close-subposition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCopytradingCloseSubpositionV5Req == nil {
		return localVarReturnValue, nil, reportError("createCopytradingCloseSubpositionV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCopytradingCloseSubpositionV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCopytradingFirstCopySettingsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	createCopytradingFirstCopySettingsV5Req *CreateCopytradingFirstCopySettingsV5Req
}

// The request body for CreateCopytradingFirstCopySettingsV5
func (r ApiCreateCopytradingFirstCopySettingsV5Request) CreateCopytradingFirstCopySettingsV5Req(createCopytradingFirstCopySettingsV5Req CreateCopytradingFirstCopySettingsV5Req) ApiCreateCopytradingFirstCopySettingsV5Request {
	r.createCopytradingFirstCopySettingsV5Req = &createCopytradingFirstCopySettingsV5Req
	return r
}

func (r ApiCreateCopytradingFirstCopySettingsV5Request) Execute() (*CreateCopytradingFirstCopySettingsV5Resp, *http.Response, error) {
	return r.ApiService.CreateCopytradingFirstCopySettingsV5Execute(r)
}

/*
CreateCopytradingFirstCopySettingsV5 The first copy settings for the certain lead trader. You need to first copy settings after stopping copying.  

The first copy settings for the certain lead trader. You need to first copy settings after stopping copying.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCopytradingFirstCopySettingsV5Request
*/
func (a *CopyTradingAPIService) CreateCopytradingFirstCopySettingsV5(ctx context.Context) ApiCreateCopytradingFirstCopySettingsV5Request {
	return ApiCreateCopytradingFirstCopySettingsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCopytradingFirstCopySettingsV5Resp
func (a *CopyTradingAPIService) CreateCopytradingFirstCopySettingsV5Execute(r ApiCreateCopytradingFirstCopySettingsV5Request) (*CreateCopytradingFirstCopySettingsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCopytradingFirstCopySettingsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.CreateCopytradingFirstCopySettingsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/first-copy-settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCopytradingFirstCopySettingsV5Req == nil {
		return localVarReturnValue, nil, reportError("createCopytradingFirstCopySettingsV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCopytradingFirstCopySettingsV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCopytradingSetInstrumentsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	createCopytradingSetInstrumentsV5Req *CreateCopytradingSetInstrumentsV5Req
}

// The request body for CreateCopytradingSetInstrumentsV5
func (r ApiCreateCopytradingSetInstrumentsV5Request) CreateCopytradingSetInstrumentsV5Req(createCopytradingSetInstrumentsV5Req CreateCopytradingSetInstrumentsV5Req) ApiCreateCopytradingSetInstrumentsV5Request {
	r.createCopytradingSetInstrumentsV5Req = &createCopytradingSetInstrumentsV5Req
	return r
}

func (r ApiCreateCopytradingSetInstrumentsV5Request) Execute() (*CreateCopytradingSetInstrumentsV5Resp, *http.Response, error) {
	return r.ApiService.CreateCopytradingSetInstrumentsV5Execute(r)
}

/*
CreateCopytradingSetInstrumentsV5 The leading trader can amend current leading instruments, need to set initial leading instruments while applying to become a leading trader.   All non-leading instruments can't have position or pending orders for the current request when setting non-leading instruments as leading instruments.  

The leading trader can amend current leading instruments, need to set initial leading instruments while applying to become a leading trader.


All non-leading instruments can't have position or pending orders for the current request when setting non-leading instruments as leading instruments.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCopytradingSetInstrumentsV5Request
*/
func (a *CopyTradingAPIService) CreateCopytradingSetInstrumentsV5(ctx context.Context) ApiCreateCopytradingSetInstrumentsV5Request {
	return ApiCreateCopytradingSetInstrumentsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCopytradingSetInstrumentsV5Resp
func (a *CopyTradingAPIService) CreateCopytradingSetInstrumentsV5Execute(r ApiCreateCopytradingSetInstrumentsV5Request) (*CreateCopytradingSetInstrumentsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCopytradingSetInstrumentsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.CreateCopytradingSetInstrumentsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/set-instruments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCopytradingSetInstrumentsV5Req == nil {
		return localVarReturnValue, nil, reportError("createCopytradingSetInstrumentsV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCopytradingSetInstrumentsV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCopytradingStopCopyTradingV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	createCopytradingStopCopyTradingV5Req *CreateCopytradingStopCopyTradingV5Req
}

// The request body for CreateCopytradingStopCopyTradingV5
func (r ApiCreateCopytradingStopCopyTradingV5Request) CreateCopytradingStopCopyTradingV5Req(createCopytradingStopCopyTradingV5Req CreateCopytradingStopCopyTradingV5Req) ApiCreateCopytradingStopCopyTradingV5Request {
	r.createCopytradingStopCopyTradingV5Req = &createCopytradingStopCopyTradingV5Req
	return r
}

func (r ApiCreateCopytradingStopCopyTradingV5Request) Execute() (*CreateCopytradingStopCopyTradingV5Resp, *http.Response, error) {
	return r.ApiService.CreateCopytradingStopCopyTradingV5Execute(r)
}

/*
CreateCopytradingStopCopyTradingV5 You need to use this endpoint to stop copy trading  

You need to use this endpoint to stop copy trading

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCopytradingStopCopyTradingV5Request
*/
func (a *CopyTradingAPIService) CreateCopytradingStopCopyTradingV5(ctx context.Context) ApiCreateCopytradingStopCopyTradingV5Request {
	return ApiCreateCopytradingStopCopyTradingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCopytradingStopCopyTradingV5Resp
func (a *CopyTradingAPIService) CreateCopytradingStopCopyTradingV5Execute(r ApiCreateCopytradingStopCopyTradingV5Request) (*CreateCopytradingStopCopyTradingV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCopytradingStopCopyTradingV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.CreateCopytradingStopCopyTradingV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/stop-copy-trading"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCopytradingStopCopyTradingV5Req == nil {
		return localVarReturnValue, nil, reportError("createCopytradingStopCopyTradingV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCopytradingStopCopyTradingV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingConfigV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
}

func (r ApiGetCopytradingConfigV5Request) Execute() (*GetCopytradingConfigV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingConfigV5Execute(r)
}

/*
GetCopytradingConfigV5 Retrieve current account configuration related to copy/lead trading.  

Retrieve current account configuration related to copy/lead trading.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingConfigV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingConfigV5(ctx context.Context) ApiGetCopytradingConfigV5Request {
	return ApiGetCopytradingConfigV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingConfigV5Resp
func (a *CopyTradingAPIService) GetCopytradingConfigV5Execute(r ApiGetCopytradingConfigV5Request) (*GetCopytradingConfigV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingConfigV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingConfigV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingCopySettingsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	instType *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingCopySettingsV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingCopySettingsV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Instrument type  &#x60;SWAP&#x60;
func (r ApiGetCopytradingCopySettingsV5Request) InstType(instType string) ApiGetCopytradingCopySettingsV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingCopySettingsV5Request) Execute() (*GetCopytradingCopySettingsV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingCopySettingsV5Execute(r)
}

/*
GetCopytradingCopySettingsV5 Retrieve the copy settings about certain lead trader.  

Retrieve the copy settings about certain lead trader.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingCopySettingsV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingCopySettingsV5(ctx context.Context) ApiGetCopytradingCopySettingsV5Request {
	return ApiGetCopytradingCopySettingsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingCopySettingsV5Resp
func (a *CopyTradingAPIService) GetCopytradingCopySettingsV5Execute(r ApiGetCopytradingCopySettingsV5Request) (*GetCopytradingCopySettingsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingCopySettingsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingCopySettingsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/copy-settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingCurrentLeadTradersV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingCurrentLeadTradersV5Request) InstType(instType string) ApiGetCopytradingCurrentLeadTradersV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingCurrentLeadTradersV5Request) Execute() (*GetCopytradingCurrentLeadTradersV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingCurrentLeadTradersV5Execute(r)
}

/*
GetCopytradingCurrentLeadTradersV5 Retrieve my lead traders.  

Retrieve my lead traders.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingCurrentLeadTradersV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingCurrentLeadTradersV5(ctx context.Context) ApiGetCopytradingCurrentLeadTradersV5Request {
	return ApiGetCopytradingCurrentLeadTradersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingCurrentLeadTradersV5Resp
func (a *CopyTradingAPIService) GetCopytradingCurrentLeadTradersV5Execute(r ApiGetCopytradingCurrentLeadTradersV5Request) (*GetCopytradingCurrentLeadTradersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingCurrentLeadTradersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingCurrentLeadTradersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/current-lead-traders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingCurrentSubpositionsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
	instId *string
	after *string
	before *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  It returns all types by default.
func (r ApiGetCopytradingCurrentSubpositionsV5Request) InstType(instType string) ApiGetCopytradingCurrentSubpositionsV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. BTC-USDT-SWAP
func (r ApiGetCopytradingCurrentSubpositionsV5Request) InstId(instId string) ApiGetCopytradingCurrentSubpositionsV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingCurrentSubpositionsV5Request) After(after string) ApiGetCopytradingCurrentSubpositionsV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingCurrentSubpositionsV5Request) Before(before string) ApiGetCopytradingCurrentSubpositionsV5Request {
	r.before = &before
	return r
}

// Number of results per request. Maximum is 500. Default is 500.
func (r ApiGetCopytradingCurrentSubpositionsV5Request) Limit(limit string) ApiGetCopytradingCurrentSubpositionsV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetCopytradingCurrentSubpositionsV5Request) Execute() (*GetCopytradingCurrentSubpositionsV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingCurrentSubpositionsV5Execute(r)
}

/*
GetCopytradingCurrentSubpositionsV5 Retrieve lead positions that are not closed.    Returns reverse chronological order with `openTime`  

Retrieve lead positions that are not closed.



Returns reverse chronological order with `openTime`

#### Rate limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingCurrentSubpositionsV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingCurrentSubpositionsV5(ctx context.Context) ApiGetCopytradingCurrentSubpositionsV5Request {
	return ApiGetCopytradingCurrentSubpositionsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingCurrentSubpositionsV5Resp
func (a *CopyTradingAPIService) GetCopytradingCurrentSubpositionsV5Execute(r ApiGetCopytradingCurrentSubpositionsV5Request) (*GetCopytradingCurrentSubpositionsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingCurrentSubpositionsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingCurrentSubpositionsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/current-subpositions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingInstrumentsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingInstrumentsV5Request) InstType(instType string) ApiGetCopytradingInstrumentsV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingInstrumentsV5Request) Execute() (*GetCopytradingInstrumentsV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingInstrumentsV5Execute(r)
}

/*
GetCopytradingInstrumentsV5 Retrieve instruments that are supported to lead by the platform.  Retrieve instruments that the lead trader has set.  

Retrieve instruments that are supported to lead by the platform. 
Retrieve instruments that the lead trader has set.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingInstrumentsV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingInstrumentsV5(ctx context.Context) ApiGetCopytradingInstrumentsV5Request {
	return ApiGetCopytradingInstrumentsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingInstrumentsV5Resp
func (a *CopyTradingAPIService) GetCopytradingInstrumentsV5Execute(r ApiGetCopytradingInstrumentsV5Request) (*GetCopytradingInstrumentsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingInstrumentsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingInstrumentsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/instruments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingProfitSharingDetailsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
	after *string
	before *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  It returns all types by default.
func (r ApiGetCopytradingProfitSharingDetailsV5Request) InstType(instType string) ApiGetCopytradingProfitSharingDetailsV5Request {
	r.instType = &instType
	return r
}

// Pagination of data to return records earlier than the requested &#x60;profitSharingId&#x60;
func (r ApiGetCopytradingProfitSharingDetailsV5Request) After(after string) ApiGetCopytradingProfitSharingDetailsV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;profitSharingId&#x60;
func (r ApiGetCopytradingProfitSharingDetailsV5Request) Before(before string) ApiGetCopytradingProfitSharingDetailsV5Request {
	r.before = &before
	return r
}

// Number of results per request. Maximum is 100. Default is 100.
func (r ApiGetCopytradingProfitSharingDetailsV5Request) Limit(limit string) ApiGetCopytradingProfitSharingDetailsV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetCopytradingProfitSharingDetailsV5Request) Execute() (*GetCopytradingProfitSharingDetailsV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingProfitSharingDetailsV5Execute(r)
}

/*
GetCopytradingProfitSharingDetailsV5 The leading trader gets profits shared details for the last 3 months.  

The leading trader gets profits shared details for the last 3 months.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingProfitSharingDetailsV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingProfitSharingDetailsV5(ctx context.Context) ApiGetCopytradingProfitSharingDetailsV5Request {
	return ApiGetCopytradingProfitSharingDetailsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingProfitSharingDetailsV5Resp
func (a *CopyTradingAPIService) GetCopytradingProfitSharingDetailsV5Execute(r ApiGetCopytradingProfitSharingDetailsV5Request) (*GetCopytradingProfitSharingDetailsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingProfitSharingDetailsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingProfitSharingDetailsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/profit-sharing-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicConfigV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingPublicConfigV5Request) InstType(instType string) ApiGetCopytradingPublicConfigV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingPublicConfigV5Request) Execute() (*GetCopytradingPublicConfigV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicConfigV5Execute(r)
}

/*
GetCopytradingPublicConfigV5 Public endpoint. Retrieve copy trading parameter configuration information of copy settings  

Public endpoint. Retrieve copy trading parameter configuration information of copy settings

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicConfigV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicConfigV5(ctx context.Context) ApiGetCopytradingPublicConfigV5Request {
	return ApiGetCopytradingPublicConfigV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicConfigV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicConfigV5Execute(r ApiGetCopytradingPublicConfigV5Request) (*GetCopytradingPublicConfigV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicConfigV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicConfigV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicCopyTradersV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	instType *string
	limit *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingPublicCopyTradersV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingPublicCopyTradersV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingPublicCopyTradersV5Request) InstType(instType string) ApiGetCopytradingPublicCopyTradersV5Request {
	r.instType = &instType
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetCopytradingPublicCopyTradersV5Request) Limit(limit string) ApiGetCopytradingPublicCopyTradersV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetCopytradingPublicCopyTradersV5Request) Execute() (*GetCopytradingPublicCopyTradersV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicCopyTradersV5Execute(r)
}

/*
GetCopytradingPublicCopyTradersV5 Public endpoint. Retrieve copy trader coming from certain lead trader. Return according to `pnl` from high to low  

Public endpoint. Retrieve copy trader coming from certain lead trader. Return according to `pnl` from high to low

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicCopyTradersV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicCopyTradersV5(ctx context.Context) ApiGetCopytradingPublicCopyTradersV5Request {
	return ApiGetCopytradingPublicCopyTradersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicCopyTradersV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicCopyTradersV5Execute(r ApiGetCopytradingPublicCopyTradersV5Request) (*GetCopytradingPublicCopyTradersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicCopyTradersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicCopyTradersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-copy-traders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicCurrentSubpositionsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	instType *string
	after *string
	before *string
	limit *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingPublicCurrentSubpositionsV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingPublicCurrentSubpositionsV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Instrument type  &#x60;SWAP&#x60;, the default value.
func (r ApiGetCopytradingPublicCurrentSubpositionsV5Request) InstType(instType string) ApiGetCopytradingPublicCurrentSubpositionsV5Request {
	r.instType = &instType
	return r
}

// Pagination of data to return records earlier than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingPublicCurrentSubpositionsV5Request) After(after string) ApiGetCopytradingPublicCurrentSubpositionsV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingPublicCurrentSubpositionsV5Request) Before(before string) ApiGetCopytradingPublicCurrentSubpositionsV5Request {
	r.before = &before
	return r
}

// Number of results per request. Maximum is 100. Default is 100.
func (r ApiGetCopytradingPublicCurrentSubpositionsV5Request) Limit(limit string) ApiGetCopytradingPublicCurrentSubpositionsV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetCopytradingPublicCurrentSubpositionsV5Request) Execute() (*GetCopytradingPublicCurrentSubpositionsV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicCurrentSubpositionsV5Execute(r)
}

/*
GetCopytradingPublicCurrentSubpositionsV5 Public endpoint. Get current leading positions of lead trader  

Public endpoint. Get current leading positions of lead trader

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicCurrentSubpositionsV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicCurrentSubpositionsV5(ctx context.Context) ApiGetCopytradingPublicCurrentSubpositionsV5Request {
	return ApiGetCopytradingPublicCurrentSubpositionsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicCurrentSubpositionsV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicCurrentSubpositionsV5Execute(r ApiGetCopytradingPublicCurrentSubpositionsV5Request) (*GetCopytradingPublicCurrentSubpositionsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicCurrentSubpositionsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicCurrentSubpositionsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-current-subpositions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicLeadTradersV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
	sortType *string
	state *string
	minLeadDays *string
	minAssets *string
	maxAssets *string
	minAum *string
	maxAum *string
	dataVer *string
	page *string
	limit *string
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingPublicLeadTradersV5Request) InstType(instType string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.instType = &instType
	return r
}

// Sort type  &#x60;overview&#x60;: overview, the default value  &#x60;pnl&#x60;: profit and loss  &#x60;aum&#x60;: assets under management  &#x60;win_ratio&#x60;: win ratio  &#x60;pnl_ratio&#x60;: pnl ratio  &#x60;current_copy_trader_pnl&#x60;: current copy trader pnl
func (r ApiGetCopytradingPublicLeadTradersV5Request) SortType(sortType string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.sortType = &sortType
	return r
}

// Lead trader state  &#x60;0&#x60;: All lead traders, the default, including vacancy and non-vacancy   &#x60;1&#x60;: lead traders who have vacancy
func (r ApiGetCopytradingPublicLeadTradersV5Request) State(state string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.state = &state
	return r
}

// Minimum lead days  &#x60;1&#x60;: 7 days  &#x60;2&#x60;: 30 days  &#x60;3&#x60;: 90 days  &#x60;4&#x60;: 180 days
func (r ApiGetCopytradingPublicLeadTradersV5Request) MinLeadDays(minLeadDays string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.minLeadDays = &minLeadDays
	return r
}

// Minimum assets in USDT
func (r ApiGetCopytradingPublicLeadTradersV5Request) MinAssets(minAssets string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.minAssets = &minAssets
	return r
}

// Maximum assets in USDT
func (r ApiGetCopytradingPublicLeadTradersV5Request) MaxAssets(maxAssets string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.maxAssets = &maxAssets
	return r
}

// Minimum assets in USDT under management.
func (r ApiGetCopytradingPublicLeadTradersV5Request) MinAum(minAum string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.minAum = &minAum
	return r
}

// Maximum assets in USDT under management.
func (r ApiGetCopytradingPublicLeadTradersV5Request) MaxAum(maxAum string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.maxAum = &maxAum
	return r
}

// Data version. It is 14 numbers. e.g. 20231010182400. Generally, it is used for pagination   A new version will be generated every 10 minutes. Only last 5 versions are stored  The default is latest version. If it is not exist, error will not be throwed and the latest version will be used.
func (r ApiGetCopytradingPublicLeadTradersV5Request) DataVer(dataVer string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.dataVer = &dataVer
	return r
}

// Page for pagination
func (r ApiGetCopytradingPublicLeadTradersV5Request) Page(page string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.page = &page
	return r
}

// Number of results per request. The maximum is 20; the default is 10
func (r ApiGetCopytradingPublicLeadTradersV5Request) Limit(limit string) ApiGetCopytradingPublicLeadTradersV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetCopytradingPublicLeadTradersV5Request) Execute() (*GetCopytradingPublicLeadTradersV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicLeadTradersV5Execute(r)
}

/*
GetCopytradingPublicLeadTradersV5 Public endpoint. Retrieve lead trader ranks.  

Public endpoint. Retrieve lead trader ranks.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicLeadTradersV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicLeadTradersV5(ctx context.Context) ApiGetCopytradingPublicLeadTradersV5Request {
	return ApiGetCopytradingPublicLeadTradersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicLeadTradersV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicLeadTradersV5Execute(r ApiGetCopytradingPublicLeadTradersV5Request) (*GetCopytradingPublicLeadTradersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicLeadTradersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicLeadTradersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-lead-traders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "form", "")
	} else {
		var defaultValue string = ""
		r.sortType = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.minLeadDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minLeadDays", r.minLeadDays, "form", "")
	} else {
		var defaultValue string = ""
		r.minLeadDays = &defaultValue
	}
	if r.minAssets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minAssets", r.minAssets, "form", "")
	} else {
		var defaultValue string = ""
		r.minAssets = &defaultValue
	}
	if r.maxAssets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAssets", r.maxAssets, "form", "")
	} else {
		var defaultValue string = ""
		r.maxAssets = &defaultValue
	}
	if r.minAum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minAum", r.minAum, "form", "")
	} else {
		var defaultValue string = ""
		r.minAum = &defaultValue
	}
	if r.maxAum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAum", r.maxAum, "form", "")
	} else {
		var defaultValue string = ""
		r.maxAum = &defaultValue
	}
	if r.dataVer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataVer", r.dataVer, "form", "")
	} else {
		var defaultValue string = ""
		r.dataVer = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue string = ""
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicPnlV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	lastDays *string
	instType *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingPublicPnlV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingPublicPnlV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Last days  &#x60;1&#x60;: last 7 days   &#x60;2&#x60;: last 30 days  &#x60;3&#x60;: last 90 days   &#x60;4&#x60;: last 365 days
func (r ApiGetCopytradingPublicPnlV5Request) LastDays(lastDays string) ApiGetCopytradingPublicPnlV5Request {
	r.lastDays = &lastDays
	return r
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingPublicPnlV5Request) InstType(instType string) ApiGetCopytradingPublicPnlV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingPublicPnlV5Request) Execute() (*GetCopytradingPublicPnlV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicPnlV5Execute(r)
}

/*
GetCopytradingPublicPnlV5 Public endpoint. Retrieve lead trader daily pnl. Results are returned in counter chronological order.  

Public endpoint. Retrieve lead trader daily pnl. Results are returned in counter chronological order.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicPnlV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicPnlV5(ctx context.Context) ApiGetCopytradingPublicPnlV5Request {
	return ApiGetCopytradingPublicPnlV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicPnlV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicPnlV5Execute(r ApiGetCopytradingPublicPnlV5Request) (*GetCopytradingPublicPnlV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicPnlV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicPnlV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-pnl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}
	if r.lastDays == nil {
		return localVarReturnValue, nil, reportError("lastDays is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "lastDays", r.lastDays, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicPreferenceCurrencyV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	instType *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingPublicPreferenceCurrencyV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingPublicPreferenceCurrencyV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingPublicPreferenceCurrencyV5Request) InstType(instType string) ApiGetCopytradingPublicPreferenceCurrencyV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingPublicPreferenceCurrencyV5Request) Execute() (*GetCopytradingPublicPreferenceCurrencyV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicPreferenceCurrencyV5Execute(r)
}

/*
GetCopytradingPublicPreferenceCurrencyV5 Public endpoint. The most frequently traded crypto of this lead trader. Results are sorted by ratio from large to small.  

Public endpoint. The most frequently traded crypto of this lead trader. Results are sorted by ratio from large to small.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicPreferenceCurrencyV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicPreferenceCurrencyV5(ctx context.Context) ApiGetCopytradingPublicPreferenceCurrencyV5Request {
	return ApiGetCopytradingPublicPreferenceCurrencyV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicPreferenceCurrencyV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicPreferenceCurrencyV5Execute(r ApiGetCopytradingPublicPreferenceCurrencyV5Request) (*GetCopytradingPublicPreferenceCurrencyV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicPreferenceCurrencyV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicPreferenceCurrencyV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-preference-currency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicStatsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	lastDays *string
	instType *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingPublicStatsV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingPublicStatsV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Last days  &#x60;1&#x60;: last 7 days   &#x60;2&#x60;: last 30 days  &#x60;3&#x60;: last 90 days   &#x60;4&#x60;: last 365 days
func (r ApiGetCopytradingPublicStatsV5Request) LastDays(lastDays string) ApiGetCopytradingPublicStatsV5Request {
	r.lastDays = &lastDays
	return r
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingPublicStatsV5Request) InstType(instType string) ApiGetCopytradingPublicStatsV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingPublicStatsV5Request) Execute() (*GetCopytradingPublicStatsV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicStatsV5Execute(r)
}

/*
GetCopytradingPublicStatsV5 Public endpoint. Key data related to lead trader performance.  

Public endpoint. Key data related to lead trader performance.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicStatsV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicStatsV5(ctx context.Context) ApiGetCopytradingPublicStatsV5Request {
	return ApiGetCopytradingPublicStatsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicStatsV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicStatsV5Execute(r ApiGetCopytradingPublicStatsV5Request) (*GetCopytradingPublicStatsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicStatsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicStatsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}
	if r.lastDays == nil {
		return localVarReturnValue, nil, reportError("lastDays is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "lastDays", r.lastDays, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicSubpositionsHistoryV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	instType *string
	after *string
	before *string
	limit *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingPublicSubpositionsHistoryV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingPublicSubpositionsHistoryV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Instrument type  &#x60;SWAP&#x60;, the default value.
func (r ApiGetCopytradingPublicSubpositionsHistoryV5Request) InstType(instType string) ApiGetCopytradingPublicSubpositionsHistoryV5Request {
	r.instType = &instType
	return r
}

// Pagination of data to return records earlier than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingPublicSubpositionsHistoryV5Request) After(after string) ApiGetCopytradingPublicSubpositionsHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingPublicSubpositionsHistoryV5Request) Before(before string) ApiGetCopytradingPublicSubpositionsHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. Maximum is 100. Default is 100.
func (r ApiGetCopytradingPublicSubpositionsHistoryV5Request) Limit(limit string) ApiGetCopytradingPublicSubpositionsHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetCopytradingPublicSubpositionsHistoryV5Request) Execute() (*GetCopytradingPublicSubpositionsHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicSubpositionsHistoryV5Execute(r)
}

/*
GetCopytradingPublicSubpositionsHistoryV5 Public endpoint. Retrieve the lead trader completed leading position of the last 3 months.   Returns reverse chronological order with `subPosId`.   

Public endpoint. Retrieve the lead trader completed leading position of the last 3 months.


Returns reverse chronological order with `subPosId`. 

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicSubpositionsHistoryV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicSubpositionsHistoryV5(ctx context.Context) ApiGetCopytradingPublicSubpositionsHistoryV5Request {
	return ApiGetCopytradingPublicSubpositionsHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicSubpositionsHistoryV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicSubpositionsHistoryV5Execute(r ApiGetCopytradingPublicSubpositionsHistoryV5Request) (*GetCopytradingPublicSubpositionsHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicSubpositionsHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicSubpositionsHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-subpositions-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingPublicWeeklyPnlV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	uniqueCode *string
	instType *string
}

// Lead trader unique code  A combination of case-sensitive alphanumerics, all numbers and the length is 16 characters, e.g. 213E8C92DC61EFAC
func (r ApiGetCopytradingPublicWeeklyPnlV5Request) UniqueCode(uniqueCode string) ApiGetCopytradingPublicWeeklyPnlV5Request {
	r.uniqueCode = &uniqueCode
	return r
}

// Instrument type  &#x60;SWAP&#x60;, the default value
func (r ApiGetCopytradingPublicWeeklyPnlV5Request) InstType(instType string) ApiGetCopytradingPublicWeeklyPnlV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingPublicWeeklyPnlV5Request) Execute() (*GetCopytradingPublicWeeklyPnlV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingPublicWeeklyPnlV5Execute(r)
}

/*
GetCopytradingPublicWeeklyPnlV5 Public endpoint. Retrieve lead trader weekly pnl. Results are returned in counter chronological order.  

Public endpoint. Retrieve lead trader weekly pnl. Results are returned in counter chronological order.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingPublicWeeklyPnlV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingPublicWeeklyPnlV5(ctx context.Context) ApiGetCopytradingPublicWeeklyPnlV5Request {
	return ApiGetCopytradingPublicWeeklyPnlV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingPublicWeeklyPnlV5Resp
func (a *CopyTradingAPIService) GetCopytradingPublicWeeklyPnlV5Execute(r ApiGetCopytradingPublicWeeklyPnlV5Request) (*GetCopytradingPublicWeeklyPnlV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingPublicWeeklyPnlV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingPublicWeeklyPnlV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/public-weekly-pnl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCode == nil {
		return localVarReturnValue, nil, reportError("uniqueCode is required and must be specified")
	}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCode", r.uniqueCode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingSubpositionsHistoryV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
	instId *string
	after *string
	before *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  It returns all types by default.
func (r ApiGetCopytradingSubpositionsHistoryV5Request) InstType(instType string) ApiGetCopytradingSubpositionsHistoryV5Request {
	r.instType = &instType
	return r
}

// Instrument ID, e.g. BTC-USDT-SWAP
func (r ApiGetCopytradingSubpositionsHistoryV5Request) InstId(instId string) ApiGetCopytradingSubpositionsHistoryV5Request {
	r.instId = &instId
	return r
}

// Pagination of data to return records earlier than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingSubpositionsHistoryV5Request) After(after string) ApiGetCopytradingSubpositionsHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;subPosId&#x60;.
func (r ApiGetCopytradingSubpositionsHistoryV5Request) Before(before string) ApiGetCopytradingSubpositionsHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. Maximum is 100. Default is 100.
func (r ApiGetCopytradingSubpositionsHistoryV5Request) Limit(limit string) ApiGetCopytradingSubpositionsHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetCopytradingSubpositionsHistoryV5Request) Execute() (*GetCopytradingSubpositionsHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingSubpositionsHistoryV5Execute(r)
}

/*
GetCopytradingSubpositionsHistoryV5 Retrieve the completed lead position of the last 3 months.   Returns reverse chronological order with `subPosId`.   

Retrieve the completed lead position of the last 3 months.


Returns reverse chronological order with `subPosId`. 

#### Rate limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingSubpositionsHistoryV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingSubpositionsHistoryV5(ctx context.Context) ApiGetCopytradingSubpositionsHistoryV5Request {
	return ApiGetCopytradingSubpositionsHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingSubpositionsHistoryV5Resp
func (a *CopyTradingAPIService) GetCopytradingSubpositionsHistoryV5Execute(r ApiGetCopytradingSubpositionsHistoryV5Request) (*GetCopytradingSubpositionsHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingSubpositionsHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingSubpositionsHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/subpositions-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingTotalProfitSharingV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  It returns all types by default.
func (r ApiGetCopytradingTotalProfitSharingV5Request) InstType(instType string) ApiGetCopytradingTotalProfitSharingV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingTotalProfitSharingV5Request) Execute() (*GetCopytradingTotalProfitSharingV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingTotalProfitSharingV5Execute(r)
}

/*
GetCopytradingTotalProfitSharingV5 The leading trader gets the total amount of profit shared since joining the platform.  

The leading trader gets the total amount of profit shared since joining the platform.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingTotalProfitSharingV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingTotalProfitSharingV5(ctx context.Context) ApiGetCopytradingTotalProfitSharingV5Request {
	return ApiGetCopytradingTotalProfitSharingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingTotalProfitSharingV5Resp
func (a *CopyTradingAPIService) GetCopytradingTotalProfitSharingV5Execute(r ApiGetCopytradingTotalProfitSharingV5Request) (*GetCopytradingTotalProfitSharingV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingTotalProfitSharingV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingTotalProfitSharingV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/total-profit-sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingTotalUnrealizedProfitSharingV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
}

// Instrument type  &#x60;SWAP&#x60;, the default value.
func (r ApiGetCopytradingTotalUnrealizedProfitSharingV5Request) InstType(instType string) ApiGetCopytradingTotalUnrealizedProfitSharingV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingTotalUnrealizedProfitSharingV5Request) Execute() (*GetCopytradingTotalUnrealizedProfitSharingV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingTotalUnrealizedProfitSharingV5Execute(r)
}

/*
GetCopytradingTotalUnrealizedProfitSharingV5 The leading trader gets the total unrealized amount of profit shared.  

The leading trader gets the total unrealized amount of profit shared.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingTotalUnrealizedProfitSharingV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingTotalUnrealizedProfitSharingV5(ctx context.Context) ApiGetCopytradingTotalUnrealizedProfitSharingV5Request {
	return ApiGetCopytradingTotalUnrealizedProfitSharingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingTotalUnrealizedProfitSharingV5Resp
func (a *CopyTradingAPIService) GetCopytradingTotalUnrealizedProfitSharingV5Execute(r ApiGetCopytradingTotalUnrealizedProfitSharingV5Request) (*GetCopytradingTotalUnrealizedProfitSharingV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingTotalUnrealizedProfitSharingV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingTotalUnrealizedProfitSharingV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/total-unrealized-profit-sharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request struct {
	ctx context.Context
	ApiService *CopyTradingAPIService
	instType *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;SWAP&#x60;  It returns all types by default.
func (r ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request) InstType(instType string) ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request {
	r.instType = &instType
	return r
}

func (r ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request) Execute() (*GetCopytradingUnrealizedProfitSharingDetailsV5Resp, *http.Response, error) {
	return r.ApiService.GetCopytradingUnrealizedProfitSharingDetailsV5Execute(r)
}

/*
GetCopytradingUnrealizedProfitSharingDetailsV5 The leading trader gets the profit sharing details that are expected to be shared in the next settlement cycle.   The unrealized profit sharing details will update once there copy position is closed.  

The leading trader gets the profit sharing details that are expected to be shared in the next settlement cycle.


The unrealized profit sharing details will update once there copy position is closed.

#### Rate limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request
*/
func (a *CopyTradingAPIService) GetCopytradingUnrealizedProfitSharingDetailsV5(ctx context.Context) ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request {
	return ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCopytradingUnrealizedProfitSharingDetailsV5Resp
func (a *CopyTradingAPIService) GetCopytradingUnrealizedProfitSharingDetailsV5Execute(r ApiGetCopytradingUnrealizedProfitSharingDetailsV5Request) (*GetCopytradingUnrealizedProfitSharingDetailsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCopytradingUnrealizedProfitSharingDetailsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CopyTradingAPIService.GetCopytradingUnrealizedProfitSharingDetailsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/copytrading/unrealized-profit-sharing-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	
	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
