/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"fmt"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SpreadTradingAPIService SpreadTradingAPI service
type SpreadTradingAPIService service

type ApiCreateSprdAmendOrderV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	createSprdAmendOrderV5Req *CreateSprdAmendOrderV5Req
}

// The request body for CreateSprdAmendOrderV5
func (r ApiCreateSprdAmendOrderV5Request) CreateSprdAmendOrderV5Req(createSprdAmendOrderV5Req CreateSprdAmendOrderV5Req) ApiCreateSprdAmendOrderV5Request {
	r.createSprdAmendOrderV5Req = &createSprdAmendOrderV5Req
	return r
}

func (r ApiCreateSprdAmendOrderV5Request) Execute() (*CreateSprdAmendOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateSprdAmendOrderV5Execute(r)
}

/*
CreateSprdAmendOrderV5 Amend order

Amend an incomplete order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSprdAmendOrderV5Request
*/
func (a *SpreadTradingAPIService) CreateSprdAmendOrderV5(ctx context.Context) ApiCreateSprdAmendOrderV5Request {
	return ApiCreateSprdAmendOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSprdAmendOrderV5Resp
func (a *SpreadTradingAPIService) CreateSprdAmendOrderV5Execute(r ApiCreateSprdAmendOrderV5Request) (*CreateSprdAmendOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSprdAmendOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.CreateSprdAmendOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/amend-order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSprdAmendOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createSprdAmendOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSprdAmendOrderV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSprdCancelAllAfterV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	createSprdCancelAllAfterV5Req *CreateSprdCancelAllAfterV5Req
}

// The request body for CreateSprdCancelAllAfterV5
func (r ApiCreateSprdCancelAllAfterV5Request) CreateSprdCancelAllAfterV5Req(createSprdCancelAllAfterV5Req CreateSprdCancelAllAfterV5Req) ApiCreateSprdCancelAllAfterV5Request {
	r.createSprdCancelAllAfterV5Req = &createSprdCancelAllAfterV5Req
	return r
}

func (r ApiCreateSprdCancelAllAfterV5Request) Execute() (*CreateSprdCancelAllAfterV5Resp, *http.Response, error) {
	return r.ApiService.CreateSprdCancelAllAfterV5Execute(r)
}

/*
CreateSprdCancelAllAfterV5 Cancel All After

Cancel all pending orders after the countdown timeout. Only applicable to spread trading.

#### Rate Limit: 1 request per second 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSprdCancelAllAfterV5Request
*/
func (a *SpreadTradingAPIService) CreateSprdCancelAllAfterV5(ctx context.Context) ApiCreateSprdCancelAllAfterV5Request {
	return ApiCreateSprdCancelAllAfterV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSprdCancelAllAfterV5Resp
func (a *SpreadTradingAPIService) CreateSprdCancelAllAfterV5Execute(r ApiCreateSprdCancelAllAfterV5Request) (*CreateSprdCancelAllAfterV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSprdCancelAllAfterV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.CreateSprdCancelAllAfterV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/cancel-all-after"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSprdCancelAllAfterV5Req == nil {
		return localVarReturnValue, nil, reportError("createSprdCancelAllAfterV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSprdCancelAllAfterV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSprdCancelOrderV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	createSprdCancelOrderV5Req *CreateSprdCancelOrderV5Req
}

// The request body for CreateSprdCancelOrderV5
func (r ApiCreateSprdCancelOrderV5Request) CreateSprdCancelOrderV5Req(createSprdCancelOrderV5Req CreateSprdCancelOrderV5Req) ApiCreateSprdCancelOrderV5Request {
	r.createSprdCancelOrderV5Req = &createSprdCancelOrderV5Req
	return r
}

func (r ApiCreateSprdCancelOrderV5Request) Execute() (*CreateSprdCancelOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateSprdCancelOrderV5Execute(r)
}

/*
CreateSprdCancelOrderV5 Cancel order

Cancel an incomplete order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSprdCancelOrderV5Request
*/
func (a *SpreadTradingAPIService) CreateSprdCancelOrderV5(ctx context.Context) ApiCreateSprdCancelOrderV5Request {
	return ApiCreateSprdCancelOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSprdCancelOrderV5Resp
func (a *SpreadTradingAPIService) CreateSprdCancelOrderV5Execute(r ApiCreateSprdCancelOrderV5Request) (*CreateSprdCancelOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSprdCancelOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.CreateSprdCancelOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/cancel-order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSprdCancelOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createSprdCancelOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSprdCancelOrderV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSprdMassCancelV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	createSprdMassCancelV5Req *CreateSprdMassCancelV5Req
}

// The request body for CreateSprdMassCancelV5
func (r ApiCreateSprdMassCancelV5Request) CreateSprdMassCancelV5Req(createSprdMassCancelV5Req CreateSprdMassCancelV5Req) ApiCreateSprdMassCancelV5Request {
	r.createSprdMassCancelV5Req = &createSprdMassCancelV5Req
	return r
}

func (r ApiCreateSprdMassCancelV5Request) Execute() (*CreateSprdMassCancelV5Resp, *http.Response, error) {
	return r.ApiService.CreateSprdMassCancelV5Execute(r)
}

/*
CreateSprdMassCancelV5 Cancel All orders

Cancel all pending orders.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSprdMassCancelV5Request
*/
func (a *SpreadTradingAPIService) CreateSprdMassCancelV5(ctx context.Context) ApiCreateSprdMassCancelV5Request {
	return ApiCreateSprdMassCancelV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSprdMassCancelV5Resp
func (a *SpreadTradingAPIService) CreateSprdMassCancelV5Execute(r ApiCreateSprdMassCancelV5Request) (*CreateSprdMassCancelV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSprdMassCancelV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.CreateSprdMassCancelV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/mass-cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSprdMassCancelV5Req == nil {
		return localVarReturnValue, nil, reportError("createSprdMassCancelV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSprdMassCancelV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSprdOrderV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	createSprdOrderV5Req *CreateSprdOrderV5Req
}

// The request body for CreateSprdOrderV5
func (r ApiCreateSprdOrderV5Request) CreateSprdOrderV5Req(createSprdOrderV5Req CreateSprdOrderV5Req) ApiCreateSprdOrderV5Request {
	r.createSprdOrderV5Req = &createSprdOrderV5Req
	return r
}

func (r ApiCreateSprdOrderV5Request) Execute() (*CreateSprdOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateSprdOrderV5Execute(r)
}

/*
CreateSprdOrderV5 Place order

Place a new order

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSprdOrderV5Request
*/
func (a *SpreadTradingAPIService) CreateSprdOrderV5(ctx context.Context) ApiCreateSprdOrderV5Request {
	return ApiCreateSprdOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSprdOrderV5Resp
func (a *SpreadTradingAPIService) CreateSprdOrderV5Execute(r ApiCreateSprdOrderV5Request) (*CreateSprdOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSprdOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.CreateSprdOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSprdOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createSprdOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSprdOrderV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketSprdCandlesV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
	bar *string
	after *string
	before *string
	limit *string
}

// Spread ID
func (r ApiGetMarketSprdCandlesV5Request) SprdId(sprdId string) ApiGetMarketSprdCandlesV5Request {
	r.sprdId = &sprdId
	return r
}

// Bar size, the default is 1m, e.g. [1m/3m/5m/15m/30m/1H/2H/4H]   Hong Kong time opening price k-line:[6H/12H/1D/2D/3D/1W/1M/3M]   UTC time opening price k-line:[/6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/1Wutc/1Mutc/3Mutc]
func (r ApiGetMarketSprdCandlesV5Request) Bar(bar string) ApiGetMarketSprdCandlesV5Request {
	r.bar = &bar
	return r
}

// Pagination of data to return records earlier than the requested ts
func (r ApiGetMarketSprdCandlesV5Request) After(after string) ApiGetMarketSprdCandlesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested ts. The latest data will be returned when using before individually
func (r ApiGetMarketSprdCandlesV5Request) Before(before string) ApiGetMarketSprdCandlesV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 300. The default is 100.
func (r ApiGetMarketSprdCandlesV5Request) Limit(limit string) ApiGetMarketSprdCandlesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketSprdCandlesV5Request) Execute() (*GetMarketSprdCandlesV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketSprdCandlesV5Execute(r)
}

/*
GetMarketSprdCandlesV5 Get candlesticks

Retrieve the candlestick charts. This endpoint can retrieve the latest 1,440 data entries. Charts are returned in groups based on the requested bar.

#### Rate Limit: 40 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketSprdCandlesV5Request
*/
func (a *SpreadTradingAPIService) GetMarketSprdCandlesV5(ctx context.Context) ApiGetMarketSprdCandlesV5Request {
	return ApiGetMarketSprdCandlesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketSprdCandlesV5Resp
func (a *SpreadTradingAPIService) GetMarketSprdCandlesV5Execute(r ApiGetMarketSprdCandlesV5Request) (*GetMarketSprdCandlesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketSprdCandlesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetMarketSprdCandlesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/sprd-candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sprdId == nil {
		return localVarReturnValue, nil, reportError("sprdId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "form", "")
	} else {
		var defaultValue string = ""
		r.bar = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketSprdHistoryCandlesV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
	after *string
	before *string
	bar *string
	limit *string
}

// Spread ID
func (r ApiGetMarketSprdHistoryCandlesV5Request) SprdId(sprdId string) ApiGetMarketSprdHistoryCandlesV5Request {
	r.sprdId = &sprdId
	return r
}

// Pagination of data to return records earlier than the requested ts
func (r ApiGetMarketSprdHistoryCandlesV5Request) After(after string) ApiGetMarketSprdHistoryCandlesV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested ts. The latest data will be returned when using before individually
func (r ApiGetMarketSprdHistoryCandlesV5Request) Before(before string) ApiGetMarketSprdHistoryCandlesV5Request {
	r.before = &before
	return r
}

// Bar size, the default is 1m, e.g. [1m/3m/5m/15m/30m/1H/2H/4H]   Hong Kong time opening price k-line:[6H/12H/1D/2D/3D/1W/1M/3M]   UTC time opening price k-line:[6Hutc/12Hutc/1Dutc/2Dutc/3Dutc/1Wutc/1Mutc/3Mutc]
func (r ApiGetMarketSprdHistoryCandlesV5Request) Bar(bar string) ApiGetMarketSprdHistoryCandlesV5Request {
	r.bar = &bar
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetMarketSprdHistoryCandlesV5Request) Limit(limit string) ApiGetMarketSprdHistoryCandlesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetMarketSprdHistoryCandlesV5Request) Execute() (*GetMarketSprdHistoryCandlesV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketSprdHistoryCandlesV5Execute(r)
}

/*
GetMarketSprdHistoryCandlesV5 Get candlesticks history

Retrieve history candlestick charts from recent years.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketSprdHistoryCandlesV5Request
*/
func (a *SpreadTradingAPIService) GetMarketSprdHistoryCandlesV5(ctx context.Context) ApiGetMarketSprdHistoryCandlesV5Request {
	return ApiGetMarketSprdHistoryCandlesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketSprdHistoryCandlesV5Resp
func (a *SpreadTradingAPIService) GetMarketSprdHistoryCandlesV5Execute(r ApiGetMarketSprdHistoryCandlesV5Request) (*GetMarketSprdHistoryCandlesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketSprdHistoryCandlesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetMarketSprdHistoryCandlesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/sprd-history-candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sprdId == nil {
		return localVarReturnValue, nil, reportError("sprdId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "form", "")
	} else {
		var defaultValue string = ""
		r.bar = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketSprdTickerV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
}

// spread ID, e.g. BTC-USDT_BTC-USDT-SWAP
func (r ApiGetMarketSprdTickerV5Request) SprdId(sprdId string) ApiGetMarketSprdTickerV5Request {
	r.sprdId = &sprdId
	return r
}

func (r ApiGetMarketSprdTickerV5Request) Execute() (*GetMarketSprdTickerV5Resp, *http.Response, error) {
	return r.ApiService.GetMarketSprdTickerV5Execute(r)
}

/*
GetMarketSprdTickerV5 Get ticker (Public)

Retrieve the latest price snapshot, best bid/ask price and quantity.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketSprdTickerV5Request
*/
func (a *SpreadTradingAPIService) GetMarketSprdTickerV5(ctx context.Context) ApiGetMarketSprdTickerV5Request {
	return ApiGetMarketSprdTickerV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMarketSprdTickerV5Resp
func (a *SpreadTradingAPIService) GetMarketSprdTickerV5Execute(r ApiGetMarketSprdTickerV5Request) (*GetMarketSprdTickerV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMarketSprdTickerV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetMarketSprdTickerV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/market/sprd-ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sprdId == nil {
		return localVarReturnValue, nil, reportError("sprdId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdBooksV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
	sz *string
}

// spread ID, e.g. BTC-USDT_BTC-USDT-SWAP
func (r ApiGetSprdBooksV5Request) SprdId(sprdId string) ApiGetSprdBooksV5Request {
	r.sprdId = &sprdId
	return r
}

// Order book depth per side. Maximum value is 400. Default value is 5.
func (r ApiGetSprdBooksV5Request) Sz(sz string) ApiGetSprdBooksV5Request {
	r.sz = &sz
	return r
}

func (r ApiGetSprdBooksV5Request) Execute() (*GetSprdBooksV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdBooksV5Execute(r)
}

/*
GetSprdBooksV5 Get order book (Public)

Retrieve the order book of the spread.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdBooksV5Request
*/
func (a *SpreadTradingAPIService) GetSprdBooksV5(ctx context.Context) ApiGetSprdBooksV5Request {
	return ApiGetSprdBooksV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdBooksV5Resp
func (a *SpreadTradingAPIService) GetSprdBooksV5Execute(r ApiGetSprdBooksV5Request) (*GetSprdBooksV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdBooksV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdBooksV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/books"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sprdId == nil {
		return localVarReturnValue, nil, reportError("sprdId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	if r.sz != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sz", r.sz, "form", "")
	} else {
		var defaultValue string = ""
		r.sz = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdOrderV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	ordId *string
	clOrdId *string
}

// Order ID   Either &#x60;ordId&#x60; or &#x60;clOrdId&#x60; is required, if both are passed, &#x60;ordId&#x60; will be used
func (r ApiGetSprdOrderV5Request) OrdId(ordId string) ApiGetSprdOrderV5Request {
	r.ordId = &ordId
	return r
}

// Client Order ID as assigned by the client. The latest order will be returned.
func (r ApiGetSprdOrderV5Request) ClOrdId(clOrdId string) ApiGetSprdOrderV5Request {
	r.clOrdId = &clOrdId
	return r
}

func (r ApiGetSprdOrderV5Request) Execute() (*GetSprdOrderV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdOrderV5Execute(r)
}

/*
GetSprdOrderV5 Get order details

Retrieve order details.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdOrderV5Request
*/
func (a *SpreadTradingAPIService) GetSprdOrderV5(ctx context.Context) ApiGetSprdOrderV5Request {
	return ApiGetSprdOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdOrderV5Resp
func (a *SpreadTradingAPIService) GetSprdOrderV5Execute(r ApiGetSprdOrderV5Request) (*GetSprdOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordId", r.ordId, "form", "")
	} else {
		var defaultValue string = ""
		r.ordId = &defaultValue
	}
	if r.clOrdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clOrdId", r.clOrdId, "form", "")
	} else {
		var defaultValue string = ""
		r.clOrdId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdOrdersHistoryArchiveV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
	ordType *string
	state *string
	instType *string
	instFamily *string
	beginId *string
	endId *string
	begin *string
	end *string
	limit *string
}

// spread ID, e.g.
func (r ApiGetSprdOrdersHistoryArchiveV5Request) SprdId(sprdId string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.sprdId = &sprdId
	return r
}

// Order type  &#x60;market&#x60;: Market order   &#x60;limit&#x60;: limit order   &#x60;post_only&#x60;: Post-only order   &#x60;ioc&#x60;: Immediate-or-cancel order
func (r ApiGetSprdOrdersHistoryArchiveV5Request) OrdType(ordType string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.ordType = &ordType
	return r
}

// State   &#x60;canceled&#x60;   &#x60;filled&#x60;
func (r ApiGetSprdOrdersHistoryArchiveV5Request) State(state string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.state = &state
	return r
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;FUTURES&#x60;  &#x60;SWAP&#x60;   Any orders with spreads containing the specified instrument type in any legs will be returned
func (r ApiGetSprdOrdersHistoryArchiveV5Request) InstType(instType string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.instType = &instType
	return r
}

// Instrument family, e.g. BTC-USDT. Any orders with spreads containing the specified instrument family in any legs will be returned
func (r ApiGetSprdOrdersHistoryArchiveV5Request) InstFamily(instFamily string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.instFamily = &instFamily
	return r
}

// Start order ID the request to begin with. Pagination of data to return records newer than the requested order Id, not including beginId
func (r ApiGetSprdOrdersHistoryArchiveV5Request) BeginId(beginId string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.beginId = &beginId
	return r
}

// End order ID the request to end with. Pagination of data to return records earlier than the requested order Id, not including endId
func (r ApiGetSprdOrdersHistoryArchiveV5Request) EndId(endId string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.endId = &endId
	return r
}

// Filter with a begin timestamp. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetSprdOrdersHistoryArchiveV5Request) Begin(begin string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetSprdOrdersHistoryArchiveV5Request) End(end string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is 100. The default is 100
func (r ApiGetSprdOrdersHistoryArchiveV5Request) Limit(limit string) ApiGetSprdOrdersHistoryArchiveV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetSprdOrdersHistoryArchiveV5Request) Execute() (*GetSprdOrdersHistoryArchiveV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdOrdersHistoryArchiveV5Execute(r)
}

/*
GetSprdOrdersHistoryArchiveV5 Get orders history (last 3 months)

Retrieve the completed order data for the last 3 months, including those placed 3 months ago but completed in the last 3 months. Results are returned in counter chronological order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdOrdersHistoryArchiveV5Request
*/
func (a *SpreadTradingAPIService) GetSprdOrdersHistoryArchiveV5(ctx context.Context) ApiGetSprdOrdersHistoryArchiveV5Request {
	return ApiGetSprdOrdersHistoryArchiveV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdOrdersHistoryArchiveV5Resp
func (a *SpreadTradingAPIService) GetSprdOrdersHistoryArchiveV5Execute(r ApiGetSprdOrdersHistoryArchiveV5Request) (*GetSprdOrdersHistoryArchiveV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdOrdersHistoryArchiveV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdOrdersHistoryArchiveV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/orders-history-archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sprdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	} else {
		var defaultValue string = ""
		r.sprdId = &defaultValue
	}
	if r.ordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	} else {
		var defaultValue string = ""
		r.ordType = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.beginId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginId", r.beginId, "form", "")
	} else {
		var defaultValue string = ""
		r.beginId = &defaultValue
	}
	if r.endId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endId", r.endId, "form", "")
	} else {
		var defaultValue string = ""
		r.endId = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdOrdersHistoryV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
	ordType *string
	state *string
	beginId *string
	endId *string
	begin *string
	end *string
	limit *string
}

// spread ID, e.g.
func (r ApiGetSprdOrdersHistoryV5Request) SprdId(sprdId string) ApiGetSprdOrdersHistoryV5Request {
	r.sprdId = &sprdId
	return r
}

// Order type  &#x60;market&#x60;: Market order   &#x60;limit&#x60;: limit order   &#x60;post_only&#x60;: Post-only order   &#x60;ioc&#x60;: Immediate-or-cancel order
func (r ApiGetSprdOrdersHistoryV5Request) OrdType(ordType string) ApiGetSprdOrdersHistoryV5Request {
	r.ordType = &ordType
	return r
}

// State   &#x60;canceled&#x60;   &#x60;filled&#x60;
func (r ApiGetSprdOrdersHistoryV5Request) State(state string) ApiGetSprdOrdersHistoryV5Request {
	r.state = &state
	return r
}

// Start order ID the request to begin with. Pagination of data to return records newer than the requested order Id, not including beginId
func (r ApiGetSprdOrdersHistoryV5Request) BeginId(beginId string) ApiGetSprdOrdersHistoryV5Request {
	r.beginId = &beginId
	return r
}

// End order ID the request to end with. Pagination of data to return records earlier than the requested order Id, not including endId
func (r ApiGetSprdOrdersHistoryV5Request) EndId(endId string) ApiGetSprdOrdersHistoryV5Request {
	r.endId = &endId
	return r
}

// Filter with a begin timestamp. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;. Date older than 7 days will be truncated.
func (r ApiGetSprdOrdersHistoryV5Request) Begin(begin string) ApiGetSprdOrdersHistoryV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetSprdOrdersHistoryV5Request) End(end string) ApiGetSprdOrdersHistoryV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is 100. The default is 100
func (r ApiGetSprdOrdersHistoryV5Request) Limit(limit string) ApiGetSprdOrdersHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetSprdOrdersHistoryV5Request) Execute() (*GetSprdOrdersHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdOrdersHistoryV5Execute(r)
}

/*
GetSprdOrdersHistoryV5 Get orders (last 21 days)

Retrieve the completed order data for the last 21 days, and the incomplete orders (filledSz =0 & state = canceled) that have been canceled are only reserved for 2 hours. Results are returned in counter chronological order of orders creation.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdOrdersHistoryV5Request
*/
func (a *SpreadTradingAPIService) GetSprdOrdersHistoryV5(ctx context.Context) ApiGetSprdOrdersHistoryV5Request {
	return ApiGetSprdOrdersHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdOrdersHistoryV5Resp
func (a *SpreadTradingAPIService) GetSprdOrdersHistoryV5Execute(r ApiGetSprdOrdersHistoryV5Request) (*GetSprdOrdersHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdOrdersHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdOrdersHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/orders-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sprdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	} else {
		var defaultValue string = ""
		r.sprdId = &defaultValue
	}
	if r.ordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	} else {
		var defaultValue string = ""
		r.ordType = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.beginId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginId", r.beginId, "form", "")
	} else {
		var defaultValue string = ""
		r.beginId = &defaultValue
	}
	if r.endId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endId", r.endId, "form", "")
	} else {
		var defaultValue string = ""
		r.endId = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdOrdersPendingV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
	ordType *string
	state *string
	beginId *string
	endId *string
	limit *string
}

// spread ID, e.g.
func (r ApiGetSprdOrdersPendingV5Request) SprdId(sprdId string) ApiGetSprdOrdersPendingV5Request {
	r.sprdId = &sprdId
	return r
}

// Order type  &#x60;market&#x60;: Market order   &#x60;limit&#x60;: Limit order   &#x60;post_only&#x60;: Post-only order   &#x60;ioc&#x60;: Immediate-or-cancel order
func (r ApiGetSprdOrdersPendingV5Request) OrdType(ordType string) ApiGetSprdOrdersPendingV5Request {
	r.ordType = &ordType
	return r
}

// State   &#x60;live&#x60;   &#x60;partially_filled&#x60;
func (r ApiGetSprdOrdersPendingV5Request) State(state string) ApiGetSprdOrdersPendingV5Request {
	r.state = &state
	return r
}

// Start order ID the request to begin with. Pagination of data to return records newer than the requested order Id, not including beginId
func (r ApiGetSprdOrdersPendingV5Request) BeginId(beginId string) ApiGetSprdOrdersPendingV5Request {
	r.beginId = &beginId
	return r
}

// End order ID the request to end with. Pagination of data to return records earlier than the requested order Id, not including endId
func (r ApiGetSprdOrdersPendingV5Request) EndId(endId string) ApiGetSprdOrdersPendingV5Request {
	r.endId = &endId
	return r
}

// Number of results per request. The maximum is 100. The default is 100
func (r ApiGetSprdOrdersPendingV5Request) Limit(limit string) ApiGetSprdOrdersPendingV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetSprdOrdersPendingV5Request) Execute() (*GetSprdOrdersPendingV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdOrdersPendingV5Execute(r)
}

/*
GetSprdOrdersPendingV5 Get active orders

Retrieve all incomplete orders under the current account.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdOrdersPendingV5Request
*/
func (a *SpreadTradingAPIService) GetSprdOrdersPendingV5(ctx context.Context) ApiGetSprdOrdersPendingV5Request {
	return ApiGetSprdOrdersPendingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdOrdersPendingV5Resp
func (a *SpreadTradingAPIService) GetSprdOrdersPendingV5Execute(r ApiGetSprdOrdersPendingV5Request) (*GetSprdOrdersPendingV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdOrdersPendingV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdOrdersPendingV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/orders-pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sprdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	} else {
		var defaultValue string = ""
		r.sprdId = &defaultValue
	}
	if r.ordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	} else {
		var defaultValue string = ""
		r.ordType = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.beginId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginId", r.beginId, "form", "")
	} else {
		var defaultValue string = ""
		r.beginId = &defaultValue
	}
	if r.endId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endId", r.endId, "form", "")
	} else {
		var defaultValue string = ""
		r.endId = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdPublicTradesV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
}

// Spread ID, e.g. BTC-USDT_BTC-USDT-SWAP
func (r ApiGetSprdPublicTradesV5Request) SprdId(sprdId string) ApiGetSprdPublicTradesV5Request {
	r.sprdId = &sprdId
	return r
}

func (r ApiGetSprdPublicTradesV5Request) Execute() (*GetSprdPublicTradesV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdPublicTradesV5Execute(r)
}

/*
GetSprdPublicTradesV5 Get public trades (Public)

Retrieve the recent transactions of an instrument (at most 500 records per request). Results are returned in counter chronological order. 

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdPublicTradesV5Request
*/
func (a *SpreadTradingAPIService) GetSprdPublicTradesV5(ctx context.Context) ApiGetSprdPublicTradesV5Request {
	return ApiGetSprdPublicTradesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdPublicTradesV5Resp
func (a *SpreadTradingAPIService) GetSprdPublicTradesV5Execute(r ApiGetSprdPublicTradesV5Request) (*GetSprdPublicTradesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdPublicTradesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdPublicTradesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/public-trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sprdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	} else {
		var defaultValue string = ""
		r.sprdId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdSpreadsV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	baseCcy *string
	instId *string
	sprdId *string
	state *string
}

// Currency instrument is based in, e.g. BTC, ETH
func (r ApiGetSprdSpreadsV5Request) BaseCcy(baseCcy string) ApiGetSprdSpreadsV5Request {
	r.baseCcy = &baseCcy
	return r
}

// The instrument ID to be included in the spread.
func (r ApiGetSprdSpreadsV5Request) InstId(instId string) ApiGetSprdSpreadsV5Request {
	r.instId = &instId
	return r
}

// The spread ID
func (r ApiGetSprdSpreadsV5Request) SprdId(sprdId string) ApiGetSprdSpreadsV5Request {
	r.sprdId = &sprdId
	return r
}

// Spreads which are available to trade, suspened or expired. Valid values include &#x60;live&#x60;, &#x60;suspend&#x60; and &#x60;expired&#x60;.
func (r ApiGetSprdSpreadsV5Request) State(state string) ApiGetSprdSpreadsV5Request {
	r.state = &state
	return r
}

func (r ApiGetSprdSpreadsV5Request) Execute() (*GetSprdSpreadsV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdSpreadsV5Execute(r)
}

/*
GetSprdSpreadsV5 Get Spreads (Public)

Retrieve all available spreads based on the request parameters.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: IP 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdSpreadsV5Request
*/
func (a *SpreadTradingAPIService) GetSprdSpreadsV5(ctx context.Context) ApiGetSprdSpreadsV5Request {
	return ApiGetSprdSpreadsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdSpreadsV5Resp
func (a *SpreadTradingAPIService) GetSprdSpreadsV5Execute(r ApiGetSprdSpreadsV5Request) (*GetSprdSpreadsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdSpreadsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdSpreadsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/spreads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseCcy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseCcy", r.baseCcy, "form", "")
	} else {
		var defaultValue string = ""
		r.baseCcy = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.sprdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	} else {
		var defaultValue string = ""
		r.sprdId = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSprdTradesV5Request struct {
	ctx context.Context
	ApiService *SpreadTradingAPIService
	sprdId *string
	tradeId *string
	ordId *string
	beginId *string
	endId *string
	begin *string
	end *string
	limit *string
}

// spread ID, e.g.
func (r ApiGetSprdTradesV5Request) SprdId(sprdId string) ApiGetSprdTradesV5Request {
	r.sprdId = &sprdId
	return r
}

// Trade ID
func (r ApiGetSprdTradesV5Request) TradeId(tradeId string) ApiGetSprdTradesV5Request {
	r.tradeId = &tradeId
	return r
}

// Order ID
func (r ApiGetSprdTradesV5Request) OrdId(ordId string) ApiGetSprdTradesV5Request {
	r.ordId = &ordId
	return r
}

// Start trade ID the request to begin with. Pagination of data to return records newer than the requested tradeId, not including beginId
func (r ApiGetSprdTradesV5Request) BeginId(beginId string) ApiGetSprdTradesV5Request {
	r.beginId = &beginId
	return r
}

// End trade ID the request to end with. Pagination of data to return records earlier than the requested tradeId, not including endId
func (r ApiGetSprdTradesV5Request) EndId(endId string) ApiGetSprdTradesV5Request {
	r.endId = &endId
	return r
}

// Filter with a begin timestamp. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetSprdTradesV5Request) Begin(begin string) ApiGetSprdTradesV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetSprdTradesV5Request) End(end string) ApiGetSprdTradesV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is 100. The default is 100
func (r ApiGetSprdTradesV5Request) Limit(limit string) ApiGetSprdTradesV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetSprdTradesV5Request) Execute() (*GetSprdTradesV5Resp, *http.Response, error) {
	return r.ApiService.GetSprdTradesV5Execute(r)
}

/*
GetSprdTradesV5 Get trades (last 7 days)

Retrieve historical transaction details . Results are returned in counter chronological order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSprdTradesV5Request
*/
func (a *SpreadTradingAPIService) GetSprdTradesV5(ctx context.Context) ApiGetSprdTradesV5Request {
	return ApiGetSprdTradesV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSprdTradesV5Resp
func (a *SpreadTradingAPIService) GetSprdTradesV5Execute(r ApiGetSprdTradesV5Request) (*GetSprdTradesV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSprdTradesV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpreadTradingAPIService.GetSprdTradesV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/sprd/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sprdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sprdId", r.sprdId, "form", "")
	} else {
		var defaultValue string = ""
		r.sprdId = &defaultValue
	}
	if r.tradeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tradeId", r.tradeId, "form", "")
	} else {
		var defaultValue string = ""
		r.tradeId = &defaultValue
	}
	if r.ordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordId", r.ordId, "form", "")
	} else {
		var defaultValue string = ""
		r.ordId = &defaultValue
	}
	if r.beginId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginId", r.beginId, "form", "")
	} else {
		var defaultValue string = ""
		r.beginId = &defaultValue
	}
	if r.endId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endId", r.endId, "form", "")
	} else {
		var defaultValue string = ""
		r.endId = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
