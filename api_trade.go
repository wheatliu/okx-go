/*
OKX v5 API

OpenAPI specification for Okx exchange - Rest API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rest

import (
	"fmt"
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TradeAPIService TradeAPI service
type TradeAPIService service

type ApiCreateTradeAmendBatchOrdersV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeAmendBatchOrdersV5Req *CreateTradeAmendBatchOrdersV5Req
}

// The request body for CreateTradeAmendBatchOrdersV5
func (r ApiCreateTradeAmendBatchOrdersV5Request) CreateTradeAmendBatchOrdersV5Req(createTradeAmendBatchOrdersV5Req CreateTradeAmendBatchOrdersV5Req) ApiCreateTradeAmendBatchOrdersV5Request {
	r.createTradeAmendBatchOrdersV5Req = &createTradeAmendBatchOrdersV5Req
	return r
}

func (r ApiCreateTradeAmendBatchOrdersV5Request) Execute() (*CreateTradeAmendBatchOrdersV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeAmendBatchOrdersV5Execute(r)
}

/*
CreateTradeAmendBatchOrdersV5 POST / Amend multiple orders

Amend incomplete orders in batches. Maximum 20 orders can be amended per request. Request parameters should be passed in the form of an array.

#### Rate Limit: 300 orders per 2 seconds 

#### Rate Limit of lead instruments for Copy Trading: 4 orders per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 

Rate limit of this endpoint will also be affected by the rules  and .

**_Unlike other endpoints, the rate limit of this endpoint is determined by the number of orders. If there is only one order in the request, it will consume the rate limit of `Amend order`._**



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeAmendBatchOrdersV5Request
*/
func (a *TradeAPIService) CreateTradeAmendBatchOrdersV5(ctx context.Context) ApiCreateTradeAmendBatchOrdersV5Request {
	return ApiCreateTradeAmendBatchOrdersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeAmendBatchOrdersV5Resp
func (a *TradeAPIService) CreateTradeAmendBatchOrdersV5Execute(r ApiCreateTradeAmendBatchOrdersV5Request) (*CreateTradeAmendBatchOrdersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeAmendBatchOrdersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeAmendBatchOrdersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/amend-batch-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeAmendBatchOrdersV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeAmendBatchOrdersV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeAmendBatchOrdersV5Req
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeAmendOrderV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeAmendOrderV5Req *CreateTradeAmendOrderV5Req
}

// The request body for CreateTradeAmendOrderV5
func (r ApiCreateTradeAmendOrderV5Request) CreateTradeAmendOrderV5Req(createTradeAmendOrderV5Req CreateTradeAmendOrderV5Req) ApiCreateTradeAmendOrderV5Request {
	r.createTradeAmendOrderV5Req = &createTradeAmendOrderV5Req
	return r
}

func (r ApiCreateTradeAmendOrderV5Request) Execute() (*CreateTradeAmendOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeAmendOrderV5Execute(r)
}

/*
CreateTradeAmendOrderV5 POST / Amend order

Amend an incomplete order.

#### Rate Limit: 60 requests per 2 seconds 

#### Rate Limit of lead instruments for Copy Trading: 4 requests per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 

Rate limit of this endpoint will also be affected by the rules  and .



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeAmendOrderV5Request
*/
func (a *TradeAPIService) CreateTradeAmendOrderV5(ctx context.Context) ApiCreateTradeAmendOrderV5Request {
	return ApiCreateTradeAmendOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeAmendOrderV5Resp
func (a *TradeAPIService) CreateTradeAmendOrderV5Execute(r ApiCreateTradeAmendOrderV5Request) (*CreateTradeAmendOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeAmendOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeAmendOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/amend-order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeAmendOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeAmendOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeAmendOrderV5Req
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeBatchOrdersV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeBatchOrdersV5Req *CreateTradeBatchOrdersV5Req
}

// The request body for CreateTradeBatchOrdersV5
func (r ApiCreateTradeBatchOrdersV5Request) CreateTradeBatchOrdersV5Req(createTradeBatchOrdersV5Req CreateTradeBatchOrdersV5Req) ApiCreateTradeBatchOrdersV5Request {
	r.createTradeBatchOrdersV5Req = &createTradeBatchOrdersV5Req
	return r
}

func (r ApiCreateTradeBatchOrdersV5Request) Execute() (*CreateTradeBatchOrdersV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeBatchOrdersV5Execute(r)
}

/*
CreateTradeBatchOrdersV5 POST / Place multiple orders

Place orders in batches. Maximum 20 orders can be placed per request. 


Request parameters should be passed in the form of an array. Orders will be placed in turn



#### Rate Limit: 300 orders per 2 seconds 

#### Rate Limit of lead instruments for Copy Trading: 4 orders per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 

Rate limit of this endpoint will also be affected by the rules  and .

**_Unlike other endpoints, the rate limit of this endpoint is determined by the number of orders. If there is only one order in the request, it will consume the rate limit of `Place order`._**



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeBatchOrdersV5Request
*/
func (a *TradeAPIService) CreateTradeBatchOrdersV5(ctx context.Context) ApiCreateTradeBatchOrdersV5Request {
	return ApiCreateTradeBatchOrdersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeBatchOrdersV5Resp
func (a *TradeAPIService) CreateTradeBatchOrdersV5Execute(r ApiCreateTradeBatchOrdersV5Request) (*CreateTradeBatchOrdersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeBatchOrdersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeBatchOrdersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/batch-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeBatchOrdersV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeBatchOrdersV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeBatchOrdersV5Req
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeCancelAllAfterV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeCancelAllAfterV5Req *CreateTradeCancelAllAfterV5Req
}

// The request body for CreateTradeCancelAllAfterV5
func (r ApiCreateTradeCancelAllAfterV5Request) CreateTradeCancelAllAfterV5Req(createTradeCancelAllAfterV5Req CreateTradeCancelAllAfterV5Req) ApiCreateTradeCancelAllAfterV5Request {
	r.createTradeCancelAllAfterV5Req = &createTradeCancelAllAfterV5Req
	return r
}

func (r ApiCreateTradeCancelAllAfterV5Request) Execute() (*CreateTradeCancelAllAfterV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeCancelAllAfterV5Execute(r)
}

/*
CreateTradeCancelAllAfterV5 POST / Cancel All After

Cancel all pending orders after the countdown timeout. Applicable to all trading symbols through order book (except Spread trading)



#### Rate Limit: 1 request per second 

#### Rate limit rule: User ID + tag 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeCancelAllAfterV5Request
*/
func (a *TradeAPIService) CreateTradeCancelAllAfterV5(ctx context.Context) ApiCreateTradeCancelAllAfterV5Request {
	return ApiCreateTradeCancelAllAfterV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeCancelAllAfterV5Resp
func (a *TradeAPIService) CreateTradeCancelAllAfterV5Execute(r ApiCreateTradeCancelAllAfterV5Request) (*CreateTradeCancelAllAfterV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeCancelAllAfterV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeCancelAllAfterV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/cancel-all-after"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeCancelAllAfterV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeCancelAllAfterV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeCancelAllAfterV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeCancelBatchOrdersV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeCancelBatchOrdersV5Req *CreateTradeCancelBatchOrdersV5Req
}

// The request body for CreateTradeCancelBatchOrdersV5
func (r ApiCreateTradeCancelBatchOrdersV5Request) CreateTradeCancelBatchOrdersV5Req(createTradeCancelBatchOrdersV5Req CreateTradeCancelBatchOrdersV5Req) ApiCreateTradeCancelBatchOrdersV5Request {
	r.createTradeCancelBatchOrdersV5Req = &createTradeCancelBatchOrdersV5Req
	return r
}

func (r ApiCreateTradeCancelBatchOrdersV5Request) Execute() (*CreateTradeCancelBatchOrdersV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeCancelBatchOrdersV5Execute(r)
}

/*
CreateTradeCancelBatchOrdersV5 POST / Cancel multiple orders

Cancel incomplete orders in batches. Maximum 20 orders can be canceled per request. Request parameters should be passed in the form of an array.

#### Rate Limit: 300 orders per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 

**_Unlike other endpoints, the rate limit of this endpoint is determined by the number of orders. If there is only one order in the request, it will consume the rate limit of `Cancel order`._**



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeCancelBatchOrdersV5Request
*/
func (a *TradeAPIService) CreateTradeCancelBatchOrdersV5(ctx context.Context) ApiCreateTradeCancelBatchOrdersV5Request {
	return ApiCreateTradeCancelBatchOrdersV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeCancelBatchOrdersV5Resp
func (a *TradeAPIService) CreateTradeCancelBatchOrdersV5Execute(r ApiCreateTradeCancelBatchOrdersV5Request) (*CreateTradeCancelBatchOrdersV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeCancelBatchOrdersV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeCancelBatchOrdersV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/cancel-batch-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeCancelBatchOrdersV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeCancelBatchOrdersV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeCancelBatchOrdersV5Req
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeCancelOrderV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeCancelOrderV5Req *CreateTradeCancelOrderV5Req
}

// The request body for CreateTradeCancelOrderV5
func (r ApiCreateTradeCancelOrderV5Request) CreateTradeCancelOrderV5Req(createTradeCancelOrderV5Req CreateTradeCancelOrderV5Req) ApiCreateTradeCancelOrderV5Request {
	r.createTradeCancelOrderV5Req = &createTradeCancelOrderV5Req
	return r
}

func (r ApiCreateTradeCancelOrderV5Request) Execute() (*CreateTradeCancelOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeCancelOrderV5Execute(r)
}

/*
CreateTradeCancelOrderV5 POST / Cancel order

Cancel an incomplete order.

#### Rate Limit: 60 requests per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeCancelOrderV5Request
*/
func (a *TradeAPIService) CreateTradeCancelOrderV5(ctx context.Context) ApiCreateTradeCancelOrderV5Request {
	return ApiCreateTradeCancelOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeCancelOrderV5Resp
func (a *TradeAPIService) CreateTradeCancelOrderV5Execute(r ApiCreateTradeCancelOrderV5Request) (*CreateTradeCancelOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeCancelOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeCancelOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/cancel-order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeCancelOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeCancelOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeCancelOrderV5Req
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeClosePositionV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeClosePositionV5Req *CreateTradeClosePositionV5Req
}

// The request body for CreateTradeClosePositionV5
func (r ApiCreateTradeClosePositionV5Request) CreateTradeClosePositionV5Req(createTradeClosePositionV5Req CreateTradeClosePositionV5Req) ApiCreateTradeClosePositionV5Request {
	r.createTradeClosePositionV5Req = &createTradeClosePositionV5Req
	return r
}

func (r ApiCreateTradeClosePositionV5Request) Execute() (*CreateTradeClosePositionV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeClosePositionV5Execute(r)
}

/*
CreateTradeClosePositionV5 POST / Close positions

Close the position of an instrument via a market order.

#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeClosePositionV5Request
*/
func (a *TradeAPIService) CreateTradeClosePositionV5(ctx context.Context) ApiCreateTradeClosePositionV5Request {
	return ApiCreateTradeClosePositionV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeClosePositionV5Resp
func (a *TradeAPIService) CreateTradeClosePositionV5Execute(r ApiCreateTradeClosePositionV5Request) (*CreateTradeClosePositionV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeClosePositionV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeClosePositionV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/close-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeClosePositionV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeClosePositionV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeClosePositionV5Req
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeEasyConvertV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeEasyConvertV5Req *CreateTradeEasyConvertV5Req
}

// The request body for CreateTradeEasyConvertV5
func (r ApiCreateTradeEasyConvertV5Request) CreateTradeEasyConvertV5Req(createTradeEasyConvertV5Req CreateTradeEasyConvertV5Req) ApiCreateTradeEasyConvertV5Request {
	r.createTradeEasyConvertV5Req = &createTradeEasyConvertV5Req
	return r
}

func (r ApiCreateTradeEasyConvertV5Request) Execute() (*CreateTradeEasyConvertV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeEasyConvertV5Execute(r)
}

/*
CreateTradeEasyConvertV5 POST / Place easy convert

Convert small currencies to mainstream currencies. 

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeEasyConvertV5Request
*/
func (a *TradeAPIService) CreateTradeEasyConvertV5(ctx context.Context) ApiCreateTradeEasyConvertV5Request {
	return ApiCreateTradeEasyConvertV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeEasyConvertV5Resp
func (a *TradeAPIService) CreateTradeEasyConvertV5Execute(r ApiCreateTradeEasyConvertV5Request) (*CreateTradeEasyConvertV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeEasyConvertV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeEasyConvertV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/easy-convert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeEasyConvertV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeEasyConvertV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeEasyConvertV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeMassCancelV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeMassCancelV5Req *CreateTradeMassCancelV5Req
}

// The request body for CreateTradeMassCancelV5
func (r ApiCreateTradeMassCancelV5Request) CreateTradeMassCancelV5Req(createTradeMassCancelV5Req CreateTradeMassCancelV5Req) ApiCreateTradeMassCancelV5Request {
	r.createTradeMassCancelV5Req = &createTradeMassCancelV5Req
	return r
}

func (r ApiCreateTradeMassCancelV5Request) Execute() (*CreateTradeMassCancelV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeMassCancelV5Execute(r)
}

/*
CreateTradeMassCancelV5 POST / Mass cancel order

Cancel all the MMP pending orders of an instrument family.



Only applicable to Option in Portfolio Margin mode, and MMP privilege is required.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeMassCancelV5Request
*/
func (a *TradeAPIService) CreateTradeMassCancelV5(ctx context.Context) ApiCreateTradeMassCancelV5Request {
	return ApiCreateTradeMassCancelV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeMassCancelV5Resp
func (a *TradeAPIService) CreateTradeMassCancelV5Execute(r ApiCreateTradeMassCancelV5Request) (*CreateTradeMassCancelV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeMassCancelV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeMassCancelV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/mass-cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeMassCancelV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeMassCancelV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeMassCancelV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeOneClickRepayV2V5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeOneClickRepayV2V5Req *CreateTradeOneClickRepayV2V5Req
}

// The request body for CreateTradeOneClickRepayV2V5
func (r ApiCreateTradeOneClickRepayV2V5Request) CreateTradeOneClickRepayV2V5Req(createTradeOneClickRepayV2V5Req CreateTradeOneClickRepayV2V5Req) ApiCreateTradeOneClickRepayV2V5Request {
	r.createTradeOneClickRepayV2V5Req = &createTradeOneClickRepayV2V5Req
	return r
}

func (r ApiCreateTradeOneClickRepayV2V5Request) Execute() (*CreateTradeOneClickRepayV2V5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeOneClickRepayV2V5Execute(r)
}

/*
CreateTradeOneClickRepayV2V5 POST / Trade one-click repay (New)

Trade one-click repay to repay debts. Only applicable to `SPOT mode`. 

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeOneClickRepayV2V5Request
*/
func (a *TradeAPIService) CreateTradeOneClickRepayV2V5(ctx context.Context) ApiCreateTradeOneClickRepayV2V5Request {
	return ApiCreateTradeOneClickRepayV2V5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeOneClickRepayV2V5Resp
func (a *TradeAPIService) CreateTradeOneClickRepayV2V5Execute(r ApiCreateTradeOneClickRepayV2V5Request) (*CreateTradeOneClickRepayV2V5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeOneClickRepayV2V5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeOneClickRepayV2V5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/one-click-repay-v2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeOneClickRepayV2V5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeOneClickRepayV2V5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeOneClickRepayV2V5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeOneClickRepayV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeOneClickRepayV5Req *CreateTradeOneClickRepayV5Req
}

// The request body for CreateTradeOneClickRepayV5
func (r ApiCreateTradeOneClickRepayV5Request) CreateTradeOneClickRepayV5Req(createTradeOneClickRepayV5Req CreateTradeOneClickRepayV5Req) ApiCreateTradeOneClickRepayV5Request {
	r.createTradeOneClickRepayV5Req = &createTradeOneClickRepayV5Req
	return r
}

func (r ApiCreateTradeOneClickRepayV5Request) Execute() (*CreateTradeOneClickRepayV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeOneClickRepayV5Execute(r)
}

/*
CreateTradeOneClickRepayV5 POST / Trade one-click repay

Trade one-click repay to repay cross debts. Isolated debts are not applicable.
The maximum repayment amount is based on the remaining available balance of funding and trading accounts.
Only applicable to `Multi-currency margin`/`Portfolio margin`.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeOneClickRepayV5Request
*/
func (a *TradeAPIService) CreateTradeOneClickRepayV5(ctx context.Context) ApiCreateTradeOneClickRepayV5Request {
	return ApiCreateTradeOneClickRepayV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeOneClickRepayV5Resp
func (a *TradeAPIService) CreateTradeOneClickRepayV5Execute(r ApiCreateTradeOneClickRepayV5Request) (*CreateTradeOneClickRepayV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeOneClickRepayV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeOneClickRepayV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/one-click-repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeOneClickRepayV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeOneClickRepayV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeOneClickRepayV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeOrderPrecheckV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeOrderPrecheckV5Req *CreateTradeOrderPrecheckV5Req
}

// The request body for CreateTradeOrderPrecheckV5
func (r ApiCreateTradeOrderPrecheckV5Request) CreateTradeOrderPrecheckV5Req(createTradeOrderPrecheckV5Req CreateTradeOrderPrecheckV5Req) ApiCreateTradeOrderPrecheckV5Request {
	r.createTradeOrderPrecheckV5Req = &createTradeOrderPrecheckV5Req
	return r
}

func (r ApiCreateTradeOrderPrecheckV5Request) Execute() (*CreateTradeOrderPrecheckV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeOrderPrecheckV5Execute(r)
}

/*
CreateTradeOrderPrecheckV5 POST / Order precheck

This endpoint is used to precheck the account information before and after placing the order. 


Only applicable to `Multi-currency margin mode`, and `Portfolio margin mode`.

#### Rate Limit: 5 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Trade 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeOrderPrecheckV5Request
*/
func (a *TradeAPIService) CreateTradeOrderPrecheckV5(ctx context.Context) ApiCreateTradeOrderPrecheckV5Request {
	return ApiCreateTradeOrderPrecheckV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeOrderPrecheckV5Resp
func (a *TradeAPIService) CreateTradeOrderPrecheckV5Execute(r ApiCreateTradeOrderPrecheckV5Request) (*CreateTradeOrderPrecheckV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeOrderPrecheckV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeOrderPrecheckV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/order-precheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeOrderPrecheckV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeOrderPrecheckV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeOrderPrecheckV5Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTradeOrderV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	createTradeOrderV5Req *CreateTradeOrderV5Req
}

// The request body for CreateTradeOrderV5
func (r ApiCreateTradeOrderV5Request) CreateTradeOrderV5Req(createTradeOrderV5Req CreateTradeOrderV5Req) ApiCreateTradeOrderV5Request {
	r.createTradeOrderV5Req = &createTradeOrderV5Req
	return r
}

func (r ApiCreateTradeOrderV5Request) Execute() (*CreateTradeOrderV5Resp, *http.Response, error) {
	return r.ApiService.CreateTradeOrderV5Execute(r)
}

/*
CreateTradeOrderV5 POST / Place order

You can place an order only if you have sufficient funds.

#### Rate Limit: 60 requests per 2 seconds 

#### Rate Limit of lead instruments for Copy Trading: 4 requests per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Trade 

Rate limit of this endpoint will also be affected by the rules  and .



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTradeOrderV5Request
*/
func (a *TradeAPIService) CreateTradeOrderV5(ctx context.Context) ApiCreateTradeOrderV5Request {
	return ApiCreateTradeOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTradeOrderV5Resp
func (a *TradeAPIService) CreateTradeOrderV5Execute(r ApiCreateTradeOrderV5Request) (*CreateTradeOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTradeOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CreateTradeOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTradeOrderV5Req == nil {
		return localVarReturnValue, nil, reportError("createTradeOrderV5Req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTradeOrderV5Req
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeAccountRateLimitV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
}

func (r ApiGetTradeAccountRateLimitV5Request) Execute() (*GetTradeAccountRateLimitV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeAccountRateLimitV5Execute(r)
}

/*
GetTradeAccountRateLimitV5 GET / Account rate limit

Get account rate limit related information. 



Only new order requests and amendment order requests will be counted towards this limit. For batch order requests consisting of multiple orders, each order will be counted individually. 



For details, please refer to 

#### Rate Limit: 1 request per second 

#### Rate limit rule: User ID 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeAccountRateLimitV5Request
*/
func (a *TradeAPIService) GetTradeAccountRateLimitV5(ctx context.Context) ApiGetTradeAccountRateLimitV5Request {
	return ApiGetTradeAccountRateLimitV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeAccountRateLimitV5Resp
func (a *TradeAPIService) GetTradeAccountRateLimitV5Execute(r ApiGetTradeAccountRateLimitV5Request) (*GetTradeAccountRateLimitV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeAccountRateLimitV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeAccountRateLimitV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/account-rate-limit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeEasyConvertCurrencyListV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	source *string
}

// Funding source  &#x60;1&#x60;: Trading account  &#x60;2&#x60;: Funding account  The default is &#x60;1&#x60;.
func (r ApiGetTradeEasyConvertCurrencyListV5Request) Source(source string) ApiGetTradeEasyConvertCurrencyListV5Request {
	r.source = &source
	return r
}

func (r ApiGetTradeEasyConvertCurrencyListV5Request) Execute() (*GetTradeEasyConvertCurrencyListV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeEasyConvertCurrencyListV5Execute(r)
}

/*
GetTradeEasyConvertCurrencyListV5 GET / Easy convert currency list

Get list of small convertibles and mainstream currencies. Only applicable to the crypto balance less than $10.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeEasyConvertCurrencyListV5Request
*/
func (a *TradeAPIService) GetTradeEasyConvertCurrencyListV5(ctx context.Context) ApiGetTradeEasyConvertCurrencyListV5Request {
	return ApiGetTradeEasyConvertCurrencyListV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeEasyConvertCurrencyListV5Resp
func (a *TradeAPIService) GetTradeEasyConvertCurrencyListV5Execute(r ApiGetTradeEasyConvertCurrencyListV5Request) (*GetTradeEasyConvertCurrencyListV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeEasyConvertCurrencyListV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeEasyConvertCurrencyListV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/easy-convert-currency-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	} else {
		var defaultValue string = ""
		r.source = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeEasyConvertHistoryV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	after *string
	before *string
	limit *string
}

// Pagination of data to return records earlier than the requested time (exclude), Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeEasyConvertHistoryV5Request) After(after string) ApiGetTradeEasyConvertHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested time (exclude), Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeEasyConvertHistoryV5Request) Before(before string) ApiGetTradeEasyConvertHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradeEasyConvertHistoryV5Request) Limit(limit string) ApiGetTradeEasyConvertHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeEasyConvertHistoryV5Request) Execute() (*GetTradeEasyConvertHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeEasyConvertHistoryV5Execute(r)
}

/*
GetTradeEasyConvertHistoryV5 GET / Easy convert history

Get the history and status of easy convert trades in the past 7 days.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeEasyConvertHistoryV5Request
*/
func (a *TradeAPIService) GetTradeEasyConvertHistoryV5(ctx context.Context) ApiGetTradeEasyConvertHistoryV5Request {
	return ApiGetTradeEasyConvertHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeEasyConvertHistoryV5Resp
func (a *TradeAPIService) GetTradeEasyConvertHistoryV5Execute(r ApiGetTradeEasyConvertHistoryV5Request) (*GetTradeEasyConvertHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeEasyConvertHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeEasyConvertHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/easy-convert-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeFillsHistoryV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
	ordId *string
	subType *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetTradeFillsHistoryV5Request) InstType(instType string) ApiGetTradeFillsHistoryV5Request {
	r.instType = &instType
	return r
}

// Underlying  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeFillsHistoryV5Request) Uly(uly string) ApiGetTradeFillsHistoryV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeFillsHistoryV5Request) InstFamily(instFamily string) ApiGetTradeFillsHistoryV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetTradeFillsHistoryV5Request) InstId(instId string) ApiGetTradeFillsHistoryV5Request {
	r.instId = &instId
	return r
}

// Order ID
func (r ApiGetTradeFillsHistoryV5Request) OrdId(ordId string) ApiGetTradeFillsHistoryV5Request {
	r.ordId = &ordId
	return r
}

// Transaction type   &#x60;1&#x60;: Buy  &#x60;2&#x60;: Sell  &#x60;3&#x60;: Open long  &#x60;4&#x60;: Open short  &#x60;5&#x60;: Close long  &#x60;6&#x60;: Close short   &#x60;100&#x60;: Partial liquidation close long  &#x60;101&#x60;: Partial liquidation close short  &#x60;102&#x60;: Partial liquidation buy  &#x60;103&#x60;: Partial liquidation sell  &#x60;104&#x60;: Liquidation long  &#x60;105&#x60;: Liquidation short  &#x60;106&#x60;: Liquidation buy   &#x60;107&#x60;: Liquidation sell   &#x60;110&#x60;: Liquidation transfer in  &#x60;111&#x60;: Liquidation transfer out   &#x60;118&#x60;: System token conversion transfer in  &#x60;119&#x60;: System token conversion transfer out   &#x60;125&#x60;: ADL close long  &#x60;126&#x60;: ADL close short  &#x60;127&#x60;: ADL buy  &#x60;128&#x60;: ADL sell   &#x60;212&#x60;: Auto borrow of quick margin  &#x60;213&#x60;: Auto repay of quick margin   &#x60;204&#x60;: block trade buy  &#x60;205&#x60;: block trade sell  &#x60;206&#x60;: block trade open long  &#x60;207&#x60;: block trade open short  &#x60;208&#x60;: block trade close long  &#x60;209&#x60;: block trade close short  &#x60;236&#x60;: Easy convert in  &#x60;237&#x60;: Easy convert out  &#x60;270&#x60;: Spread trading buy  &#x60;271&#x60;: Spread trading sell  &#x60;272&#x60;: Spread trading open long  &#x60;273&#x60;: Spread trading open short  &#x60;274&#x60;: Spread trading close long  &#x60;275&#x60;: Spread trading close short
func (r ApiGetTradeFillsHistoryV5Request) SubType(subType string) ApiGetTradeFillsHistoryV5Request {
	r.subType = &subType
	return r
}

// Pagination of data to return records earlier than the requested &#x60;billId&#x60;
func (r ApiGetTradeFillsHistoryV5Request) After(after string) ApiGetTradeFillsHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;billId&#x60;
func (r ApiGetTradeFillsHistoryV5Request) Before(before string) ApiGetTradeFillsHistoryV5Request {
	r.before = &before
	return r
}

// Filter with a begin timestamp &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeFillsHistoryV5Request) Begin(begin string) ApiGetTradeFillsHistoryV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeFillsHistoryV5Request) End(end string) ApiGetTradeFillsHistoryV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetTradeFillsHistoryV5Request) Limit(limit string) ApiGetTradeFillsHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeFillsHistoryV5Request) Execute() (*GetTradeFillsHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeFillsHistoryV5Execute(r)
}

/*
GetTradeFillsHistoryV5 GET / Transaction details (last 3 months)

Retrieve recently-filled transaction details in the last 3 months.

#### Rate Limit: 10 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeFillsHistoryV5Request
*/
func (a *TradeAPIService) GetTradeFillsHistoryV5(ctx context.Context) ApiGetTradeFillsHistoryV5Request {
	return ApiGetTradeFillsHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeFillsHistoryV5Resp
func (a *TradeAPIService) GetTradeFillsHistoryV5Execute(r ApiGetTradeFillsHistoryV5Request) (*GetTradeFillsHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeFillsHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeFillsHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/fills-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordId", r.ordId, "form", "")
	} else {
		var defaultValue string = ""
		r.ordId = &defaultValue
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	} else {
		var defaultValue string = ""
		r.subType = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeFillsV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
	ordId *string
	subType *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetTradeFillsV5Request) InstType(instType string) ApiGetTradeFillsV5Request {
	r.instType = &instType
	return r
}

// Underlying  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeFillsV5Request) Uly(uly string) ApiGetTradeFillsV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeFillsV5Request) InstFamily(instFamily string) ApiGetTradeFillsV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetTradeFillsV5Request) InstId(instId string) ApiGetTradeFillsV5Request {
	r.instId = &instId
	return r
}

// Order ID
func (r ApiGetTradeFillsV5Request) OrdId(ordId string) ApiGetTradeFillsV5Request {
	r.ordId = &ordId
	return r
}

// Transaction type   &#x60;1&#x60;: Buy  &#x60;2&#x60;: Sell  &#x60;3&#x60;: Open long  &#x60;4&#x60;: Open short  &#x60;5&#x60;: Close long  &#x60;6&#x60;: Close short   &#x60;100&#x60;: Partial liquidation close long  &#x60;101&#x60;: Partial liquidation close short  &#x60;102&#x60;: Partial liquidation buy  &#x60;103&#x60;: Partial liquidation sell  &#x60;104&#x60;: Liquidation long  &#x60;105&#x60;: Liquidation short  &#x60;106&#x60;: Liquidation buy   &#x60;107&#x60;: Liquidation sell   &#x60;110&#x60;: Liquidation transfer in  &#x60;111&#x60;: Liquidation transfer out   &#x60;118&#x60;: System token conversion transfer in  &#x60;119&#x60;: System token conversion transfer out   &#x60;125&#x60;: ADL close long  &#x60;126&#x60;: ADL close short  &#x60;127&#x60;: ADL buy  &#x60;128&#x60;: ADL sell   &#x60;212&#x60;: Auto borrow of quick margin  &#x60;213&#x60;: Auto repay of quick margin   &#x60;204&#x60;: block trade buy  &#x60;205&#x60;: block trade sell  &#x60;206&#x60;: block trade open long  &#x60;207&#x60;: block trade open short  &#x60;208&#x60;: block trade close long  &#x60;209&#x60;: block trade close short  &#x60;236&#x60;: Easy convert in  &#x60;237&#x60;: Easy convert out  &#x60;270&#x60;: Spread trading buy  &#x60;271&#x60;: Spread trading sell  &#x60;272&#x60;: Spread trading open long  &#x60;273&#x60;: Spread trading open short  &#x60;274&#x60;: Spread trading close long  &#x60;275&#x60;: Spread trading close short
func (r ApiGetTradeFillsV5Request) SubType(subType string) ApiGetTradeFillsV5Request {
	r.subType = &subType
	return r
}

// Pagination of data to return records earlier than the requested &#x60;billId&#x60;
func (r ApiGetTradeFillsV5Request) After(after string) ApiGetTradeFillsV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;billId&#x60;
func (r ApiGetTradeFillsV5Request) Before(before string) ApiGetTradeFillsV5Request {
	r.before = &before
	return r
}

// Filter with a begin timestamp  &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeFillsV5Request) Begin(begin string) ApiGetTradeFillsV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp  &#x60;ts&#x60;. Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeFillsV5Request) End(end string) ApiGetTradeFillsV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetTradeFillsV5Request) Limit(limit string) ApiGetTradeFillsV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeFillsV5Request) Execute() (*GetTradeFillsV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeFillsV5Execute(r)
}

/*
GetTradeFillsV5 GET / Transaction details (last 3 days)

Retrieve recently-filled transaction details in the last 3 day.

#### Rate Limit: 60 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeFillsV5Request
*/
func (a *TradeAPIService) GetTradeFillsV5(ctx context.Context) ApiGetTradeFillsV5Request {
	return ApiGetTradeFillsV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeFillsV5Resp
func (a *TradeAPIService) GetTradeFillsV5Execute(r ApiGetTradeFillsV5Request) (*GetTradeFillsV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeFillsV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeFillsV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/fills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordId", r.ordId, "form", "")
	} else {
		var defaultValue string = ""
		r.ordId = &defaultValue
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	} else {
		var defaultValue string = ""
		r.subType = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOneClickRepayCurrencyListV2V5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
}

func (r ApiGetTradeOneClickRepayCurrencyListV2V5Request) Execute() (*GetTradeOneClickRepayCurrencyListV2V5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOneClickRepayCurrencyListV2V5Execute(r)
}

/*
GetTradeOneClickRepayCurrencyListV2V5 GET / One-click repay currency list (New)

Get list of debt currency data and repay currencies. Only applicable to `SPOT mode`.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOneClickRepayCurrencyListV2V5Request
*/
func (a *TradeAPIService) GetTradeOneClickRepayCurrencyListV2V5(ctx context.Context) ApiGetTradeOneClickRepayCurrencyListV2V5Request {
	return ApiGetTradeOneClickRepayCurrencyListV2V5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOneClickRepayCurrencyListV2V5Resp
func (a *TradeAPIService) GetTradeOneClickRepayCurrencyListV2V5Execute(r ApiGetTradeOneClickRepayCurrencyListV2V5Request) (*GetTradeOneClickRepayCurrencyListV2V5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOneClickRepayCurrencyListV2V5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOneClickRepayCurrencyListV2V5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/one-click-repay-currency-list-v2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOneClickRepayCurrencyListV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	debtType *string
}

// Debt type   &#x60;cross&#x60;: cross   &#x60;isolated&#x60;: isolated
func (r ApiGetTradeOneClickRepayCurrencyListV5Request) DebtType(debtType string) ApiGetTradeOneClickRepayCurrencyListV5Request {
	r.debtType = &debtType
	return r
}

func (r ApiGetTradeOneClickRepayCurrencyListV5Request) Execute() (*GetTradeOneClickRepayCurrencyListV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOneClickRepayCurrencyListV5Execute(r)
}

/*
GetTradeOneClickRepayCurrencyListV5 GET / One-click repay currency list

Get list of debt currency data and repay currencies. Debt currencies include both cross and isolated debts. Only applicable to `Multi-currency margin`/`Portfolio margin`.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOneClickRepayCurrencyListV5Request
*/
func (a *TradeAPIService) GetTradeOneClickRepayCurrencyListV5(ctx context.Context) ApiGetTradeOneClickRepayCurrencyListV5Request {
	return ApiGetTradeOneClickRepayCurrencyListV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOneClickRepayCurrencyListV5Resp
func (a *TradeAPIService) GetTradeOneClickRepayCurrencyListV5Execute(r ApiGetTradeOneClickRepayCurrencyListV5Request) (*GetTradeOneClickRepayCurrencyListV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOneClickRepayCurrencyListV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOneClickRepayCurrencyListV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/one-click-repay-currency-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.debtType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "debtType", r.debtType, "form", "")
	} else {
		var defaultValue string = ""
		r.debtType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOneClickRepayHistoryV2V5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	after *string
	before *string
	limit *string
}

// Pagination of data to return records earlier than (included) the requested time &#x60;ts&#x60; , Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeOneClickRepayHistoryV2V5Request) After(after string) ApiGetTradeOneClickRepayHistoryV2V5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than (included) the requested time &#x60;ts&#x60;, Unix timestamp format in milliseconds, e.g. &#x60;1597026383085&#x60;
func (r ApiGetTradeOneClickRepayHistoryV2V5Request) Before(before string) ApiGetTradeOneClickRepayHistoryV2V5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradeOneClickRepayHistoryV2V5Request) Limit(limit string) ApiGetTradeOneClickRepayHistoryV2V5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeOneClickRepayHistoryV2V5Request) Execute() (*GetTradeOneClickRepayHistoryV2V5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOneClickRepayHistoryV2V5Execute(r)
}

/*
GetTradeOneClickRepayHistoryV2V5 GET / One-click repay history (New)

Get the history and status of one-click repay trades in the past 7 days. Only applicable to `SPOT mode`.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOneClickRepayHistoryV2V5Request
*/
func (a *TradeAPIService) GetTradeOneClickRepayHistoryV2V5(ctx context.Context) ApiGetTradeOneClickRepayHistoryV2V5Request {
	return ApiGetTradeOneClickRepayHistoryV2V5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOneClickRepayHistoryV2V5Resp
func (a *TradeAPIService) GetTradeOneClickRepayHistoryV2V5Execute(r ApiGetTradeOneClickRepayHistoryV2V5Request) (*GetTradeOneClickRepayHistoryV2V5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOneClickRepayHistoryV2V5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOneClickRepayHistoryV2V5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/one-click-repay-history-v2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOneClickRepayHistoryV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	after *string
	before *string
	limit *string
}

// Pagination of data to return records earlier than the requested time, Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetTradeOneClickRepayHistoryV5Request) After(after string) ApiGetTradeOneClickRepayHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested time, Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetTradeOneClickRepayHistoryV5Request) Before(before string) ApiGetTradeOneClickRepayHistoryV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is 100. The default is 100.
func (r ApiGetTradeOneClickRepayHistoryV5Request) Limit(limit string) ApiGetTradeOneClickRepayHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeOneClickRepayHistoryV5Request) Execute() (*GetTradeOneClickRepayHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOneClickRepayHistoryV5Execute(r)
}

/*
GetTradeOneClickRepayHistoryV5 GET / One-click repay history

Get the history and status of one-click repay trades in the past 7 days. Only applicable to `Multi-currency margin`/`Portfolio margin`.

#### Rate Limit: 1 request per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOneClickRepayHistoryV5Request
*/
func (a *TradeAPIService) GetTradeOneClickRepayHistoryV5(ctx context.Context) ApiGetTradeOneClickRepayHistoryV5Request {
	return ApiGetTradeOneClickRepayHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOneClickRepayHistoryV5Resp
func (a *TradeAPIService) GetTradeOneClickRepayHistoryV5Execute(r ApiGetTradeOneClickRepayHistoryV5Request) (*GetTradeOneClickRepayHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOneClickRepayHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOneClickRepayHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/one-click-repay-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOrderV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	instId *string
	ordId *string
	clOrdId *string
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;  Only applicable to live instruments
func (r ApiGetTradeOrderV5Request) InstId(instId string) ApiGetTradeOrderV5Request {
	r.instId = &instId
	return r
}

// Order ID   Either &#x60;ordId&#x60; or &#x60;clOrdId&#x60; is required, if both are passed, &#x60;ordId&#x60; will be used
func (r ApiGetTradeOrderV5Request) OrdId(ordId string) ApiGetTradeOrderV5Request {
	r.ordId = &ordId
	return r
}

// Client Order ID as assigned by the client  If the &#x60;clOrdId&#x60; is associated with multiple orders, only the latest one will be returned.
func (r ApiGetTradeOrderV5Request) ClOrdId(clOrdId string) ApiGetTradeOrderV5Request {
	r.clOrdId = &clOrdId
	return r
}

func (r ApiGetTradeOrderV5Request) Execute() (*GetTradeOrderV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOrderV5Execute(r)
}

/*
GetTradeOrderV5 GET / Order details

Retrieve order details.

#### Rate Limit: 60 requests per 2 seconds 

#### Rate limit rule (except Options): User ID + Instrument ID 

#### Rate limit rule (Options only): User ID + Instrument Family 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOrderV5Request
*/
func (a *TradeAPIService) GetTradeOrderV5(ctx context.Context) ApiGetTradeOrderV5Request {
	return ApiGetTradeOrderV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOrderV5Resp
func (a *TradeAPIService) GetTradeOrderV5Execute(r ApiGetTradeOrderV5Request) (*GetTradeOrderV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOrderV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOrderV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instId == nil {
		return localVarReturnValue, nil, reportError("instId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	if r.ordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordId", r.ordId, "form", "")
	} else {
		var defaultValue string = ""
		r.ordId = &defaultValue
	}
	if r.clOrdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clOrdId", r.clOrdId, "form", "")
	} else {
		var defaultValue string = ""
		r.clOrdId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOrdersHistoryArchiveV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
	ordType *string
	state *string
	category *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetTradeOrdersHistoryArchiveV5Request) InstType(instType string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.instType = &instType
	return r
}

// Underlying  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeOrdersHistoryArchiveV5Request) Uly(uly string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeOrdersHistoryArchiveV5Request) InstFamily(instFamily string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID, e.g. &#x60;BTC-USD-200927&#x60;
func (r ApiGetTradeOrdersHistoryArchiveV5Request) InstId(instId string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.instId = &instId
	return r
}

// Order type   &#x60;market&#x60;: Market order   &#x60;limit&#x60;: Limit order   &#x60;post_only&#x60;: Post-only order   &#x60;fok&#x60;: Fill-or-kill order   &#x60;ioc&#x60;: Immediate-or-cancel order    &#x60;optimal_limit_ioc&#x60;: Market order with immediate-or-cancel order  &#x60;mmp&#x60;: Market Maker Protection (only applicable to Option in Portfolio Margin mode)  &#x60;mmp_and_post_only&#x60;: Market Maker Protection and Post-only order(only applicable to Option in Portfolio Margin mode)   &#x60;op_fok&#x60;: Simple options (fok)
func (r ApiGetTradeOrdersHistoryArchiveV5Request) OrdType(ordType string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.ordType = &ordType
	return r
}

// State  &#x60;canceled&#x60;   &#x60;filled&#x60;  &#x60;mmp_canceled&#x60;: Order canceled automatically due to Market Maker Protection
func (r ApiGetTradeOrdersHistoryArchiveV5Request) State(state string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.state = &state
	return r
}

// Category   &#x60;twap&#x60;   &#x60;adl&#x60;  &#x60;full_liquidation&#x60;  &#x60;partial_liquidation&#x60;  &#x60;delivery&#x60;    &#x60;ddh&#x60;: Delta dynamic hedge
func (r ApiGetTradeOrdersHistoryArchiveV5Request) Category(category string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.category = &category
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ordId&#x60;
func (r ApiGetTradeOrdersHistoryArchiveV5Request) After(after string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ordId&#x60;
func (r ApiGetTradeOrdersHistoryArchiveV5Request) Before(before string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.before = &before
	return r
}

// Filter with a begin timestamp &#x60;cTime&#x60;. Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetTradeOrdersHistoryArchiveV5Request) Begin(begin string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp &#x60;cTime&#x60;. Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetTradeOrdersHistoryArchiveV5Request) End(end string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetTradeOrdersHistoryArchiveV5Request) Limit(limit string) ApiGetTradeOrdersHistoryArchiveV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeOrdersHistoryArchiveV5Request) Execute() (*GetTradeOrdersHistoryArchiveV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOrdersHistoryArchiveV5Execute(r)
}

/*
GetTradeOrdersHistoryArchiveV5 GET / Order history (last 3 months)

Get completed orders which are placed in the last 3 months, including those placed 3 months ago but completed in the last 3 months.  



#### Rate Limit: 20 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOrdersHistoryArchiveV5Request
*/
func (a *TradeAPIService) GetTradeOrdersHistoryArchiveV5(ctx context.Context) ApiGetTradeOrdersHistoryArchiveV5Request {
	return ApiGetTradeOrdersHistoryArchiveV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOrdersHistoryArchiveV5Resp
func (a *TradeAPIService) GetTradeOrdersHistoryArchiveV5Execute(r ApiGetTradeOrdersHistoryArchiveV5Request) (*GetTradeOrdersHistoryArchiveV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOrdersHistoryArchiveV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOrdersHistoryArchiveV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/orders-history-archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	} else {
		var defaultValue string = ""
		r.ordType = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	} else {
		var defaultValue string = ""
		r.category = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOrdersHistoryV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
	ordType *string
	state *string
	category *string
	after *string
	before *string
	begin *string
	end *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetTradeOrdersHistoryV5Request) InstType(instType string) ApiGetTradeOrdersHistoryV5Request {
	r.instType = &instType
	return r
}

// Underlying  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeOrdersHistoryV5Request) Uly(uly string) ApiGetTradeOrdersHistoryV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeOrdersHistoryV5Request) InstFamily(instFamily string) ApiGetTradeOrdersHistoryV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID, e.g. &#x60;BTC-USDT&#x60;
func (r ApiGetTradeOrdersHistoryV5Request) InstId(instId string) ApiGetTradeOrdersHistoryV5Request {
	r.instId = &instId
	return r
}

// Order type  &#x60;market&#x60;: market order   &#x60;limit&#x60;: limit order   &#x60;post_only&#x60;: Post-only order   &#x60;fok&#x60;: Fill-or-kill order   &#x60;ioc&#x60;: Immediate-or-cancel order    &#x60;optimal_limit_ioc&#x60;: Market order with immediate-or-cancel order  &#x60;mmp&#x60;: Market Maker Protection (only applicable to Option in Portfolio Margin mode)  &#x60;mmp_and_post_only&#x60;: Market Maker Protection and Post-only order(only applicable to Option in Portfolio Margin mode)   &#x60;op_fok&#x60;: Simple options (fok)
func (r ApiGetTradeOrdersHistoryV5Request) OrdType(ordType string) ApiGetTradeOrdersHistoryV5Request {
	r.ordType = &ordType
	return r
}

// State  &#x60;canceled&#x60;  &#x60;filled&#x60;  &#x60;mmp_canceled&#x60;: Order canceled automatically due to Market Maker Protection
func (r ApiGetTradeOrdersHistoryV5Request) State(state string) ApiGetTradeOrdersHistoryV5Request {
	r.state = &state
	return r
}

// Category   &#x60;twap&#x60;   &#x60;adl&#x60;  &#x60;full_liquidation&#x60;  &#x60;partial_liquidation&#x60;   &#x60;delivery&#x60;    &#x60;ddh&#x60;: Delta dynamic hedge
func (r ApiGetTradeOrdersHistoryV5Request) Category(category string) ApiGetTradeOrdersHistoryV5Request {
	r.category = &category
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ordId&#x60;
func (r ApiGetTradeOrdersHistoryV5Request) After(after string) ApiGetTradeOrdersHistoryV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ordId&#x60;
func (r ApiGetTradeOrdersHistoryV5Request) Before(before string) ApiGetTradeOrdersHistoryV5Request {
	r.before = &before
	return r
}

// Filter with a begin timestamp &#x60;cTime&#x60;. Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetTradeOrdersHistoryV5Request) Begin(begin string) ApiGetTradeOrdersHistoryV5Request {
	r.begin = &begin
	return r
}

// Filter with an end timestamp &#x60;cTime&#x60;. Unix timestamp format in milliseconds, e.g. 1597026383085
func (r ApiGetTradeOrdersHistoryV5Request) End(end string) ApiGetTradeOrdersHistoryV5Request {
	r.end = &end
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetTradeOrdersHistoryV5Request) Limit(limit string) ApiGetTradeOrdersHistoryV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeOrdersHistoryV5Request) Execute() (*GetTradeOrdersHistoryV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOrdersHistoryV5Execute(r)
}

/*
GetTradeOrdersHistoryV5 GET / Order history (last 7 days)

Get completed orders which are placed in the last 7 days, including those placed 7 days ago but completed in the last 7 days.  



The incomplete orders that have been canceled are only reserved for 2 hours.

#### Rate Limit: 40 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOrdersHistoryV5Request
*/
func (a *TradeAPIService) GetTradeOrdersHistoryV5(ctx context.Context) ApiGetTradeOrdersHistoryV5Request {
	return ApiGetTradeOrdersHistoryV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOrdersHistoryV5Resp
func (a *TradeAPIService) GetTradeOrdersHistoryV5Execute(r ApiGetTradeOrdersHistoryV5Request) (*GetTradeOrdersHistoryV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOrdersHistoryV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOrdersHistoryV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/orders-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instType == nil {
		return localVarReturnValue, nil, reportError("instType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	} else {
		var defaultValue string = ""
		r.ordType = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	} else {
		var defaultValue string = ""
		r.category = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	} else {
		var defaultValue string = ""
		r.begin = &defaultValue
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	} else {
		var defaultValue string = ""
		r.end = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradeOrdersPendingV5Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	instType *string
	uly *string
	instFamily *string
	instId *string
	ordType *string
	state *string
	after *string
	before *string
	limit *string
}

// Instrument type  &#x60;SPOT&#x60;  &#x60;MARGIN&#x60;  &#x60;SWAP&#x60;  &#x60;FUTURES&#x60;  &#x60;OPTION&#x60;
func (r ApiGetTradeOrdersPendingV5Request) InstType(instType string) ApiGetTradeOrdersPendingV5Request {
	r.instType = &instType
	return r
}

// Underlying  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeOrdersPendingV5Request) Uly(uly string) ApiGetTradeOrdersPendingV5Request {
	r.uly = &uly
	return r
}

// Instrument family  Applicable to &#x60;FUTURES&#x60;/&#x60;SWAP&#x60;/&#x60;OPTION&#x60;
func (r ApiGetTradeOrdersPendingV5Request) InstFamily(instFamily string) ApiGetTradeOrdersPendingV5Request {
	r.instFamily = &instFamily
	return r
}

// Instrument ID, e.g. &#x60;BTC-USD-200927&#x60;
func (r ApiGetTradeOrdersPendingV5Request) InstId(instId string) ApiGetTradeOrdersPendingV5Request {
	r.instId = &instId
	return r
}

// Order type   &#x60;market&#x60;: Market order   &#x60;limit&#x60;: Limit order   &#x60;post_only&#x60;: Post-only order   &#x60;fok&#x60;: Fill-or-kill order   &#x60;ioc&#x60;: Immediate-or-cancel order    &#x60;optimal_limit_ioc&#x60;: Market order with immediate-or-cancel order   &#x60;mmp&#x60;: Market Maker Protection (only applicable to Option in Portfolio Margin mode)  &#x60;mmp_and_post_only&#x60;: Market Maker Protection and Post-only order(only applicable to Option in Portfolio Margin mode)   &#x60;op_fok&#x60;: Simple options (fok)
func (r ApiGetTradeOrdersPendingV5Request) OrdType(ordType string) ApiGetTradeOrdersPendingV5Request {
	r.ordType = &ordType
	return r
}

// State  &#x60;live&#x60;   &#x60;partially_filled&#x60;
func (r ApiGetTradeOrdersPendingV5Request) State(state string) ApiGetTradeOrdersPendingV5Request {
	r.state = &state
	return r
}

// Pagination of data to return records earlier than the requested &#x60;ordId&#x60;
func (r ApiGetTradeOrdersPendingV5Request) After(after string) ApiGetTradeOrdersPendingV5Request {
	r.after = &after
	return r
}

// Pagination of data to return records newer than the requested &#x60;ordId&#x60;
func (r ApiGetTradeOrdersPendingV5Request) Before(before string) ApiGetTradeOrdersPendingV5Request {
	r.before = &before
	return r
}

// Number of results per request. The maximum is &#x60;100&#x60;; The default is &#x60;100&#x60;
func (r ApiGetTradeOrdersPendingV5Request) Limit(limit string) ApiGetTradeOrdersPendingV5Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradeOrdersPendingV5Request) Execute() (*GetTradeOrdersPendingV5Resp, *http.Response, error) {
	return r.ApiService.GetTradeOrdersPendingV5Execute(r)
}

/*
GetTradeOrdersPendingV5 GET / Order List

Retrieve all incomplete orders under the current account.

#### Rate Limit: 60 requests per 2 seconds 

#### Rate limit rule: User ID 

#### Permission: Read 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradeOrdersPendingV5Request
*/
func (a *TradeAPIService) GetTradeOrdersPendingV5(ctx context.Context) ApiGetTradeOrdersPendingV5Request {
	return ApiGetTradeOrdersPendingV5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTradeOrdersPendingV5Resp
func (a *TradeAPIService) GetTradeOrdersPendingV5Execute(r ApiGetTradeOrdersPendingV5Request) (*GetTradeOrdersPendingV5Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTradeOrdersPendingV5Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.GetTradeOrdersPendingV5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v5/trade/orders-pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instType", r.instType, "form", "")
	} else {
		var defaultValue string = ""
		r.instType = &defaultValue
	}
	if r.uly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uly", r.uly, "form", "")
	} else {
		var defaultValue string = ""
		r.uly = &defaultValue
	}
	if r.instFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instFamily", r.instFamily, "form", "")
	} else {
		var defaultValue string = ""
		r.instFamily = &defaultValue
	}
	if r.instId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instId", r.instId, "form", "")
	} else {
		var defaultValue string = ""
		r.instId = &defaultValue
	}
	if r.ordType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordType", r.ordType, "form", "")
	} else {
		var defaultValue string = ""
		r.ordType = &defaultValue
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = ""
		r.state = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue string = ""
		r.after = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue string = ""
		r.before = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = ""
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextOKXAuth).(Auth); ok {
			localVarHeaderParams["OK-ACCESS-KEY"] = auth.APIKey
			localVarHeaderParams["OK-ACCESS-PASSPHRASE"] = auth.Passphrase
		}
	}
	
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = strings.TrimSpace(fmt.Sprintf("%s %s", localVarHTTPResponse.Status, *v.Msg))
			newErr.model = &v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if *localVarReturnValue.Code != "0" {
		var v *APIError = &APIError{
			Code: localVarReturnValue.Code,
			Msg: localVarReturnValue.Msg,
		}
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: *localVarReturnValue.Msg,
			model: v,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
